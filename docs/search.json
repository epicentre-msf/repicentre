[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "This page will (eventually) contain external resources to continue your R learning journey."
  },
  {
    "objectID": "explore.fr.html",
    "href": "explore.fr.html",
    "title": "Explorer",
    "section": "",
    "text": "Choisissez votre propre aventure en parcourant toutes les sessions disponibles.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBasic Data Manipulation\n\n\n\nCore\n\n\nData Manipulation\n\n\nData Cleaning\n\n\n\nAn introduction to data manipulation and cleaning using {dplyr}\n\n\n\n\n\n\nFeb 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Manipulation with Conditional Logic\n\n\n\nCore\n\n\nData Manipulation\n\n\nData Cleaning\n\n\nLogic\n\n\n\nUsing {dplyr} and conditional logic to filter and recode data\n\n\n\n\n\n\nFeb 12, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImport data\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCreate an Rstudio project, install useful packages and start importing data to work in R\n\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des donn√©es\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCr√©ez un projet Rstudio, installez les paquets utiles et importez des donn√©es pour travailler dans R.\n\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nYour first steps in R. Learn your way around Rstudio, and meet some common R objects.\n\n\n\n\n\n\nFeb 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction √† R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\nFeb 9, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSession Title\n\n\n\nCore\n\n\n\nShort description (appears on cards in pathway / explore pages)\n\n\n\n\n\n\nFeb 4, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nSummary tables\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nCreate summary tables.\n\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{repicentre}",
    "section": "",
    "text": "Welcome to {repicentre}\nAn open source platform to learn R for humanitarian contexts. What would you like to do?\n\n\n\n\n\nLearn Follow a linear path starting with the basics  Start\n\n\n\n\n\nExplore Browse our full catelogue of self paced tutorisals  Start\n\n\n\n\n\nExpand Go even further with a list of external resouces  Start"
  },
  {
    "objectID": "index.fr.html",
    "href": "index.fr.html",
    "title": "{repicentre}",
    "section": "",
    "text": "Bienvenue √† {repicentre}\nUne plateforme open source pour apprendre R dans les contextes humanitaires. Qu‚Äôaimeriez-vous faire ?\n\n\n\n\n\nApprendre Parcours lin√©aire en commen√ßant par les bases  Start\n\n\n\n\n\nExplorer Catalogue complet de cours d‚Äôautoformation  Start\n\n\n\n\n\n√âlargir Ressources externes pour aller plus loin  Start"
  },
  {
    "objectID": "about.html#hey-there",
    "href": "about.html#hey-there",
    "title": "About",
    "section": "Hey There",
    "text": "Hey There\nWelcome to {repicentre}, an open source site developed by Epicentre to support folks learning R for humanitarian contexts. The site is composed of self paced tutorials and has two main options for learning:\n\nLinear. Designed for people with zero prior experience in R, the linear course will walk you through core R concepts using a case study about measles in Chad. The course covers the following concepts:\n\nData Structures and the RStudio Interface\nData Importation\nData Manipulation\nData Cleaning\nData Aggregation\nData Visualization\n\nChoose Your Own Adventure. If you have a bit more experience or if you are looking for a particular subject, feel free to explore the full range of tutorials. Tutorials are tagged with categories and designed to be self contained."
  },
  {
    "objectID": "about.html#recommendations-and-requests",
    "href": "about.html#recommendations-and-requests",
    "title": "About",
    "section": "Recommendations and Requests",
    "text": "Recommendations and Requests\nIs there a topic that you would like to see a tutorial on that isn‚Äôt currently available? Great! Feel free to let us know by opening an issue on the GitHub repository associated with this website. If you aren‚Äôt familiar with how to open an issue, please get in touch with Cat Eisenhauer instead."
  },
  {
    "objectID": "about.html#contributing",
    "href": "about.html#contributing",
    "title": "About",
    "section": "Contributing",
    "text": "Contributing\nWould you like to help write or maintain some tutorials? Increadible! Please get in touch with Cat."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html",
    "href": "sessions_core/03_data_verbs.html",
    "title": "Basic Data Manipulation",
    "section": "",
    "text": "Learn basic data verbs from {dplyr} to:\n\nSelect specific columns (select())\nRename columns (rename())\nAdd new columns and change existing ones (mutate())\nRemove duplicate observations\n\nUnderstand the pipe operator |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#objectives",
    "href": "sessions_core/03_data_verbs.html#objectives",
    "title": "Basic Data Manipulation",
    "section": "",
    "text": "Learn basic data verbs from {dplyr} to:\n\nSelect specific columns (select())\nRename columns (rename())\nAdd new columns and change existing ones (mutate())\nRemove duplicate observations\n\nUnderstand the pipe operator |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#setup",
    "href": "sessions_core/03_data_verbs.html#setup",
    "title": "Basic Data Manipulation",
    "section": "Setup",
    "text": "Setup\nDependencies. This session assumes that you know how to use RStudio and that you are able to import data. If you need a refresher on either of these topics, we encourage you to review the first two sessions in the learning pathway.\n\nThis session will work with the raw Moissala linelist data, which can be downloaded here:\n\n\n\n  Download Data\n\n\n\n Make sure this dataset is saved into the appropriate subdirectory of your R project and create a new script called data_verbs_practice.R in your R directory. Add an appropriate header and load the following packages: {here}, {rio}, and {tidyverse}.  Finally, add an import section where you use {here} and {rio} to load your data into an object called df_raw."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#manipulating-data-with-dplyr",
    "href": "sessions_core/03_data_verbs.html#manipulating-data-with-dplyr",
    "title": "Basic Data Manipulation",
    "section": "Manipulating Data with {dplyr}",
    "text": "Manipulating Data with {dplyr}\nNow that we know how to set up a project and import data, we can finally start to play around with it. Going forward we will be using several packages from the ‚Äútidyverse‚Äù to help us manipulate, summarize, and visualize our data. Today‚Äôs session will focus on data manipulation using a package called {dplyr}.\n\nWhat is {dplyr}\nData manipulation is the foundation of working with data in R and as such is foundational to the work we do as epidemiologists. In particular, data manipulation skills will be critical when trying clean our data.\nIn R, the package {dplyr} provides a large number of functions to help us manipulate data frames and perform many of the tasks that we will need to use on a daily basis, for example:\n\nSubsetting our data to remove certain variables\nRenaming certain variables\nAdding or modifying a variable\nRemoving duplicate entries\n\nIn {dplyr} each of these actions can be done with a particular function, which typically have an intuitive verb for a name. For example, renaming columns will use the function rename().\nIn today‚Äôs session we will look at the ‚Äúdata manipulation verb‚Äù, ie the function, needed for each of the above tasks as well as how to chain them all together into an efficient data pipeline.\n\n\n\n\n\n\nNote\n\n\n\nYou may have noticed that we asked you to load a package called {tidyverse} rather than {dplyr} in the setup. Loading {tidyverse} will load several of the most useful packages from the broader tidyverse, including {dplyr} and a couple other packages that we will see later in the session."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#basic-data-verbs",
    "href": "sessions_core/03_data_verbs.html#basic-data-verbs",
    "title": "Basic Data Manipulation",
    "section": "Basic Data Verbs",
    "text": "Basic Data Verbs\n\nSelecting Specific Columns\nA lot of the time when we receive a dataset it will have extra columns that we don‚Äôt need, either because those columns contain sensitive data or because our analysis will only focus on a subset of the data. This is where a function like select() comes in handy.\nHere is the basic syntax, note that this is pseudo-code and isn‚Äôt something you are intended to run yourself.\n\n# DO NOT RUN (PSEUDO-CODE)\nselect(df_raw, first_column_to_keep, second_column_to_keep)\n\nHere we see that the first argument is our dataset and each subsequent argument is the name of a column that we would like to keep. In the tidyverse, variables (ie column names) don‚Äôt need to be put into quotation marks. So for example, if we want to select the columns id, sex, and age we can use the following:\n\nselect(df_raw, id, sex, age)\n\n\nUse select() to select the following variables in your dataset: id, sex, age, sub_prefecture, date_onset, and outcome. The head of your output should look something like this:\n\n\n  id   sex age date_onset   outcome\n1  1 femme  36 2022-08-13 recovered\n2  2     f   5 2022-08-18      &lt;NA&gt;\n3  3     f 156 2022-08-17 recovered\n4  6 homme   8 2022-08-22 recovered\n5  7     m   7 2022-08-30 recovered\n6 10     m   4 2022-08-30 recovered\n\n\n Take a look at this output and then at df_raw. We can see that df_raw still contains all of the columns, which is what we want. But can you tell why it didn‚Äôt change?\n\nOften, we want to keep most of the variables in our dataset and only remove one or two. We can use the above syntax to do this, but it can become pretty tedious to write out every column name. In these cases, instead of telling select what to **keep**, we can use a subtraction sign (-) to tell it what to **remove**. For example, if we wanted to remove thevillage_commune` column from our dataframe we can use the following:\n\nselect(df_raw, -village_commune)\n\nWay easier!\n\nUse the - syntax in select() to select all of the columns in df_raw except: full_name and age_unit from your dataset.\n\n\n\nRenaming Columns\nAnother common issue when we get new datasets is that the variable names are inconvenient. In those cases, rename() can work wonders. Here‚Äôs the basic syntax:\n\n# DO NOT RUN (PSEUDO CODE)\nrename(df,\n       new_column_name = old_column_name,\n       another_new_name = another_old_name)\n\nAs in the case of select(), and indeed in essentially all {dplyr} verbs, the first argument is our daframe. Then each subsequent argument is a statement of new_column_name = old_column_name telling R which columns to rename and the new names that we want to use, with each pair given its own line to improve readability. If we wanted to change village_commune to simply be village, for example, we can write:\n\nrename(df_raw,\n       village = village_commune)\n\n\nUse rename() on df_raw to change the columns sub_prefecture, village_commune, and health_facility_name to be prefecture, village, and facility respectively.\n\nIn the above exercise it may have been difficult to check if the output looked correct because R would have printed out the full data frame. In these cases it can be helpful to create a temporary object just to check if everything looks alright. You can call this object whatever you want, but a common name is tmp.\n\nRepeat the last exercise but this time assign the output to an object called tmp and use names() to check that the column names changed as you expected. The output of names() should give you something like this:\n\n\n [1] \"id\"                \"full_name\"         \"sex\"              \n [4] \"age\"               \"age_unit\"          \"region\"           \n [7] \"prefecture\"        \"village\"           \"date_onset\"       \n[10] \"date_consultation\" \"hospitalisation\"   \"date_admission\"   \n[13] \"facility\"          \"malaria_rdt\"       \"fever\"            \n[16] \"rash\"              \"cough\"             \"red_eye\"          \n[19] \"pneumonia\"         \"encephalitis\"      \"muac\"             \n[22] \"vacc_status\"       \"vacc_doses\"        \"outcome\"          \n[25] \"date_outcome\"     \n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nTemporary objects, like the tmp data frame you just created are just that: temporary. They are usually used to test if something has worked and designed to be overwritten each time you need to test something else. As such, you should not use these temporary objects as the input for other parts of your code. If you want to make a data frame that will be reused, such as a clean version of df_raw, this should be done using an object with a proper name like df or df_clean.\n\n\n\n\nChanging and Adding Columns\nSo now we know how to select and rename columns, but how do we modify them? This is where mutate() comes into play. This function can be used both to add new columns and to change existing ones.\nLet‚Äôs start with the basic mutate() syntax needed to add a new column:\n\n# DO NOT RUN (PSEUDO-CODE)\nmutate(df,\n       new_column = action(existing_column),\n       another_new_column = another_action(another_existing_column))\n\nIn the above code, we are creating a new column (new_column) by performing some sort of action (action()) on an existing column in the dataframe (existing_column). This action could be anything, it could use a function or be a simple arithmetic operation and can use one or more columns. For example, if we wanted to create a new column expressing MUAC in cm we could use the following:\n\nmutate(df_raw,\n       muac_cm = muac / 100)\n\n\nUse mutate() to create a new column called age_years that expresses age in years rather than months. The head of your new age_years column should look like this:\n\n\n   age_years\n1  3.0000000\n2  0.4166667\n3 13.0000000\n4  0.6666667\n5  0.5833333\n6  0.3333333\n\n\n\nGreat! But what if instead of creating a new column we instead wanted to change an existing one? You just need to use the existing column name on the left side of the = instead of giving a new column name. For example, in the above MUAC code we would write:\n\nmutate(df_raw,\n       muac = muac / 100)\n\nWe might want to keep age in months as well as years, so we won‚Äôt reassign that column. But there are some other columns that could stand to be changed. There are a lot of reasons we might want to change a column, two of the most common ones are:\n\nThe format of a string needs changing\nThe data type of a column is incorrect\n\nOur dataset has both of these problems. For example, while it isn‚Äôt per se a problem that region and sub_prefecture are in all capitals, it also isn‚Äôt particularly nice. To fix this, we can use another function from the {tidyverse}, this time from a package called {stringr} to make these columns title case:\n\nmutate(df_raw,\n       region = str_to_title(region),\n       sub_prefecture = str_to_title(sub_prefecture))\n\n\nUse mutate() to update the format of malaria_rdt and outcome to use title case. The head of these two columns should now look something like this:\n\n\n  malaria_rdt   outcome\n1    Negative Recovered\n2    Negative      &lt;NA&gt;\n3    Negative Recovered\n4    Negative Recovered\n5    Negative Recovered\n6    Negative Recovered\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that we didn‚Äôt need to load {stringr} to do the above exercise. That‚Äôs because, like {dplyr} this package is loaded when we load the {tidyverse}.\n\n\nThat‚Äôs nicer. Now let‚Äôs consider the second issue, having variables with the wrong type.\n\nTake a look at the data type of your columns, do any of them look strange?  Hint. str() may be useful here.\n\nMost of the columns look ok, but it seems theres something strange with the dates. Some of them are character type and others are something called POSIXct. We would much rather have all of these columns use the simple Date type.\nTo convert to dates, we are going to call on yet another package from the the tidyverse, {lubridate}. In particular, we are going to use the function ymd(). For example:\n\nmutate(df_raw,\n       date_outcome = ymd(date_outcome))\n\n\nUse mutate() and ymd() to modify date_onset and date_admission to be Date type. Use a temporary data frame tmp to check that your code is doing what you want it to.\n\n\n\nRemoving Duplicates\nOk great! We know how to select, rename, and modify our data. Another task we will often need to do is removing duplicate entries. Fortunately this one is easily done using the function distinct(), which has the following basic syntax:\n\n# DO NOT RUN (PSEUDO-CODE)\ndistinct(df)\n\nNotice that distinct only needs one argument by default, the dataset itself. This will look for and remove any duplicate observations in the data frame. There are some fancier ways of using distinct() that will look for duplication on certain variables only, but that‚Äôs outside of the scope of today‚Äôs session.\n\nUse distinct() to create a temporary data frame, tmp, that contains all the unique observations in df_raw. Compare the number of rows in tmp to that of df_raw. Did we have any duplicates?"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#the-pipe-operator",
    "href": "sessions_core/03_data_verbs.html#the-pipe-operator",
    "title": "Basic Data Manipulation",
    "section": "The Pipe Operator",
    "text": "The Pipe Operator\nSo it looks like we have actually done quite a bit of cleaning while learning the core {dplyr} verbs. We should probably try to put some of the above steps together to start building a basic data cleaning pipeline. So far we haven‚Äôt been saving any of our changes, except perhaps to a temporary data frame. It would be nice to keep them in a new clean df object.\nFor example, if we want to effect the column renaming we did above to a reusable object we might write something like this:\n\ndf &lt;- rename(df_raw, \n             prefecture = sub_prefecture,\n             village = village_commune,\n             facility = health_facility_name)\n\n\n\n\n\n\n\nTip\n\n\n\nIn general, it‚Äôs good practice to keep a raw version of your dataset, here df_raw, that remains unmodified in your code. This is so that you always have it available in your environment as a reference and is always available at the start of your cleaning pipeline to improve reproducibility.\n\n\nNow we have a new object, df that we can do more operations on. Brilliant. For example, if we now wanted to select everything except for full_name we could update the above code like this:\n\n# Step 1: Rename Variables\ndf &lt;- rename(df_raw, \n             prefecture = sub_prefecture,\n             village = village_commune,\n             facility = health_facility_name)\n\n# Step 2: Select Variables to Keep\ndf &lt;- select(df,\n             -full_name)\n\nNotice that in this second step we are using df as the input of select() rather than df_raw because we want to continue working on our modified version of the data. Let‚Äôs say now we want to add a column of age in years:\n\n# Step 1: Rename Variables\ndf &lt;- rename(df_raw, \n             prefecture = sub_prefecture,\n             village = village_commune,\n             facility = health_facility_name)\n\n# Step 2: Select Variables to Keep\ndf &lt;- select(df,\n             -full_name)\n\n# Step 3: Add Age in Years\ndf &lt;- mutate(df,\n             age_years = age / 12)\n\nHm, ok well this is working but it is starting to get repetitive. With each step we are reusing the output of the last step and then updating the same data frame, df. It would be better if these actions could be chained together in a simpler way.\nThis is exactly what the pipe operator, |&gt; is for! The pipe has the following basic syntax:\n\n# DO NOT RUN (PSEUDO-CODE)\ninput |&gt; action()\n\nHere the input on the left side (input) is ‚Äúpiped into‚Äù the action on the right side (action()). So for example instead of writing:\n\nselect(df_raw, id, sex)\n\nWe could instead write:\n\ndf_raw |&gt;\n  select(id, sex)\n\n\nTry out the above code to see if it works.\n\nThis can be used to chain multiple actions together and you will often see tidyverse style code that uses pipes in the following way:\n\n# DO NOT RUN (PSEUDO-CODE)\ndf &lt;- df_raw |&gt;\n  first_action() |&gt;\n  second_action() |&gt;\n  third_action()\n\n\n\n\n\n\n\nTip\n\n\n\nNotice that here each action in the pipe is given its own line. This is considered good practice as it makes your code easier to read and understand.\n\n\nSo, if we wanted to chain the example actions we saw above into a single pipe, we might write something like this:\n\ndf &lt;- df_raw |&gt;\n  rename(prefecture = sub_prefecture,\n         village = village_commune,\n         facility = health_facility_name) |&gt;\n  select(-full_name) |&gt;\n  mutate(age_years = age / 12)\n\nThat‚Äôs a lot easier than reassigning df after each step!\n\nLet‚Äôs see if we can put together what we learned above into a single pipeline! Use the pipe operator |&gt;, select(), rename(), mutate(), str_to_title(), ymd(), and distinct() to perform the following actions on df_raw and assign the output to a new data frame called df:\n\nRemove the variables full_name and age_unit\nRename the following variables:\n\nage becomes age_months\nsub_prefecture becomes prefecture\nvillage_commune becomes village\nhealth_facility_name becomes facility\n\nAdd a variable age_years with patient age in years\nUpdate region and prefecture to use title case\nUpdate all date columns to use Date type\nRemove any duplicate observations\n\nThe head of your final data should look something like this:\n\n\n  id   sex age_months  region prefecture        village date_onset\n1  1 femme         36 Mandoul   Moissala Sangana Ko√Øtan 2022-08-13\n2  2     f          5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3     f        156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 homme          8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7     m          7 Mandoul   Moissala      T√©tindaya 2022-08-30\n6 10     m          4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             yes     2022-08-14\n2        2022-08-25             yes     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25              no           &lt;NA&gt;\n5        2022-09-02              no           &lt;NA&gt;\n6        2022-09-02             yes     2022-09-02\n                         facility malaria_rdt fever rash cough red_eye\n1 H√¥pital du District de Moissala    negative    No &lt;NA&gt;   Yes      No\n2 H√¥pital du District de Moissala    negative    No   No   Yes      No\n3                      CS Silambi    negative   Yes &lt;NA&gt;    No      No\n4 H√¥pital du District de Moissala    negative    No   No    No    &lt;NA&gt;\n5                      CS Silambi    negative  &lt;NA&gt;   No   Yes     Yes\n6                    Moissala Est    negative   Yes   No    No    &lt;NA&gt;\n  pneumonia encephalitis muac vacc_status vacc_doses   outcome date_outcome\n1        No           No  244        &lt;NA&gt;       &lt;NA&gt; recovered   2022-08-18\n2      &lt;NA&gt;           No  232          No       &lt;NA&gt;      &lt;NA&gt;   2022-08-28\n3        No         &lt;NA&gt;  123  Yes - oral       &lt;NA&gt; recovered         &lt;NA&gt;\n4        No           No  210          No       &lt;NA&gt; recovered         &lt;NA&gt;\n5        No           No   80          No       &lt;NA&gt; recovered         &lt;NA&gt;\n6        No           No  220          No       &lt;NA&gt; recovered   2022-09-03\n   age_years\n1  3.0000000\n2  0.4166667\n3 13.0000000\n4  0.6666667\n5  0.5833333\n6  0.3333333\n\n\nHint. Be careful with your column names here! If you renamed something you will need to use the new names for any subsequent parts of the pipe.\n\nAmazing! That looks like a great start at a data cleaning pipeline. Keep this code handy, you will use it in the next session where we will look at another common part of data cleaning: recoding."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#done",
    "href": "sessions_core/03_data_verbs.html#done",
    "title": "Basic Data Manipulation",
    "section": "Done!",
    "text": "Done!\nWell done, you‚Äôve learned the fundamentals of data manipulation and how to string multiple commands together into a data manipulation pipe. Moving forward, solution files will focus less on being ‚Äúexercise by exercise‚Äù and rather provide an example of what a real script might look like in a real world context. In this case, the solutions will then focus only on the final pipe that is created at the end of the session.\n\n\n\n Solution File"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#going-further",
    "href": "sessions_core/03_data_verbs.html#going-further",
    "title": "Basic Data Manipulation",
    "section": "Going Further",
    "text": "Going Further\n\nExtra Exercises\n\nA a line to your mutate() to update the hospitalisation variable so that its text would be in title case as well.\nPerhaps you would prefer to use lower case for the region column rather than the title case, update your code to do this instead. Hint: you might want to check out str_to_lower() from {stringr}.\nCreate a delay_consultation column, that contains the number of days between the onset of symptoms and the consultation."
  },
  {
    "objectID": "sessions_core/template.html",
    "href": "sessions_core/template.html",
    "title": "Session Title",
    "section": "",
    "text": "Objective 1\nObjective 2"
  },
  {
    "objectID": "sessions_core/template.html#objectives",
    "href": "sessions_core/template.html#objectives",
    "title": "Session Title",
    "section": "",
    "text": "Objective 1\nObjective 2"
  },
  {
    "objectID": "sessions_core/template.html#setup",
    "href": "sessions_core/template.html#setup",
    "title": "Session Title",
    "section": "Setup",
    "text": "Setup\n\nDescription of something participants need to setup, primarily used at the beginning of a section but can also be used for tasks like setting up an Rproject file, folder structure, etc."
  },
  {
    "objectID": "sessions_core/template.html#main-section-1",
    "href": "sessions_core/template.html#main-section-1",
    "title": "Session Title",
    "section": "Main Section 1",
    "text": "Main Section 1\nYour main section(s) can (and probably should) be boken down into subsections.\n\nSubsection 1\n\n\nSubsection 2"
  },
  {
    "objectID": "sessions_core/template.html#done",
    "href": "sessions_core/template.html#done",
    "title": "Session Title",
    "section": "Done!",
    "text": "Done!\nThis last header let‚Äôs students know that they are done with the main material for the day. It should also include a link to the solutions (hosted on github). For example:\n\n\n\n Solution File\n\n\n\nMake sure this link references the main."
  },
  {
    "objectID": "sessions_core/template.html#going-further",
    "href": "sessions_core/template.html#going-further",
    "title": "Session Title",
    "section": "Going Further",
    "text": "Going Further\nAfter your main content is done you should have a section called called ‚ÄúGoing Further‚Äù for students who finish the main content early. It should include: 1. A mention of one or two satellite sessions that would be relevant extensions of the current material 2. A section with ‚Äúextra exercise questions‚Äù (these don‚Äôt need to use the ‚Äúaction blocks‚Äù (see below) and can just be a number list as shown below.\n\nExtra Exercises\n\nDo this.\nThen do that."
  },
  {
    "objectID": "sessions_core/template.html#markdown-reminders",
    "href": "sessions_core/template.html#markdown-reminders",
    "title": "Session Title",
    "section": "Markdown Reminders",
    "text": "Markdown Reminders\nThe rest of this document is a reminder on qmd syntax and a basic style guide. Enjoy.\n\nText Formatting\n\nItalic and Bold will turn out like this\nBlock quotes will look like this:\n\n\nThis is a blockquote made using &gt;\n\n\nTooltips can be done using spans (please do not use asides or footnotes)\n\n\n\nCode\nInline coding will turn out like this\nCode blocks will appear like this:\n\n# comment\nprint('hello world')\n\nWarning: For these tutorials, code blocks are not evaluated by default. If you want to evaluate them, you must indicate it specifically.\n\n# comment\nprint('hello back!')\n\n[1] \"hello back!\"\n\ntest &lt;- function(x) {\n  if (x &gt; 1) {\n    return(x)\n  } else {\n    print('nothing to see here')\n  }\n}\n\nNote. We are no longer using solution blocks, instead a single code file will be available at the end of each session contiaining code that runs through all the exercises.\n\n\nCallouts\nIMPORTANT: please do not use callouts not explicitly defined here; they have not been included in the css and therefore will not render well in the final document.\n\n\n\n\n\n\nNote\n\n\n\nThis is a callout using {.callout-note}\n\n\n\n\n\n\n\n\nTip\n\n\n\nComment about a genral tip / trick or best practice.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nWarning / comment on something really important.\n\n\n\n\nAction Boxes\nThese are used for things participants are expected to actually do, ie: exercises. They are split into three categories.\n\nDescription of something participants need to setup, primarily used at the beginning of a section but can also be used for tasks like setting up an Rproject file, folder structure, etc.\n\n\nDescription of something participants should observe, investigate, etc.\n\n\nDescription of a coding exercise that participants are expected to complete.\n\n\n\nTabsets\n\nOneTwoThree\n\n\nContent that will show under the first tab\n\n\nContent that will show under the second tab\n\n\nContent that will show under the third tab\n\n\n\n\n\nImages\nYou can insert images by referring to their relative path using markdown syntax or HTML. Note that the markdown syntax does not allow you to modify image size. In either case, make sure to add alt text for accessibility.\nMarkdown style syntax:\n\n\n\nexample image alt text\n\n\nHTML style syntax (with specification of desired size):\n\n\n\nLinking to Other Pages\nEasy, use relative paths within a standard href, ie: link to home page."
  },
  {
    "objectID": "sessions_core/02_import_data.html",
    "href": "sessions_core/02_import_data.html",
    "title": "Import data",
    "section": "",
    "text": "Create a RStudio Project\nSet up an organized and well documented code\nInstall and load packages\nWrite robust file paths\n\nImport and inspect data\n\n\n\n\n\n\n\nImportant\n\n\n\nThe principles you learned in the Introduction to R session will apply here as well: we should do our best to ensure that our projects won‚Äôt just work today but can also be reused and shared in the future. While doing this is not always easy, there are several best practices that can help us, and one of the most important is to start with a good, organized code base."
  },
  {
    "objectID": "sessions_core/02_import_data.html#objectives",
    "href": "sessions_core/02_import_data.html#objectives",
    "title": "Import data",
    "section": "",
    "text": "Create a RStudio Project\nSet up an organized and well documented code\nInstall and load packages\nWrite robust file paths\n\nImport and inspect data\n\n\n\n\n\n\n\nImportant\n\n\n\nThe principles you learned in the Introduction to R session will apply here as well: we should do our best to ensure that our projects won‚Äôt just work today but can also be reused and shared in the future. While doing this is not always easy, there are several best practices that can help us, and one of the most important is to start with a good, organized code base."
  },
  {
    "objectID": "sessions_core/02_import_data.html#setting-up-your-project",
    "href": "sessions_core/02_import_data.html#setting-up-your-project",
    "title": "Import data",
    "section": "Setting up your Project",
    "text": "Setting up your Project\n\nFolder Structure\n\nIf not done already, download and unzip the course folder. Save the uncompressed folder to a location that is not connected to OneDrive and navigate into it.\n\n\n\n  Course Folder\n\n\n\n\nThis folder gives an example of a typical (and highly recommended) structure for your code projects:\n\nüìÅ data\n\nüìÅ clean\nüìÅ raw\n\nüìÅ R\nüìÅ outputs\n\nThis folder will be you working directory for all the sessions of this course. You will create an Rstudio project in it (explanations below), and save all your scripts in /R. The course datasets are already in data/raw.\n\n\nDefinitions\nTo work through this session you need to understand the two following concepts:\nWorking directory. The working directory is the location (folder) where your R session is actively working. If you save a file, for example, it will be saved into this folder by default. Similarly, when you want to open a file, this folder will be shown by default. All relative paths will be relative to this working directory. By default, R usually picks the ‚ÄúDocuments‚Äù folder as the working directory on Windows machines.\nRoot. The root refers to the top-most folder level of the working directory. If your course folder was called FETCHR, the root would then be directly inside it (as opposed to being inside one of its subfolders like R or Data).\n\n\nRStudio Projects\nAn RStudio Project can be used to make your life easier and help orient RStudio around the various files used in your code\nAs a quick reminder, your interface should look something like this:\n\n\n\n\n\n\nFigure¬†1: Screenshot of a typical Rstudio interface\n\n\n\n\nOpen RStudio and create a new project by clicking File &gt; New Project &gt; Existing Directory &gt; Browse, navigating into (opening) the course folder, and clicking Create Project.\n\n\nIn the Windows Explorer, look at the course folder. You should now see a new file with the extention .Rproj that has a small blue icon with an R in it.\n\n\n\n\nIcon associated with RStudio projects\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you don‚Äôt see this file, it‚Äôs probably because it is hidden by default on your computer. To change this setting in Windows Explorer, go into the View menu and select Filename Extensions.\n\n\nWhen you open an RStudio Project, RStudio starts a new R session, opens the associated project files, and sets your working directory to the root of the course folder. At this time, RStudio also displays the subfolders of this directory in the panel on the bottom right.\n\n\n\n\n\n\nTip\n\n\n\nIt is strongly recommended to set up a separate RStudio Project for each of your analyses to ensure that your project files remain organized and manageable.\n\n\nThere are several ways to open an RStudio Project:\n\nUse the RStudio menu File &gt; Open Project and then select the relevant .Rproj file\nClick on the Project: (none) button on the top right of the RStudio interface\nNavigate in the folder explorer to the analysis folder and double click on the file with the .Rproj extension\n\n\n\nRStudio Options\nBefore continuing, let‚Äôs update some of RStudio‚Äôs problematic default settings:\n\nOpen the global options (Tools &gt; Global Options) and open the tab General (left menu). Make sure that none of the boxes in the sections R Sessions, Workspace, or History are checked.\n\n\n\n\nScreenshot of the Rstudio options\n\n\nWhen checked, these options cause RStudio to save the objects in your environment and reload them as well as any files you previously had open when you open a new R session. While these default may seem like a good idea, it is better to always start your work from a fresh, empty R session to avoid bugs.\n\n\n\n\n\n\nImportant\n\n\n\nRemember that any commands or outputs that is needed for the cleaning and analysis should be saved explicitly in a script in the correct, functional order."
  },
  {
    "objectID": "sessions_core/02_import_data.html#creating-a-new-script",
    "href": "sessions_core/02_import_data.html#creating-a-new-script",
    "title": "Import data",
    "section": "Creating a New Script",
    "text": "Creating a New Script\n\nOpen a new script and save it in the R folder of your project under the name import_data.R.\nAdd some metadata to the top of the script as seen in the first session using comments. Be sure to include:\n\nTitle\nAuthor\nCreation Date\nDescription\n\n\nNow you‚Äôre ready to start coding!"
  },
  {
    "objectID": "sessions_core/02_import_data.html#sec-packages",
    "href": "sessions_core/02_import_data.html#sec-packages",
    "title": "Import data",
    "section": "Packages",
    "text": "Packages\nPackages are collections of functions that extend the functionality of R. You‚Äôll use them a lot, both in this course and in your daily life. Fortunately, as an open source language, R packages can be downloaded and installed for free from the internet.\n\n\n\n\n\n\nNote\n\n\n\nIn R, packages are referenced using {}. For example {ggplot2} is the name of the ggplot2 package that contains new plotting functions such as ggplot(), geom_point() etc‚Ä¶\n\n\n\nInstallation\nWe can install a new package using the function install.packages(), which downloads and installs it into the package library on your computer. This is done once per computer.\n\ninstall.packages(\"here\") # install the {here} package\n\nDon‚Äôt forget to wrap the package name in quotation marks when using install.packages(). What happens if you don‚Äôt do this?\n\n\n\n\n\n\nNote\n\n\n\nIf you are following this session as part of a course, to avoid any potential internet connectivity issues during the training we already had you install most of the course packages.\nIf are following this tutorial on your own or have not installed the packages yet, you will have to manually install each new package that we encounter.\n\n\n\n\nUsage\nOnce a package is installed we can use it but we have to specify to R that we will be using it every single session. This process is called loading the package and is achieved using the function library().\n\nlibrary(here) # load the \"here\" package\n\n\nUse the library() function to load the packages here and rio, which will be used in the next section.\n\nBased on your computer‚Äôs set up and the package you are trying to load, you may get a warning message noting that some functions have been masked or that the current version of the package was built for a different version of R. These messages are not usually a problem but are still important to note.\n\nTry to run the following code. Can you work out what the error means?\n\nlibrary(ggplot)\n\n\nThe above code throws an error because you have asked for a library that doesn‚Äôt exist. Remember that R is fickle and case sensitive and many of your errors will come from small typos in the names of functions or objects. Here, for example, we wanted to load the package ggplot2 but wrote ggplot instead.\n\n\n\n\n\n\nTip\n\n\n\nMost of the time, you‚Äôll need to load a number of packages for your script and it is recommended to have a section at the start of your code that loads everything you‚Äôll need in one place:\n\n# Packages ----------------------------\nlibrary(tidyverse)   # data manipulation\nlibrary(lubridate)   # date manipulation\n\nThis practice makes it easy to tell which packages need to be installed to run a script.\n\n\n\nUse comments to create a ‚ÄúPackages‚Äù section to your script.\n\n\n\nUpdating Packages\nR has a very active community of developers and it‚Äôs pretty common for packages to be updated from time to time as their owners add in new functions and fix existing bugs. In order to update the packages in your library, you can go into the Packages tab of the bottom right panel and click Update. Don‚Äôt forget that you‚Äôll need to be connected to the internet during this process.\n\n\n\n\n\n\nImportant\n\n\n\nSometimes packages are updated in a way that might remove or change a function that you used in some of your scripts, causing your code to no longer work. Don‚Äôt panic if this happens. The best practice is to adapt your code, although in the worst case scenario you can forcibly install an old version of a package. This is however out of the scope of this session."
  },
  {
    "objectID": "sessions_core/02_import_data.html#data-importation",
    "href": "sessions_core/02_import_data.html#data-importation",
    "title": "Import data",
    "section": "Data Importation",
    "text": "Data Importation\n\nUnderstanding File Paths\nTo open a file in R you need to provide a file path. A file path is simply a longer name for a file, that includes not only its name but also its location on your computer. There are several ways of defining these paths, including absolute and relative paths.\n\nAbsolute Paths\nAbsolute paths are specific to your computer and go all the way up to the level of your hard drive. For example, an absolute path may look something like this: D:/OneDrive - MSF/Documents/monitoring/cholera/fancy_project/data/raw/example_linelist.xlsx. Clearly, this path will only work on one specific computer.\nThe use of hard coded absolute paths is strongly discouraged as it makes your code inflexible and prone to break: the paths need to be updated every time your code is shared or the project folder is moved on your computer.\n\n\nRelative Paths\nRelative paths are defined relatively to your current working directory. For example, keeping in mind that our handy .Rproj file set our working directory to the root of our project folder, we could create a relative path that looked like data/raw/example_linelist.xlsx. This means that as long as we maintain the internal structure of our project folder and have an .Rproj file, our code would theoretically run on multiple computers.\n\n\nRobust Paths with the here() function\nThe {here} package has a here() function that really helps defining paths. It has two advantages:\n\nWhen used with RStudio projects, you can give it only the part of the path within the project, (the relative path in other words), and the function uses it to create the absolute path dynamically.\nIt does so using the separator adapted to you operating system, whether it‚Äôs /, \\, or //\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"/home/catherine/Documents/epicentre/training/repicentre/data/raw/example_linelist.xlsx\"\n\n\nSee how we only defined the relative path and the function created an absolute path. This way of defining the path will work on your colleagues computer, even if they run on another operating system, as long as you both respect the internal structure of the working directory.\nWe strongly encourage you to use here() whenever you need to create a file path.\n\nRun the above code in the console. What file path does here(\"data\", \"raw\") give you?\n\n\nUsing here(), create a complete file path for the file Moissalla-measles-linelist-EN.xlsx. Keep this path around, we will use it soon.\n\n\n\n\n\n\n\nImportant\n\n\n\nhere() simply creates a file path, it doesn‚Äôt actually check if a file exists on your computer: if the file is absent or there is a typo in your code, the command will yield an error when the path is used. If you would like to use a function to check if a file exists, check out the file.exists() function.\n\n\n\n\n\n\n\n\nTip\n\n\n\nWe will often want to source multiple data files in a single project. To make that process easier, it can be helpful to create a section at the start of the script, after loading the packages to define paths and store them in variables.\n\n\n\n\n\nImport function\nIn R different file formats are often imported using different, often specialized functions. This can be tedious as it requires you to memorize and load a large number of functions just to get your data imported. To avoid this problem, we recommend that you use the import() function from the package {rio}. This function is able to open a large variety of files (including Excel, csv, Stata, and many others) by recognizing the file extension of your data and calling a relevant specialized function from another package so that you don‚Äôt have to.\nBecause import() is actually just calling other functions in the background, it is possible that it will need different arguments depending on the type of file you want to load.\n\n\n\n\n\n\nTip\n\n\n\nTo see the full list of all the file types you can load (and save!) with rio, check out the list of supported formats on their website. In the rest of the lesson we will focus on importing data from Excel .xlsx files.\n\n\n\nImporting from the First Sheet\nIn general, the usage of import() is pretty simple, at minima you need to pass the path of the file to the file argument\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"))\n\nNotice that we have nested the command here() inside the import() command. Nesting functions is absolutely allowed in R and is something you will do all the time. When functions are nested, R will evaluate them in the order of the innermost function (in this case here()) to the outermost (in this case import()). In this way, the output of here() is being used as the input of import().\n\nImport the file Moissalla-measles-linelist-EN.xlsx that is in your raw data subfolder into R using here() and import().\n\nIf your import worked correctly, R will print the data into the console but not save it into the environment because we have not assigned them to an object.\n\n\n\n\n\n\nTip\n\n\n\nYou may not want to have R print very large datasets into the console and assign them directly to an object.\n\n\n\nReimport your data but this time save it to an object called df_linelist.\n\n\n\nImporting Data from Any Sheet\nAs you just saw, R selects the first sheet by default. It is however possible to pass the number (or name) of a specific worksheet in your Excel data to import() using the argument which:\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"),\n       which = 2)  # imports the second sheet\n\nNote that the which argument is specific to the file types that have multiple sheets, such as Excel or .Rdata files. If you try to use it on a .csv file the argument will be ignored."
  },
  {
    "objectID": "sessions_core/02_import_data.html#taking-a-first-look-at-your-data",
    "href": "sessions_core/02_import_data.html#taking-a-first-look-at-your-data",
    "title": "Import data",
    "section": "Taking a First Look at your Data",
    "text": "Taking a First Look at your Data\nWe have now imported a dataset into R and assigned it to a dataframe (df_linelist). The natural next step is to inspect this dataset, to check that the import went well, get to know it a bit better, and assess if it requires any cleaning before analysis.\nWe can start by taking a quick look at the first few lines of the dataframe using the function head(). This function takes a dataframe as its first argument and optionally accepts a second argument n indicating the number of lines we would like to see.\n\nhead(df_linelist, n = 10) # Inspect 10 first lines\n\n\nUse head() to examine the 12 first lines of df_linelist.\n\nWe can also check out our data by looking at the Environment tab of the top-right panel. Here, we can see our dataframe in the environment, look at its structure, or open it in the data viewer of RStudio.\n\nClick on the round blue button next to df_linelist in your environment to see its structure. Then click on the name of the dataset to open it in the viewer.\n\nThe data viewer displays dataframes as tables and is a convenient way to quickly look at your data. You can even sort and filter your data in the ‚ÄúView‚Äù, though be aware that these actions will not make any changes to the actual object df_linelist. The View can also be opened by passing the dataframe to the function View()."
  },
  {
    "objectID": "sessions_core/02_import_data.html#done",
    "href": "sessions_core/02_import_data.html#done",
    "title": "Import data",
    "section": "Done!",
    "text": "Done!\nWell done and don‚Äôt forget to save your code.\n\n\n\n Solution File"
  },
  {
    "objectID": "sessions_core/02_import_data.html#going-further",
    "href": "sessions_core/02_import_data.html#going-further",
    "title": "Import data",
    "section": "Going Further",
    "text": "Going Further\n\nExtra Exercises\n\nUse dim() to take a look at the dimensions of your dataset.\nUse str() to check the data type of each column. Does anything look odd? Remember that you can also use functions like is.character() and is.numeric() if you‚Äôd like to test the type of a particular column.\nUsing a function learned in the first session, can you extract the names of the columns of the dataset? Do these results match what you see when you open the data in Excel?\nTry passing your dataframe to the function summary(). What does this function tell you?\n\n\n\nAdditional Resources\n\nThe {rio} website\nMore examples on importing data of various file types"
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html",
    "href": "sessions_core/01_introduction.fr.html",
    "title": "Introduction √† R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCr√©er et ex√©cuter un script\nCr√©er des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#objectifs",
    "href": "sessions_core/01_introduction.fr.html#objectifs",
    "title": "Introduction √† R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCr√©er et ex√©cuter un script\nCr√©er des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#format-des-exercices",
    "href": "sessions_core/01_introduction.fr.html#format-des-exercices",
    "title": "Introduction √† R",
    "section": "Format des exercices",
    "text": "Format des exercices\nCes exercices sont dans un format tutoriel contenant de br√®ves explications sur les concepts cl√©s, des exemples et des instructions √† suivre. Notre approche est tr√®s orient√©e sur la pratique, et √† l‚Äôexception de cette premi√®re session partiellement ax√©e sur l‚Äôinterface, vous aurez beaucoup d‚Äôoccasions de coder.\nLes instructions pour les exercices seront donn√©es dans les formats suivants :\n\nCet encadr√© contient des instructions g√©n√©ralistes. Vous le trouverez en g√©n√©ral au d√©but d‚Äôune session, avec des instructions de mise en place.\n Exemple : Ouvrez un script vide et nommez-le mon_premier_script.R.\n\n\nCet encadr√© contient des instructions de code que vous devez √©crire dans votre script ou la console.\n Exemple : Cr√©ez un objet region qui contient la valeur \"Mandoul\".\n\n\nCet encadr√© vous demande d‚Äôobserver ou √©tudier quelque chose.\n Exemple : Inspectez l‚Äôinterface de RStudio.\n\nAu cours de ces exercices, vous rencontrerez certainement des erreurs, qui se produisent lorsque R n‚Äôest pas en mesure d‚Äôex√©cuter une commande. Cela peut se produire pour de nombreuses raisons : une faute d‚Äôorthographe dans le nom d‚Äôun objet ou d‚Äôune fonction, le mauvais type de donn√©es fournis etc. Lorsqu‚Äôune erreur se produit, R arr√™te les calculs en cours et affiche un message expliquant ce qu‚Äôil s‚Äôest pass√©. Il est tout √† fait normal d‚Äôavoir des erreurs, √ßa arrive tout le temps, √† tous les programmeurs, qu‚Äôils soient novices ou experts. Comme lorsque vous apprenez une langue (non informatique), vous vous am√©liorerez avec la pratique, en faisant des erreurs et en apprenant √† les corriger."
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#rstudio-et-r",
    "href": "sessions_core/01_introduction.fr.html#rstudio-et-r",
    "title": "Introduction √† R",
    "section": "RStudio et R",
    "text": "RStudio et R\nR est un langage de programmation fonctionnel qui peut √™tre utilis√© pour nettoyer et manipuler des donn√©es, effectuer des analyses (en particulier des analyses statistiques), visualiser des r√©sultats, et bien plus encore.\nRStudio est un logiciel qui fournit une interface facile √† utiliser pour R (√©galement appel√© IDE, pour ‚ÄúIntegrated Development Environment‚Äù). Son utilisation n‚Äôest pas obligatoire, mais tr√®s fortement recommand√©e pour les d√©butants.\n\nPremiers pas avec RStudio\n\nOuvrez RStudio en utilisant le menu de d√©marrage de votre ordinateur ou le raccourci cr√©√© par d√©faut sur le bureau ; si RStudio √©tait d√©j√† ouvert, fermez-le et ouvrez-le √† nouveau.\n\nVous devriez voir une interface qui ressemble √† ceci :\n\n\n\nVue de l‚Äôinterface de l‚ÄôIDE Rstudio √† l‚Äôouverture\n\n\n\nInspectez l‚Äôinterface de RStudio.\n\nVous verrez trois ou quatre panneaux.\n\nPanneau sup√©rieur droit\nEn haut √† droite se trouve un panneau avec plusieurs onglets. La plupart d‚Äôentre eux d√©passent le cadre de ce cours, mais nous utiliserons les deux onglets suivants :\n\nEnvironment : liste les objets enregistr√©s par l‚Äôutilisateur dans la session en cours. Comme vous venez de d√©marrer une nouvelle session, votre environnement devrait √™tre vide.\nHistory : comprend l‚Äôhistorique de toutes les commandes que vous avez ex√©cut√©es au cours de la session actuelle.\n\n\n\n\n\n\n\nNote\n\n\n\nOuvrir une nouvelle session R, c‚Äôest comme red√©marer son ordinateur : tout est vide et pr√™t pour le calcul, de la m√™me mani√®re qu‚Äôil n‚Äôy a aucun programme ouvert lorsque vous allumez votre ordinateur pour la premi√®re fois.\nNous vous encourageons √† arr√™ter et √† re-d√©marrer vos sessions R r√©guli√®rement. Parfois cela corrigera certains de vos probl√®mes !\n\n\n\n\nPanneau inf√©rieur droit\nEn bas √† droite se trouve un autre panneau comprenant les onglets suivants :\n\nFiles : un explorateur de fichiers pour le r√©pertoire de travail, qui est l‚Äôemplacement du dossier dans lequel R travaille actuellement.\nPlots : l√† o√π RStudio affichera les graphiques statiques. Cet onglet devrait √™tre vide pour le moment.\nPackages : liste de tous les paquets R install√©s sur votre ordinateur. Les paquets sont des collections de fonctions qui permettent d‚Äô√©tendre les fonctionnalit√©s de R. Nous les aborderons plus en d√©tail dans la prochaine le√ßon.\nHelp : un endroit pour lire les pages d‚Äôaide et la documentation pour les fonctions et les paquets.\nViewer : un emplacement o√π RStudio affichera des sorties html telles que des tableaux, des widgets interactifs ou m√™me des tableaux de bord.\n\n\n\nPartie gauche\n\nA gauche (ou en bas √† gauche si vous avez d√©j√† quatre panneaux), vous devriez voir l‚Äôonglet console, o√π le code R est ex√©cut√©.\nEn haut √† gauche (si vous avez quatre panneaux) se trouvent les scripts R ouverts.\n\n\n\n\nLa console\nLa console est l‚Äôendroit o√π le code R s‚Äôex√©cute.\nAu d√©but d‚Äôune nouvelle session, un texte d‚Äôinformation sur votre cofiguration appara√Æt tout en haut de la console, dont le num√©ro et nom de la version de R. En dessous de ces informations, il y a une ligne avec le symbole &gt; et un curseur clignotant.\nPour ex√©cuter une commande dans R, tapez-la √† la suite du &gt; et pressez Entr√©e. R traitera alors votre code et affichera le r√©sultat (s‚Äôil y en a un). Un nouveau &gt; s‚Äôaffichera alors sur la ligne suivante, indiquant que la console est pr√™te pour la commande suivante.\n\n\n\n\n\n\nImportant\n\n\n\nSi la derni√®re ligne est pr√©fac√©e d‚Äôun + au lieu d‚Äôun &gt;, cela signifie que la console n‚Äôest pas pr√™te. Soit elle attend qu‚Äôun calcul d‚Äôune commande pr√©c√©dente finisse, soit elle attend la fin d‚Äôune commande incompl√®te. A tout moment, vous pouvez interrompre l‚Äôex√©cution en pressant la touche Echap.\n\n\n\nEx√©cutez les commandes suivantes dans la console, une ligne √† la fois, et observez les r√©sultats.\n\n5 + 90\n\n6 * 171\n\n189 / 36.6\n\n92^3\n\n(12 + 9)^4 / 1000\n\nEx√©cutez maintenant la commande suivante. Notez que le ) fermant est manquant, ce qui rend la commande incompl√®te. Que se passe-t-il ?\n\n3 / (2 + 97\n\n\nVous avez peut-√™tre not√© dans les exemples pr√©c√©dents que notre code contient beaucoup d‚Äôespaces. C‚Äôest en effet une bonne pratique que d‚Äôinclure des espaces autour de la plupart des op√©rateurs, tels que +, -, *, /, &lt;, &gt;, = et &lt;-. Ces espaces facilitent la lecture et la compr√©hension de votre code, et dans certains cas (rares) ils permettent d‚Äô√©viter des erreurs. N√©anmoins, certains op√©rateurs ne doivent pas √™tre entour√©s d‚Äôespaces, tels que ^, . et :.\n\n1+29+4.8/3*3           # Mauvais\n1 + 29 + 4.8 / 3 * 3   # Bien\n\n1 ^ 2  # Mauvais\n1^2    # Bien\n\nNous pouvons √©galement ex√©cuter des fonctions dans la console. Nous aborderons les fonctions plus en d√©tail plus tard mais sachez que les fonctions dans R sont similaires aux fonctions dans Excel (telles que SOMME ou MOYENNE).\n\nEx√©cutez les commandes suivantes dans la console (une ligne √† la fois).\n\n# Trouvez la valeur minimale\nmin(5, 10)\nmin(1, 8, 56, 0.3)\n\n# Trouvez la valeur maximale\nmax(568, 258, 314)\n\n\n\n\nScripts\nLes scripts sont des fichiers texte qui contiennent une s√©rie de commandes pour un langage de programmation particulier. L‚Äôextension du fichier indique le langage dans lequel les commandes sont √©crites. Ici nous utiliserons l‚Äôextension .R. Les scripts nous permettent de cr√©er du code qui peut √™tre r√©utilis√©, partag√© et m√™me automatis√©.\n\n√âcrire son premier script\nPour cr√©er un nouveau script, allez dans le menu File &gt; New File &gt; R Script. Alternativement, cliquez sur la petite ic√¥ne avec un + vert sur une page blanche situ√©e en dessous du menu File. Ou encore, utilisez le raccourci clavier CTRL + MAJ + N. Ce nouveau script non sauvegard√© appara√Ætra sous la forme d‚Äôun document vierge dans le panneau sup√©rieur gauche.\n\n\n\nEtapes pour cr√©er un nouveau script dans RStudio\n\n\nPour enregistrer votre script, utilisez le menu File &gt; Save As ou le raccourci clavier CTRL + S.\n\nCr√©ez un script et enregistrez-le sous le nom decouverte.R(n‚Äôoubliez l‚Äôextension !). Pour l‚Äôinstant, vous pouvez l‚Äôenregistrer sur votre bureau ou √† tout autre endroit pratique, mais nous aborderons l‚Äôorganisation des scripts dans la prochaine session.\n\n\n\nEx√©cuter du code √† partir d‚Äôun script\nPour ex√©cuter du code √† partir d‚Äôun script, placez votre curseur sur la ligne que vous souhaitez ex√©cuter (ou s√©lectionnez plusieurs lignes) et effectuez l‚Äôune des op√©rations suivantes :\n\nCliquez sur le bouton Run en haut √† droite de la fen√™tre de script\nUtilisez le raccourci CTRL + Entr√©e (le curseur passera ensuite √† la ligne suivante)\nUtiliser le raccourci ALT + Entr√©e (le curseur restera sur la ligne actuelle)\n\n\nCopiez le code que vous aviez ex√©cut√© dans la console lors des exercices pr√©c√©dents dans votre script et ex√©cutez-le en testant les diff√©rentes m√©thodes ci-dessus.\nA partir de maintenant, vous √©crirez votre code dans votre script et l‚Äôex√©cuterez √† partir de l√†, sauf indication contraire de notre part.\n\n\n\nCommentaires\nDans R, le code qui est pr√©c√©d√© d‚Äôun # (di√®se) n‚Äôest pas ex√©cut√©, il est juste ignor√© jusqu‚Äô√† la fin de la ligne. C‚Äôest donc un bon moyen de documenter votre code.\n\n# Ceci est un commentaire\n\n2 + 3  # Ceci est aussi un commentaire\n\nIl est utile pour vous et vos coll√®gues de commencer vos scripts par quelques lignes comment√©es fournissant des informations importantes sur le contenu de votre script.\n\n# IMPORT & PREPARATION DES DONNEES #\n# Auteure :  Mathilde Mousset\n# Date de cr√©ation : 23/11/2024\n# Derni√®re mise √† jour : 28/01/2024\n# Description : Importat et nettoyage des donn√©es de surveillance rougeole de Moissala\n\n\nAjoutez quelques commentaires au d√©but de votre script pour le d√©crire.\n\nLes commentaires sont √©galement un moyen pratique de diviser les scripts longs en sections th√©matiques, telles que ‚ÄúImport des donn√©es‚Äù, ‚ÄúAnalyse‚Äù, ‚ÄúVisualisation‚Äù, etc. Par exemple :\n\n# NOM DE LA SECTION 1 -----------------------------------------------             \n\n# NOM DE LA SECTION 2 -----------------------------------------------             \n\n\nUtilisez les commentaires pour cr√©er des sections dans votre script qui correspondent aux sections principales de ce tutoriel.\n\nEnfin, les commentaires permettent de prendre des notes sur votre code pour aider √† la compr√©hension (celle de votre ‚Äúmoi futur‚Äù et celle de vos coll√®gues). On entend souvent le conseil de se focaliser sur les commentaires qui expliquent le ‚Äúpourquoi‚Äù plut√¥t que le ‚Äúquoi‚Äù, car le ‚Äúquoi‚Äù d‚Äôun code bien √©crit devrait √™tre clair.\nPar exemple, ce commentaire est superflu :\n\n1 + 3  # Code pour additionner un et trois\n\nEn comparaison, voici quelques cas o√π un commentaire est m√©rit√© :\n\nVous d√©finissez une constante, une valeur seuil de s√©ropr√©valence par exemple. Ajoutez un commentaire indiquant la r√©f√©rence d‚Äôo√π provient la valeur.\nVotre code contient une valeur ou un nom de fichier qui doit √™tre mis √† jour chaque semaine. Indiquez le dans un commentaire afin que toute personne utilisant le code en soit inform√©e.\nVous utilisez une commande contre-intuitive de premier abord, ou un paquet rare que votre coll√®gue ne conna√Æt peut-√™tre pas. Commentez pour expliquer vos raisons.\n\nCeci √©tant dit, vous √™tes en plein apprentissage, et les scripts que vous √©crivez pendant ce cours sont l‚Äô√©quivalent de vos notes de cours, alors n‚Äôh√©sitez pas √† utiliser autant de commentaires que vous le souhaitez pour expliquer les commandes et vous rappeler de ce qu‚Äôelles font. Vous √©crirez naturellement moins de commentaires avec la pratique, lorsque les choses qui nouvelles aujourd‚Äôhui deviendront naturelles.\n\n\n\n\n\n\nTip\n\n\n\nCommentez une ligne s√©lectionn√©e avec le raccourci CTRL + MAJ + C.\nAjoutez une section de premier niveau avec CTRL + MAJ + R.\n\n\n\nAjoutez quelques commentaires pour d√©crire le code que vous avez √©crit jusqu‚Äô√† pr√©sent dans votre script."
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#types-de-donn√©es",
    "href": "sessions_core/01_introduction.fr.html#types-de-donn√©es",
    "title": "Introduction √† R",
    "section": "Types de donn√©es",
    "text": "Types de donn√©es\nR dispose de plusieurs types de donn√©es. Ceux que nous verrons le plus souvent dans ce cours sont les suivants :\n\nnum√©rique [numeric en anglais]\ncha√Æne de caract√®res (texte) [string en anglais]\nbool√©en (VRAI / FAUX) [boolean en anglais]\ndate [date]\nfacteur [factor]\n\n\nNum√©rique\nLe type num√©rique englobe les entiers [integers en anglais] et les doubles (nombres d√©cimaux). Les nombres en R n‚Äôont pas de signal√©tique, tapez simplement la valeur brute dans votre script ou votre console.\n\n\nCha√Ænes de caract√®res\nLes cha√Ænes de caract√®res [strings] repr√©sentent le texte en R. Elles sont tap√©es en entourant votre texte de guillemets simples ou doubles, \"district\" ou 'cas' par exemple (les guillemets doubles sont g√©n√©ralement consid√©r√©s comme la meilleure pratique).\n\nComparez la sortie dans la console pour les commandes suivantes :\n\n28         # num√©rique\n\"28\"       # texte\n28 + \"28\"  # donne une erreur\n\n\nLa derni√®re commande ci-dessus a renvoy√© une erreur car nous ne pouvons pas effectuer d‚Äôop√©rations arithm√©tiques combinant du texte et des nombres.\n\n\n\n\n\n\nImportant\n\n\n\nR est sensible √† la casse (majuscules ou minuscules), ce qui signifie que \"ABC\" n‚Äôest pas √©quivalent √† \"abc\".\n\n\n\nSi vous souhaitez cr√©er une cha√Æne de caract√®res contenant des guillemets, il faut √©chapper les guillements les faisant pr√©c√©der d‚Äôun \\. Par exemple : \"Elle dit \\\"Bonjour\\\" et s'en alla\" ou 'C\\'est une belle journ√©e'. Si vous avez utilis√© des guillements doubles pour cr√©er votre cha√Æne de caract√®res, vous pouvez utiliser des guillemets simples √† l‚Äôint√©rieur de celle-ci (par exemple : \"C'est une belle journ√©e\") et vice versa (par exemple : 'Elle dit \"Bonjour\" et s'en alla').\n\n\n\nBool√©en (logique)\nLe type bool√©en (ou logique) stocke des valeurs vrai/faux et est cr√©√© en √©crivant soit TRUE [VRAI] ou FALSE [FAUX] sans guillemets.\nEn interne, R traduit TRUE et FALSE en √©quivalents num√©riques 1 et 0 respectivement, ce qui peut √™tre utile pour des op√©rations arithm√©tiques.\n\n\n\n\n\n\nNote\n\n\n\nVous verrez peut-√™tre des personnes qui utilisent T ou F mais c‚Äôest d√©conseill√© car T et F peuvent √©galement √™tre utilis√©s comme noms d‚Äôobjets ou de variables. En revanche, les valeurs TRUE et FALSE sont r√©serv√©es (prot√©g√©es), ce qui signifie qu‚Äôelles ne peuvent pas √™tre r√©affect√©s √† une autre valeur.\n\n\n\n\nD√©terminer le type d‚Äôun objet\nIl existe plusieurs fonctions permettant de d√©terminer le type d‚Äôun objet (souvent appel√© la classe de l‚Äôobjet en R [class].\n\nTapez les commandes suivantes dans votre script et ex√©cutez-les :\n\n# Obtenir le type\nclass(28)  \nclass(\"Mandoul\")\n\n# Test du type\nis.numeric(28)\nis.numeric(\"Mandoul\")\nis.character(\"Mandoul\")\n\nis.numeric(TRUE)\nis.character(TRUE)\nis.logical(FALSE)"
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#sec-assignement-operator",
    "href": "sessions_core/01_introduction.fr.html#sec-assignement-operator",
    "title": "Introduction √† R",
    "section": "Enregistrer un objet",
    "text": "Enregistrer un objet\nEn R, presque tout est un objet y compris les fonctions, les vecteurs et les structures plus complexes. Souvent, nous souhaitons r√©utiliser certains objets tout au long d‚Äôun script (un jeu de donn√©es par exemple). Il est donc tr√®s utile de les stocker dans notre environnement (la m√©moire de R). Pour ce faire, nous utilisons l‚Äôop√©rateur d‚Äôassignation &lt;-.\n\nRegardez le panneau environnement en haut √† droite. Il devrait √™tre vide. Tapez la commande suivante dans votre script et ex√©cutez-la. Elle enregistre une variable appel√©e cas dans votre environnement.\n\ncas &lt;- 28\n\nInspectez √† nouveau l‚Äôenvironnement. Est-il toujours vide ?\n\nSi vous souhaitez acc√©der √† la valeur de votre nouvel objet, cas il vous suffit d‚Äôex√©cuter son nom.\n\ncas\n\n[1] 28\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous √©crivons les cha√Ænes de caract√®res entre guillements pour permettre √† R de faire la diff√©rence entre un objet cas et le texte \"cas\".\n\n\nUne fois cr√©√©s, les objets peuvent √™tre utilis√©s dans d‚Äôautres commandes :\n\ncas + 5\n\n[1] 33\n\n\n\nDans votre script, cr√©ez un objet appel√© region qui contient la valeur \"Mandoul\". Est-il bien apparu dans votre environnement ?\n\n\n\n\n\n\n\nTip\n\n\n\nN‚Äôoubliez pas que nous devons toujours entourer l‚Äôop√©rateur &lt;- par des espaces afin d‚Äôam√©liorer la lisibilit√© et d‚Äô√©viter les erreurs.\n\nx&lt;-3     # MAUVAIS\nx &lt;- 3   # BIEN\n\n\n\n\nMettre √† jour d‚Äôun objet\nNous souhaitons souvent mettre √† jour la valeur stock√©e dans un objet. Pour ce faire, il suffit d‚Äôassigner une nouvelle valeur avec la m√™me syntaxe que celle utilis√©e lors de la cr√©ation de l‚Äôobjet :\n\ncas &lt;- 32\n\n\nMettez √† jour l‚Äôobjet region avec la valeur \"Moyen Chari\".\n\n\n\nNoms d‚Äôobjets\nPour nommer vos objets, il existe quelques r√®gles (relativement) strictes :\n\nNe pas commencer par un chiffre\nNe pas utiliser d‚Äôespaces (utiliser un _ √† la place)\nNe pas utiliser de valeurs r√©serv√©es (comme TRUE et FALSE) ou des noms de fonctions (comme mean)\nNe pas utiliser de majuscules (c‚Äôest plus une convention qu‚Äôune r√®gle dure)\n\nAu-del√† de ces r√®gles, il existe √©galement des bonnes pratiques plus subjectives et des styles personnels. En r√®gle g√©n√©rale, les noms doivent √™tre courts et descriptifs :\n\na &lt;- 19                              # Pas informatif\nage_du_patient_a_l_admission &lt;- 19   # Trop long\nage &lt;- 19                            # Concis et pr√©cis\n\nDes noms clairs et informatifs contribuent √† rendre votre code plus lisible, ce qui permet aux autres de le comprendre facilement sans avoir √† constamment consulter le dictionnaire de donn√©es."
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#structures-de-donn√©es",
    "href": "sessions_core/01_introduction.fr.html#structures-de-donn√©es",
    "title": "Introduction √† R",
    "section": "Structures de donn√©es",
    "text": "Structures de donn√©es\nJusqu‚Äô√† maintenant, nous avons cr√©√© des objets simples qui contenaient une seule valeur. A pr√©sent nous allons nous int√©resser √† des structures plus complexes qui peuvent contenir des jeux de donn√©es.\n\nVecteurs\nIl est possible de rassembler plusieurs valeurs (telles que des valeurs num√©riques ou des cha√Ænes de caract√®res) en un seul objet, appel√© vecteur.\nTechniquement, il existe plusieurs types de vecteurs, dont :\n\nles vecteurs simples (ou vecteurs atomiques) ne peuvent contenir qu‚Äôun seul type de valeurs. Par exemple, un vecteur d‚Äôentiers contenant 2, 4, 6 ou un vecteur de texte contenant \"Mandoul\", \"Moyen Chari\".\nles vecteurs r√©cursifs (g√©n√©ralement appel√©s listes) sont plus complexes et peuvent contenir plusieurs dimensions et types de donn√©es. Nous ne les aborderons pas dans cette le√ßon.\n\nCette le√ßon n‚Äôentrera pas dans les d√©tails abstraits de ces structures et se concentrera sur celles que vous rencontrerez le plus souvent dans votre travail.\n\nVecteurs simples\nLes vecteurs simples peuvent contenir une ou plusieurs valeurs d‚Äôun seul type de donn√©es. Ils ont donc deux propri√©t√©s essentielles : une longueur et un type. Dans le cadre de ce cours, nous utiliserons indiff√©remment les termes ‚Äúvecteur simple‚Äù et ‚Äúvecteur‚Äù, comme c‚Äôest g√©n√©ralement le cas dans la communaut√© R.\nTechniquement, vous avez d√©j√† cr√©√© vos premiers vecteurs simples lorsque vous avez construit les objets cas et region. Il s‚Äôagissait de vecteurs avec une longueur de taille une. Pour cr√©er un vecteur avec plus d‚Äôune valeur, nous utiliserons la fonction c() (moyen mn√©motechnique) :\n\ncas &lt;- c(2, 5, 8, 0, 4)\n\n\nMettez √† jour cas avec les valeurs ci-dessus et mettez √† jour region pour cr√©er un vecteur de cha√Ænes de caract√®res contenant les valeurs suivantes : Mandoul, Moyen-Chari, Logone Oriental, Tibesti et Logone Occidental.\n\nNous pouvons maintenant utiliser des fonctions sur les objets que nous avons cr√©√©s :\n\nmean(cas)  # Calcule la moyenne des valeurs stock√©es dans le vecteur\n\n[1] 3.8\n\ntoupper(region)  # Convertit les valeurs du vecteur en majuscules\n\n[1] \"MANDOUL\"           \"MOYEN-CHARI\"       \"LOGONE ORIENTAL\"  \n[4] \"TIBESTI\"           \"LOGONE OCCIDENTAL\"\n\n\n\nEcrivez des commandes dans votre script pour effectuer les actions suivantes :\n\ncalculer la somme des valeurs de cas avec la fonction sum()\nconvertir le texte de region en minuscules √† l‚Äôaide de la fonction tolower()\n\n\n\n\n\nAcc√®s aux valeurs d‚Äôun vecteur\nIl est possible d‚Äôacc√©der √† une valeur d‚Äôun vecteur en donnant son indice (i.e. sa position dans le vecteur) entre crochets :\n\ncas[2]   # Deuxi√®me valeur de cas\n\n[1] 5\n\ncas[10]  # Dixi√®me valeur de cas\n\n[1] NA\n\n\nOups il n‚Äôy a pas de dixi√®me valeur dans cas ! Nous reviendrons sur ce que ce NA signifie dans la section valeurs manquantes.\nNous pouvons √©galement acc√©der √† une plage de valeurs, comme nous pourrions le faire dans Excel. Nous utilisons l‚Äôop√©rateur : entre la position minimum et maximum de la plage :\n\ncas[2:4]  # de la deuxi√®me √† la quatri√®me valeur\n\n[1] 5 8 0\n\n\n\nAffichez la 3√®me valeur du vecteur region.\nAcc√©dez aux valeurs ‚ÄúMandoul‚Äù et ‚ÄúMoyen-Chari‚Äù du vecteur region.\n\n\n\nData frames\nLes data frames sont des structures tabulaires / tableaux en 2D avec des lignes et des colonnes. Il s‚Äôagit d‚Äôune structure tr√®s similaire √† celle d‚Äôun ‚Äútableau‚Äù dans Excel. En tant qu‚Äô√©pid√©miologistes, ce type d‚Äôobjet est l‚Äôun des plus utiles et vous l‚Äôutiliserez quotidiennement pour stocker des jeux de donn√©es (des listes lin√©aires par exemple).\n\nCr√©ation d‚Äôun data frame\nNous cr√©ons un data frame avec la fonction data.frame() :\n\ndata.frame(col1 = c(1, 4, 2, 9),\n           col2 = c(\"un peu de texte\", \"plus de text\", \"Salut !\", \"les epidemiologistes !\"))\n\n  col1                   col2\n1    1        un peu de texte\n2    4           plus de text\n3    2                Salut !\n4    9 les epidemiologistes !\n\n\nIci, on a cr√©e col1 √† partir d‚Äôun vecteur num√©rique, et col2 √† partir d‚Äôun vecteur de cha√Ænes de caract√®res. Nous avons choisi les noms des colonnes (col1 et col2), ce qui est normal, mais vous pouvez ex√©cuter le code sans nommer les colonnes pour voir comment R cr√©e lui m√™me des noms.\n\nDans votre script, cr√©ez un data frame nom√© data_cas qui contient cas dans une colonne et region dans l‚Äôautre.\n\n\n\nExploration d‚Äôun data frame\nL‚Äôobjet data_cas devrait maintenant appara√Ætre dans votre environnement. Vous pouvez cliquer sur le cercle bleu avec un triangle blanc pour d√©rouler des informations suppl√©mentaires, ou cliquer sur son nom pour le visualiser dans un onglet dans le m√™me volet que votre script.\n\n\n\nLe data frame data_cas appara√Æt d√©sormais dans l‚Äôonglet Environnement.\n\n\nIl existe plusieurs fonctions pratiques pour explorer un data frame :\n\nEx√©cutez les commandes suivantes et essayez de d√©terminer le type d‚Äôinformations qu‚Äôelles renvoient.\n\nstr(data_cas)     # STRucture de l'object\ndim(data_cas)     # DIMension de l'object\nnrow(data_cas)    # Nombre de lignes (row = ligne)\nncol(data_cas)    # Nombre de COLonnes\nnames(data_cas)   # noms des colonnes\n\n\nPratiquons un peu plus ! R est livr√© avec quelques data frames int√©gr√©s auxquels il est possible d‚Äôacc√©der directement, dont un appel√© iris. C‚Äôest pratique pour cette session car nous n‚Äôavons pas encore appris √† importer des donn√©es dans R (ne vous inqui√©tez pas, nous travaillerons sur des donn√©es de liste lin√©aire d√®s la prochaine session !).\nNous pouvons afficher les premi√®res lignes de ce data frame gr√¢ce √† la fonction head() [head = la t√™te en anglais] :\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nCombien de lignes et de colonnes y a-t-il dans iris? Quels sont les noms des colonnes de ce data frame ?\n\n\n\nAcc√©der aux donn√©es d‚Äôun data frame\nEn R, il existe plusieurs m√©thodes pour acc√©der aux lignes et/ou colonnes d‚Äôun data frame. Dans cette session d‚Äôintroduction, nous nous concentrerons sur la syntaxe [row, column].\nNous pouvons utiliser un num√©ro (ou un intervalle) de ligne pour extraire des lignes, et des num√©ros (ou un intervalle) de colonnes pour extraire les colonnes. Ont peut √©galement utiliser le nom des colonnes pour y acc√©der.\n\ndata_cas[1, 2]    # Afficher la valeur de la ligne 1, deuxi√®me colonne\n\n[1] \"Mandoul\"\n\ndata_cas[1, \"region\"]   # Afficher la valeur de la lignbe 1, pour la colonne r√©gion\n\n[1] \"Mandoul\"\n\n\nSi nous voulons isoler toutes les lignes (ou colonnes), nous pouvons simplement laisser un espace √† la place du num√©ro/nom :\n\ndata_cas[1, ]  # Extrait la premi√®re ligne (garde toutes les colonnes)\n\n  cas  region\n1   2 Mandoul\n\ndata_cas[2:4, ]   # Valeurs des lignes 2 √† 4, pour toutes les colonnes\n\n  cas         region\n2   5       Sud Kivu\n3   8 Kasai oriental\n4   0          Kasai\n\ndata_cas[ , \"region\"]   # Garde toutes les lignes mais que la colonne r√©gion\n\n[1] \"Mandoul\"        \"Sud Kivu\"       \"Kasai oriental\" \"Kasai\"         \n[5] \"Haut Katanga\"  \n\n\nNous pouvons m√™me s√©lectionner plusieurs indices non cons√©cutifs en utilisant un vecteur :\n\ndata_cas[c(1, 3), ]  # Ligne 1 et 3 (toutes les colonnes)\n\n  cas         region\n1   2        Mandoul\n3   8 Kasai oriental\n\n\nSoyez attentifs, le type de l‚Äôobjet renvoy√© par [ ] d√©pend de l‚Äôindexation utilis√©e :\n\nstr(data_cas[1 , ])   # Renvoit un data frame\n\n'data.frame':   1 obs. of  2 variables:\n $ cas   : num 2\n $ region: chr \"Mandoul\"\n\nstr(data_cas[ , 1])   # Renvoit un vecteur\n\n num [1:5] 2 5 8 0 4\n\n\nUne syntaxe simplifi√©e existe pour extraire des colonnes d‚Äôun data frame :\n\ndata_cas[2]           # Renvoit la deuxi√®me colonne (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\ndata_cas[\"region\"]    # Renvoit la colonne r√©gion (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\n\n\nEcrivez le code pour :\n\nextraire la troisi√®me valeur de la colonne region de votre data frame\nextraire les deuxi√®me et troisi√®me valeurs de la colonne cas\ncalculer la somme des valeurs de la colonne cas"
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#sec-missing-values",
    "href": "sessions_core/01_introduction.fr.html#sec-missing-values",
    "title": "Introduction √† R",
    "section": "Valeurs manquantes",
    "text": "Valeurs manquantes\nEn tant qu‚Äô√©pid√©miologistes, nous sommes constamment confront√©s aux donn√©es manquantes. Dans R, celles-ci sont cod√©es √† l‚Äôaide d‚Äôune valeur sp√©ciale : NA [signifiant Not Available]. La valeur NA n‚Äôa pas de type fixe, elle prend celui des valeurs qui l‚Äôentourent. Par exemple, un NA dans une colonne num√©rique est trait√©e comme une valeur num√©rique. Nous aurons des occasions de manipuler les NA dans la suite du cours."
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#sec-functions",
    "href": "sessions_core/01_introduction.fr.html#sec-functions",
    "title": "Introduction √† R",
    "section": "Fonctions",
    "text": "Fonctions\nLes fonctions sont des objets qui contiennent des commandes (au lieu de valeurs) qui sont ex√©cut√©es chaque fois que la fonction est lanc√©e. Vous √™tes sans doute familiers avec les fonctions dans Excel, telles que la fonction SOMME() ou la fonction MOYENNE(). Bonne nouvelle, les fonctions sont similaires dans R !\nLa majorit√© des fonctions que vous allez utiliser ont besoin d‚Äôinformations compl√©mentaires : a minima des donn√©es, mais aussi d‚Äôautres param√®tres. On appelle ces informations des arguments. Les arguments sont normalement nomm√©s.\nPar exemple, lorsque nous avons ex√©cut√© la commande sum(cas), nous avons fourni le vecteur cas comme premier (et seul) argument de la fonction sum().\nParmis les arguments d‚Äôune fonction, certains peuvent √™tre obligatoires, d‚Äôautres facultatifs. Le premier argument est presque toujours obligatoire et est souvent un data frame ou un vecteur de donn√©es. Comme c‚Äôest un argument √©vident, on omet souvent son nom (il vous a sans doute sembl√© naturel de taper mean(cas) au lieu de mean(x = cas)).\nLes arguments facultatifs, en revanche, sont g√©n√©ralement utilis√©s avec neur nom. Par exemple : mean(cas, na.rm = TRUE). Les arguments facultatifs sont souvent fournis avec des valeurs par d√©faut raisonnables, ce qui fait que l‚Äôutilisateur ne les sp√©cifie que lorsqu‚Äôil a besoin de changer ces valeurs par d√©faut. Par exemple, l‚Äôargument na.rm de la fonction mean() controle comment les valeurs manquantes sont g√©r√©es lors du calcul de la moyenne [‚Äúna‚Äù en r√©f√©rence aux valeurs manquantes NA, et ‚Äúrm‚Äù comme raccourci de ‚ÄúReMove‚Äù, que l‚Äôon peut traduire dans ce contexte par enlever ou ignorer]. Par d√©fault, la valeur de na.rm est FALSE Ainsi, par d√©faut, la moyenne de donn√©es avec des valeurs manquantes renverra toujours NA :\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nCeci est vrai pour de nombreuses op√©rations arithm√©tiques dans R. Si l‚Äôon veut que que R calcule la moyenne sur toutes les donn√©es disponibles et ignore les valeurs manquantes, nous devons explicitement fournir l‚Äôargument na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nLes arguments sont s√©par√©s par des virgules.\nCes virgules doivent toujours √™tre suivies d‚Äôun espace\nChaque fois qu‚Äôun argument nomm√© est utilis√©, l‚Äôattribut = doit √™tre entour√© d‚Äôespaces :\n\n\nmean(cas,na.rm=TRUE)     # MAUVAIS\nmean(cas, na.rm = TRUE)  # BON\n\nSi vous √©crivez une commande avec de nombreux arguments, s√©parez chaque argument sur sa propre ligne pour am√©liorer la lisibilit√© :\n\nmean(cas, \n     na.rm = TRUE) \n\n\n\nQue se passe-t-il si l‚Äôon fournit plusieurs arguments dans le d√©sordre ? Si vous avez nomm√© les arguments la fonction s‚Äôex√©cutera correctement, mais le code sera contre-intuitif et peu lisible. Nous vous conseillons de respecter l‚Äôordre standard, en pla√ßant les arguments obligatoires tels que les donn√©es en premier.\n\n# Fonctionnel mais dur √† lire\nmean(na.rm = TRUE,  \n     x = cas) \n\n# mieux\nmean(cas,         \n     na.rm = TRUE)\n\nEn revanche, si vous ne nommez pas les arguments et les passez dans le d√©sordre, alors la fonction ne fonctionnera pas comme pr√©vu, voire renverra une erreur :\n\nmean(TRUE, cas)  # Pas ce que vous attendez"
  },
  {
    "objectID": "sessions_core/01_introduction.fr.html#termin√©",
    "href": "sessions_core/01_introduction.fr.html#termin√©",
    "title": "Introduction √† R",
    "section": "Termin√© !",
    "text": "Termin√© !\nC‚Äôest tout pour cette session, bravo pour vos d√©buts avec R et RStudio !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/05_summary-table.html",
    "href": "sessions_core/05_summary-table.html",
    "title": "Summary tables",
    "section": "",
    "text": "Create contingency tables with count()\nCompute summary statistics by group using summarize()\nReview how to subset rows using filter() and create/modify variables with mutate()\nCreate ordered categorical variables\n\n\nThis session will use the clean version of the Moissala measles dataset. Download the data and store them in data/clean in your practice project:\n\n\n\n Clean Measles Linelist"
  },
  {
    "objectID": "sessions_core/05_summary-table.html#objectives",
    "href": "sessions_core/05_summary-table.html#objectives",
    "title": "Summary tables",
    "section": "",
    "text": "Create contingency tables with count()\nCompute summary statistics by group using summarize()\nReview how to subset rows using filter() and create/modify variables with mutate()\nCreate ordered categorical variables\n\n\nThis session will use the clean version of the Moissala measles dataset. Download the data and store them in data/clean in your practice project:\n\n\n\n Clean Measles Linelist"
  },
  {
    "objectID": "sessions_core/05_summary-table.html#setup",
    "href": "sessions_core/05_summary-table.html#setup",
    "title": "Summary tables",
    "section": "Setup",
    "text": "Setup\n\nOpen your RStudio Project and create a new script in the R folder called tables.R with appropriate metadata and a ‚ÄúPackages‚Äù section that imports: {rio}, {here} and {tidyverse}. Add an ‚ÄúImport Data‚Äù section that loads the cleaned version of the measles linelist."
  },
  {
    "objectID": "sessions_core/05_summary-table.html#introduction-data-aggregation",
    "href": "sessions_core/05_summary-table.html#introduction-data-aggregation",
    "title": "Summary tables",
    "section": "Introduction: Data aggregation",
    "text": "Introduction: Data aggregation\nOK so let‚Äôs recap, you have just performed one of the most important tasks of an epidemiologist: the data cleaning. Now that you have clean and standardise data, we can get into the real business and start analysing them. Analyses typically start with some tables and summaries to describe our data:\n\nUnivariate frequency tables to count occurrences of different values\nSummary statistics (mean, median, standard deviation) of numerical variables\nCross-tabulations to examine relationships between categorical variables\nGroup-wise summaries to compare statistics across different subsets of the data"
  },
  {
    "objectID": "sessions_core/05_summary-table.html#counting-multiple-columns-contingency-tables",
    "href": "sessions_core/05_summary-table.html#counting-multiple-columns-contingency-tables",
    "title": "Summary tables",
    "section": "Counting Multiple Columns (Contingency Tables)",
    "text": "Counting Multiple Columns (Contingency Tables)\nDuring the data exploration session, you have learned to create frequency table for a single categorical variable using the count() function. Counting one variable is nice, but we often want to count the number observations based on two (or more!) variables.\nThese tables are called contingency tables. For example, knowing the number of patients by sub_prefecture is great but we might want to stratify by both sub_prefecture and age_group to see if certain areas have unusually old patients. Doing this is easy, you just need to pass multiple column names to count(); for example:\n\ndf_linelist |&gt;\n  count(sub_prefecture, age_group)\n\n\nCreate a new summary table counting the number of patients stratified by sub_prefecture and hospitalisation. What happens if you change the order of the arguments given to count()?\n\n\nUsing count() answer the following questions:\n\nHow many patients were female? What is the proportion?\nWhat are all the possible values of the outcome variable?\nHow many patients between 1 - 4 years have recovered?"
  },
  {
    "objectID": "sessions_core/05_summary-table.html#filtering-out-nas",
    "href": "sessions_core/05_summary-table.html#filtering-out-nas",
    "title": "Summary tables",
    "section": "Filtering out NAs",
    "text": "Filtering out NAs\nWhen looking at the categories of outcome, you should have spotted that some patients have missing values (NA):\n\ndf_linelist |&gt;\n  count(outcome) |&gt;\n  mutate(prop = n / sum(n))\n\n\nObserve the output of the code above. How can you also call the proportion of patients who died ? Are you happy with this calculation ?\n\nThe proportion of cases that died is also referred to as the Case Fatality Ratio (CFR). However, to precisely calculate the CFR we need to make sure that the denominator only includes patient for whom we are sure of their outcome (ie we need to remove all cases with NA or left aginst medical advice).\nRemember that we can do this using filter(). To filter for missing values (NA) in a variable we can use the small function is.na(outcome). Adding a ! in front will do the opposite: removing missing values from outcome:\n\ndf_linelist |&gt;\n  filter(\n    outcome != \"left against medical advice\", \n    !is.na(outcome)\n  ) |&gt;\n  count(outcome)\n\n\nWhich other conditionnal statement could you use in filter() to obtain the same results\n\nNow that we have removed the patients with unknown outcomes, we can add this before creating our frequency table to get the right CFR.\n\nUsing your filter, update your code to summarize the observed number of patients who survived and died as well as the CFR (proportion who died). Store this new dataframe into an object, cfr_df.\n\n\n\n\n\n\n\nTip\n\n\n\nBonus. Another useful ‚Äúshortcut‚Äù function is drop_na() from the package {tidyr} that equates to filter(!is.na()).\n\ndf_linelist |&gt;\n  drop_na(outcome) |&gt;\n  count(outcome)\n\ndrop_na() is particularly useful as you can give it multiple column names to filter by. But be careful that doing so will remove all rows where one or more of those columns have a missing value."
  },
  {
    "objectID": "sessions_core/05_summary-table.html#summary-table-statistics-by-sub-prefecture",
    "href": "sessions_core/05_summary-table.html#summary-table-statistics-by-sub-prefecture",
    "title": "Summary tables",
    "section": "Summary Table: Statistics by sub prefecture",
    "text": "Summary Table: Statistics by sub prefecture\nOk now that we have produced some simple frequency and contingency tables we may want to increase the complexity. A common task in epidemiology is to look at summary statistics within subsets of the data.\nFor example, we may be asked to produce patient statistics at the sub-prefecture level, ie: for each sub-prefecture in the data, we need to answer the following questions:\n\nHow many patients?\nWhat is their average age?\nWhat was the earliest date of admission?\nHow many patients have been hospitalised?\nAmong children under 6 months, how many have died?\n\nThis is exactly what the function summarize() has been made for! It allows us to calculate summary statistics on a dataset, and the syntax is similar to that of mutate():\n\n# DO NOT RUN (PSEUDO-CODE)\ndf |&gt;\n  mutate(new_col = function_to_create(existing_col))\n\ndf |&gt;\n  summarize(\n    .by = grouping_variable,\n    new_col = summary_function(existing_col)\n  )\n\nConsider the following code, here we are summarising the data to calculate the average age across all patients.\n\ndf_linelist |&gt;\n  summarize(mean_age = mean(age))\n\n# A tibble: 1 √ó 1\n  mean_age\n     &lt;dbl&gt;\n1     6.82\n\n\nYou might notice that this code yields a single value for average age. When the data are not grouped, summarize() will consider the full dataset as a single group and return one summary statistic for the whole dataset. To calculate the average age by a specific strata, we need to specify a ‚Äúgrouping variable‚Äù using the .by = argument:\n\ndf_linelist |&gt;\n  summarize(\n    .by = sex,\n    mean_age = mean(age)\n  )\n\n# A tibble: 2 √ó 2\n  sex   mean_age\n  &lt;chr&gt;    &lt;dbl&gt;\n1 f         6.77\n2 m         6.87\n\n\n\nTake a look at the above results. How would you interpret them?\n\nNow that we can use summarize() we can use it to calculate some proper summary statistics by sub-prefecture. Let‚Äôs start by calling an empty summarize() and grouping the data on sub_prefecture.\n\nRun the following code:\n\ndf_linelist |&gt;\n  summarize(\n    .by = sub_prefecture\n  )\n\nWhat happens when you run these lines?\n\n\nCounts\nWe first want to look at the number of cases in each sub_prefecture. This can be done using the helper function n():\n\ndf_linelist |&gt;\n  summarize(\n    .by = sub_prefecture,\n    n_patients = n()\n  )\n\n\nOk now let‚Äôs build a summary table for each sub_prefecture. First start by replicating the above lines\n\n\n\nContinuous Summaries\nWe can then use the simple mean, median, min, max functions to produce summaries for continuous variables. For example the average age:\n\ndf_linelist |&gt;\n  summarize(\n    .by = sub_prefecture,\n    n_patients = n(),\n    mean_age = mean(age)\n  )\n\n\nAdd the minimum date of admission to your table for each of the sub_prefecture? Are you happy with the results?\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that with the small functions (mean, median, min, max), you need to explicitly tell R to remove NA.\n\n\n\n\nCounting with a Condition\nWe may also be interested in looking at the number of patients (rows) that fit a condition: the number of patients that were female. Counting by a logical condition can be done with the following syntax:\n\n# DO NOT RUN (PSEUDO-CODE)\nsummarize(\n  sum_category = sum(LOGIC_TEST,\n  na.rm = TRUE\n))\n\nThis sum allows us to count all the lines where our condition was met. For example:\n\ndf_linelist |&gt;\n  summarize(\n    .by = sub_prefecture,\n    n_female = sum(sex == \"f\", na.rm = TRUE)\n  )\n\n\nAdd a variable to your table that counts the number of patients that have been hospitalised? (ie: rows that have yes in variable hospitalisation)\n\n\n\nOther Statistics\nSometimes we want to produce a statistic other than counting given a condition, let‚Äôs say the mean age of all hospitalised patients. Here the syntax is a bit different:\n\n# DO NOT RUN (PSEUDO-CODE)\ndf |&gt;\n  summarize(\n    mean_category = mean(col_to_use[LOGIC_TEST],\n    na.rm = TRUE\n  ))\n\nHere, we have:\n\nIndicated which column we want to use when caluclating the summary statistic (here a mean)\nIndexed that column using a logical test\n\nFor example to compute the mean() of the age variable but only in rows where hospitalisation == \"yes\" we would write it like this:\n\ndf_linelist |&gt;\n  summarize(\n    .by = sub_prefecture,\n    n_patients = n(),\n    mean_age_hosp = mean(age[hospitalisation == \"yes\"], na.rm = TRUE)\n  )\n\n\nCan you use this syntax to calculate the mean age of female patients in your table ?\n\nThat is looking great! We are starting to get a pretty exhaustive grouped summary table with a lot of useful information by sub_prefecture! An extra challenge for you:\n\nCHALLENGE: Could you add a variable to your table that counts the number of patients that died among the ones that are &lt; 6 months old.\n\n\n\n\n\n\nTip\n\n\n\nYou want to count rows (so use sum()) that fill a specific condition for outcome (outcome == \"dead\"), but only when age_group == \"&lt; 6 months\"\n\n\n\n\n\nUse the output\nFinally, a reminder that summarize() returns a dataframe that we can then further manipulate (eg: with filter and mutate).\n\nCan you add a mutate() after producing your summary table to calculate:\n\nThe proportion of hospitalised patients per sub-prefecture\nThe proportion of female patients per sub-prefecture\n\n\nHere is our final table !"
  },
  {
    "objectID": "sessions_core/05_summary-table.html#done",
    "href": "sessions_core/05_summary-table.html#done",
    "title": "Summary tables",
    "section": "Done!",
    "text": "Done!\nYou should be proud of yourselves, making summary tables is an important skill to an epidemiologist, making it in R is very efficient !! Don‚Äôt forget to save your code !\n\n\n\n Solution File"
  },
  {
    "objectID": "sessions_core/05_summary-table.html#going-further",
    "href": "sessions_core/05_summary-table.html#going-further",
    "title": "Summary tables",
    "section": "Going Further",
    "text": "Going Further\n\nExtra Exercises\nMake a summary table that summarizes: - The number of patients - The proportion of male - The number of deaths - The CFR - The number of deaths among patients that had pneumonia\nin all the different age groups !\n\n\nAdditional Resources\n\nThe EpiR Handbook chapter on grouping data\nOnce you have tables, you can extensively customise them for display/publication using {gt} package:\n\nWebsite of gt\nBook about gt"
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html",
    "href": "sessions_core/02_import_data.fr.html",
    "title": "Importer des donn√©es",
    "section": "",
    "text": "Cr√©er un projet RStudio\nMettre en place un code organis√© et bien document√©\nInstaller et charger des paquets dans la session\nEcrire des chemins d‚Äôacc√®s aux fichiers robustes\nImporter et inspecter des donn√©es dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des donn√©es s‚Äôappliquent aussi √† votre code : on souhaite √©crire un script qui fonctionne maintenant, mais √©galement dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider √† aller dans cette direction, et la premi√®re est d‚Äôavoir un code source propre et bien organis√©."
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html#objectifs",
    "href": "sessions_core/02_import_data.fr.html#objectifs",
    "title": "Importer des donn√©es",
    "section": "",
    "text": "Cr√©er un projet RStudio\nMettre en place un code organis√© et bien document√©\nInstaller et charger des paquets dans la session\nEcrire des chemins d‚Äôacc√®s aux fichiers robustes\nImporter et inspecter des donn√©es dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des donn√©es s‚Äôappliquent aussi √† votre code : on souhaite √©crire un script qui fonctionne maintenant, mais √©galement dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider √† aller dans cette direction, et la premi√®re est d‚Äôavoir un code source propre et bien organis√©."
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html#mise-en-place-du-projet",
    "href": "sessions_core/02_import_data.fr.html#mise-en-place-du-projet",
    "title": "Importer des donn√©es",
    "section": "Mise en place du projet",
    "text": "Mise en place du projet\n\nStructure des dossiers\n\nSi ce n‚Äôest pas d√©j√† fait, t√©l√©chargez le dossier du cours d√©compressez-le. Sauvegardez le dossier non compress√© √† un endroit non connect√© √† OneDrive et ouvrez-le.\n\n\n\n  Dossier du cours\n\n\n\n\nCe dossier illustre une structure typique et recommand√©e pour vos projets de code :\n\nüìÅ data\n\nüìÅ raw\nüìÅ clean\n\nüìÅ R\nüìÅ outputs\n\nCe dossier sera votre r√©pertoire de travail pour toutes les sessions de ce cours. Vous y cr√©erez un projet RStudio (explications ci-dessous), et y enregistrerez tous vos scripts (sous dossier R). Les donn√©es brutes se trouvent d√©j√† dans data/raw.\n\n\nD√©finitions\nVoici deux concepts importants que nous allons rencontrer dans cette session :\nR√©pertoire de travail. Le r√©pertoire de travail est l‚Äôemplacement (dossier) o√π votre session R en cours travaille. Si vous enregistrez un fichier, par exemple, il sera enregistr√© dans ce dossier par d√©faut. De m√™me, Si vous ouvrez un fichier, ce dossier sera affich√© par d√©faut. Tous les chemins relatifs auront ce dossier pour origine. Par d√©faut, R choisit g√©n√©ralement votre dossier ‚ÄúDocuments‚Äù comme r√©pertoire de travail sur les machines Windows.\nRacine. La racine fait r√©f√©rence au niveau de dossier le plus √©lev√© du r√©pertoire de travail. Si le dossier de votre cours s‚Äôappelle FETCHR la racine se trouverait directement √† l‚Äôint√©rieur de celui-ci (et non dans l‚Äôun de ses sous-dossiers comme R ou data).\n\n\nProjets RStudio\nUn projet RStudio est outil qui va faciliter votre vie et aider RStudio √† trouver les diff√©rents fichiers.\nPour rappel, votre interface doit ressembler √† ceci :\n\n\n\n\n\n\nFigure¬†1: Capture d‚Äô√©cran d‚Äôune interface RStudio typique\n\n\n\n\nOuvrez RStudio et suivez ces √©tapes pour cr√©er un nouveau projet :\n\ncliquez sur File &gt; New Project &gt; Existing Directory &gt; Browse,\nnaviguez jusqu‚Äôau dossier du cours (en l‚Äôouvrant)\ncliquez sur Create Project.\n\n\n\nDans l‚Äôexplorateur Windows, examinez le dossier du cours. Vous devriez maintenant voir un nouveau fichier avec l‚Äôextension .Rproj qui a une petite ic√¥ne bleue avec un R au milieu\n\n\n\n\nIc√¥ne associ√©e aux projets RStudio\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi vous ne voyez pas ce fichier, c‚Äôest probablement parce qu‚Äôil est cach√© par d√©faut sur votre ordinateur. Pour modifier ce param√®tre dans l‚Äôexplorateur Windows, allez dans le menu Afficher et s√©lectionnez Extensions de noms de fichier.\n\n\nLorsque vous ouvrez un projet RStudio, RStudio d√©marre une nouvelle session R sp√©cifique √† ce projet, ouvre les fichiers associ√©s et d√©finit la racine de votre dossier comme r√©pertoire de travail. Une cons√©quence imm√©diate est que le panneau Files en bas √† droite de l‚Äôinterface montre les sous dossiers pr√©sents dans le r√©pertoire de travail, i.e. votre dossier de cours.\n\n\n\n\n\n\nTip\n\n\n\nIl est fortement recommand√© de mettre en place un projet RStudio distinct pour chacune de vos analyses afin de garantir que les fichiers de vos projets restent organis√©s.\n\n\nIl existe plusieurs fa√ßons d‚Äôouvrir un projet RStudio :\n\nUtilisez le menu RStudio File &gt; Open Project puis s√©lectionnez le fichier .Rproj appropri√©\nCliquez sur le bouton Project: (none) en haut √† droite de l‚Äôinterface RStudio\nNaviguez dans l‚Äôexplorateur de fichiers Windows jusqu‚Äô√† votre dossier de cours et double-cliquez sur le fichier avec l‚Äôextension .Rproj\n\n\n\nLes options de RStudio\nAvant de poursuivre, allons modifier certaines des options de RStudio qui peuvent causer des probl√®mes.\n\nOuvrez les options globales (Tools &gt; Global Options) et ouvrez l‚Äôonglet General (menu de gauche). D√©selectionnez toutes les cases des sections R Sessions, Workspace et History.\n\n\n\n\nCapture d‚Äô√©cran des options de RStudio\n\n\nLorsque ces options sont activ√©es, RStudio enregistre les objets de votre environnement et les charge √† chaque fois que vous ouvrez une nouvelle session R. Ca semble √™tre une bonne id√©e, mais il est en fait pr√©f√©rable de toujours commencer votre travail √† partir d‚Äôune session R vide afin d‚Äô√©viter les erreurs.\n\n\n\n\n\n\nImportant\n\n\n\nN‚Äôoubliez pas que toutes les commandes n√©cessaires au nettoyage et √† l‚Äôanalyse de vos donn√©es doivent √™tre enregistr√©es explicitement dans un script, dans le bon ordre. Faire retourner le script devrait arriver aux m√™mes r√©sultats que pr√©c√©dement.\n\n\n\n\nCr√©ation d‚Äôun nouveau script\n\nOuvrez un nouveau script et enregistrez-le dans le sous-dossier R de votre projet sous le nom import_data.R.\nAjoutez des m√©tadonn√©es au d√©but du script, comme recommand√© lors premi√®re session, en utilisant des commentaires. Veillez √† inclure :\n\nLe titre\nL‚Äôauteur du script\nLa date de cr√©ation\nUne description rapide de ce que fait le script\n\n\nNous sommes pr√™ts √† commencer √† coder"
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html#sec-packages",
    "href": "sessions_core/02_import_data.fr.html#sec-packages",
    "title": "Importer des donn√©es",
    "section": "Paquets",
    "text": "Paquets\nLes paquets [packages] sont des collections de fonctions qui √©tendent les fonctionalit√©s de R. Vous en utiliserez un grand nombre pendant ce cours et dans votre travail quotidien. R √©tant open-souce, les packages sont t√©l√©chargeable et utilisable gratuitement.\n\n\n\n\n\n\nNote\n\n\n\nDans ce cours, nous utiliserons une convention commune qui est de r√©f√©rencer les paquets entre {}. Par exemple {ggplot2} est le nom du paquet ggplot2 qui contient des fonctions pour cr√©er des graphes, telles que ggplot(), geom_point() etc‚Ä¶\n\n\n\nInstallation\nLa fonction install.packages() t√©l√©charge et installe un nouveau paquet sur votre ordinateur, dans la biblioth√®que de paquets associ√©e √† R. Vous n‚Äôavez √† faire cette op√©ration qu‚Äôune seule fois par paquet et ordinateur.\n\ninstall.packages(\"here\") # installe le paquet {here} \n\nN‚Äôoubliez pas de mettre le nom du paquet entre guillemets lorsque vous utilisez la commande install.packages(). Que se passe-t-il si vous ne le faites pas ?\n\n\n\n\n\n\nNote\n\n\n\nSi vous suivez cette session dans le cadre d‚Äôun cours, pour √©viter tout probl√®me potentiel de connectivit√© internet pendant la formation, nous vous avons d√©j√† fait installer la plupart des paquets du cours.\nSi vous suivez ce tutoriel seul ou si vous n‚Äôavez pas encore install√© les paquets, vous devrez installer manuellement chaque nouveau paquet que nous rencontrerons avec la fonction install.packages().\n\n\n\n\nUtilisation\nUne fois qu‚Äôun paquet est install√©, il faut indiquer √† R que nous souhaitons l‚Äôutiliser pour une session donn√©e en le chargeant dans la session avec la fonction library().\n\nlibrary(here) # charge le paquet {here} dans la session\n\n\nUtilisez la fonction library() pour charger les paquets here et rio qui seront utilis√©s aujourd‚Äôhui.\n\nIl se peut que vous obteniez parfois un message d‚Äôavertissement signalant que certaines fonctions ont √©t√© masqu√©es ou que la version actuelle du paquet a √©t√© construite pour une version diff√©rente de R. Ces messages ne doivent pas vous inqui√©ter, mais il faut les lire et essayer de comprendre ce qui se passe.\n\nEx√©cutez le code suivant. Comprenez-vous le message d‚Äôerreur ?\n\nlibrary(ggplot)\n\n\nLe code ci-dessus g√©n√®re une erreur car il y a une faute de frappe dans le nom du paquet, et vous avez donc essay√© de charger un paquet qui n‚Äôexiste pas. Rappelez-vous que R est p√©nible, et en particulier est sensible √† la casse : beaucoup de vos erreurs viendront de petites fautes dans les noms de fonctions ou d‚Äôobjets. Ici, par exemple, nous voulions charger le paquet ggplot2 mais nous avons √©crit ggplot √† la place.\n\n\n\n\n\n\nTip\n\n\n\nIl est recommand√© d‚Äôavoir une section au d√©but de votre script qui charge tous les paquets dont vous aurez besoin dans votre script en un seul endroit :\n\n# Packages ----------------------------\nlibrary(tidyverse)   # manipulation de donn√©es\nlibrary(lubridate)   # manipulation des dates\n\nCel√† permet de savoir rapidement quels paquets doivent √™tre install√©s pour ex√©cuter un script.\n\n\n\nCr√©ez une section ‚ÄúPaquets‚Äù dans votre script √† l‚Äôaide de commentaires\n\n\n\nMettre √† jour les paquets\nR dispose d‚Äôune communaut√© de d√©veloppeurs tr√®s active et il est assez courant que les paquets soient mis √† jour, avec de nouvelles fonctionalit√©s ou des corrections de bugs. Pour mettre √† jour les paquets de votre biblioth√®que, rendez-vous dans l‚Äôonglet Packages du panneau inf√©rieur droit et cliquez sur Update. N‚Äôoubliez pas que vous devez √™tre connect√© √† internet pendant ce processus.\n\n\n\n\n\n\nImportant\n\n\n\nLa mise √† jour de certains paquets peut parfois changer le comportement de certaines fonctions, ce qui peut casser votre code. Pas de panique. La meilleure pratique consiste √† adapter votre code mais, dans le pire des cas, vous pouvez installer une ancienne version du paquet incrimin√©."
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html#importation-de-donn√©es",
    "href": "sessions_core/02_import_data.fr.html#importation-de-donn√©es",
    "title": "Importer des donn√©es",
    "section": "Importation de donn√©es",
    "text": "Importation de donn√©es\n\nTrouver son chemin‚Ä¶\nPour ouvrir un fichier dans R, vous devez fournir un chemin d‚Äôacc√®s au fichier. Un chemin d‚Äôacc√®s est simplement un (long) nom pour un fichier qui inclut son emplacement sur votre ordinateur. Les chemins d‚Äôacc√®s peuvent √™tre absolus ou relatifs.\n\nChemins d‚Äôacc√®s absolus\nLes chemins d‚Äôacc√®s absolus sont sp√©cifiques √† votre ordinateur et vont jusqu‚Äôau niveau de votre disque dur. Par exemple : D:/OneDrive - MSF/Documents/monitoring/cholera/fancy_project/data/raw/example_linelist.xlsx. Il est clair que ce chemin ne fonctionne que sur un ordinateur particulier.\nL‚Äôutilisation de chemins absolus encod√©s en dur est fortement d√©conseill√© car cela rend votre code fragile et augmente la maintenance : en effet, les chemins devront tous √™tre mis √† jour chaque fois quelqu‚Äôun d‚Äôautre ex√©cute votre code, ou que le dossier du projet est d√©plac√© sur votre ordinateur.\n\n\nChemins d‚Äôacc√®s relatifs\nLes chemins relatifs sont d√©finis par rapport √† votre r√©pertoire de travail. Comme l‚Äôemplacement du fichier .Rproj d√©finit le r√©pertoire de travail, les chemins sont relatifs √† cette racine. Pour vous, un chemin relatif ressemblera √† √ßa : data/raw/example_linelist.xlsx.\nCela signifie que tant que la structure interne du dossier contenant votre projet est pr√©serv√©e, le chemin d‚Äôacc√®s relatif sera valable quelque soit l‚Äôordinateur.\n\n\nChemins d‚Äôacc√®s robustes avec la fonction here()\nLe paquet {here} dispose d‚Äôune fonction here() qui aide √† cr√©er des chemins d‚Äôacc√®s. Elle pr√©sente deux avantages :\n\nElle d√©tecte la pr√©sence d‚Äôun fichier .Rproj et est capable de construire un chemin absolu √† partir d‚Äôun chemin relatif dans votre projet RStudio.\nElle choisit automatiquement le s√©parateur adapt√© √† votre syst√®me d‚Äôexploitation : /, \\ ou //.\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"/home/catherine/Documents/epicentre/training/repicentre/data/raw/example_linelist.xlsx\"\n\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"/home/catherine/Documents/epicentre/training/repicentre/data/raw/example_linelist.xlsx\"\n\n\nVoyez comme nous n‚Äôavons d√©fini que le chemin relatif et la fonction a reconstitu√© le chemin absolu. Cel√† marchera donc sur l‚Äôordinateur d‚Äôun coll√®gue, y compris sur un autre syst√®me d‚Äôexploitation, du moment que la structure du r√©pertoire de travail est intacte.\nNous vous encourageons fortement √† utiliser here() chaque fois que vous devez cr√©er un chemin d‚Äôacc√®s √† un fichier.\n\nEx√©cutez le code ci-dessus dans la console. Quel chemin d‚Äôacc√®s here(\"data\", \"raw\") vous donne-t-il ?\n\n\nUtilisez here() pour cr√©er le chemin vers le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx.\n\n\n\n\n\n\n\nImportant\n\n\n\nhere() cr√©e une cha√Æne de caract√®res contenant l‚Äôadresse d‚Äôun fichier, mais ne v√©rifie pas si ce fichier existe r√©ellement sur votre ordinateur. Si le fichier est absent ou s‚Äôil y a une faute de frappe dans votre code, vous obtiendrez une erreur lors de l‚Äôutilisation du chemin ainsi cr√©√©. Vous pouvez tester si un fichier existe √† cette adresse avec la fonction file.exists().\n\n\n\n\n\n\n\n\nTip\n\n\n\nOn veut souvent d√©finir plusieurs chemins dans un projet (donn√©es brutes, donn√©es propres, o√π sauver les graphes etc.). C‚Äôest une bonne pratique que de cr√©er une nouvelle section au d√©but de votre script, apr√®s le chargement des paquets, pour d√©finir et stocker les chemins d‚Äôacc√®s dans des objets.\n\n\n\n\n\nImporter les donn√©es\nDans R, diff√©rents formats de fichiers sont import√©s par diff√©rentes fonctions sp√©cialis√©es, ce qui est fastidieux √† m√©moriser et √† charger. La fonction import() du paquet {rio} nous fait gagner du temps en reconnaissant l‚Äôextension des fichier et en appelent automatiquement une fonction sp√©cialis√©e pour charger les donn√©es.\nComme import() ne fait qu‚Äôappeler d‚Äôautres fonctions en arri√®re-plan, il est possible qu‚Äôelle ait besoin d‚Äôarguments optionnels sp√©cifiques pour certains types de fichier.\n\n\n\n\n\n\nTip\n\n\n\nLa (longue) liste des types de fichiers pris en charge par {rio} est sur le site du paquet. Dans la suite de la le√ßon, nous nous concentrerons sur l‚Äôimportation de donn√©es √† partir de fichiers Excel .xlsx.\n\n\n\nImport de la premi√®re feuille\nAu minimum la fonction import() a besoin qu‚Äôon lui donne le chemin du fichier avec l‚Äôargument file :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"))\n\nNotez que nous avons imbriqu√© la commande here() √† l‚Äôint√©rieur de la commande import(). L‚Äôimbrication de fonctions est autoris√©e et m√™me courrante en R. R √©value les fonctions imbriqu√©es de l‚Äôint√©rieur (here()) √† l‚Äôext√©rieur (import()). La valeur renvoy√©e par here() est donc utilis√©e comme valeur d‚Äôentr√©e d‚Äôimport().\n\nImportez le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx en utilisant here() et import().\n\nSi votre importation a fonctionn√© correctement, R affichera les donn√©es dans la console mais ne les enregistrera pas dans l‚Äôenvironnement car nous ne les avons pas assign√©es √† un objet.\n\nR√©importez vos donn√©es, mais cette fois-ci, sauvegardez-les dans un objet appel√© df_linelist.\n\n\n\n\n\n\n\nTip\n\n\n\nSi votre jeu de donn√©es est tr√®s gros, il vaut mieux √©viter de l‚Äôafficher dans la console‚Ä¶\n\n\n\n\nImport d‚Äôune autre feuille\nComme vous venez de le voir, la fonction import() importe la premi√®re feuille d‚Äôun fichier Excel par d√©faut. Il est cependant possible de passer le num√©ro de la feuille ou son nom (en cha√Æne de caract√®res) √† l‚Äôargument which :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"),  # chemin\n       which = 2)                                            # sp√©cifie la deuxi√®me feuille\n\nNotez que l‚Äôargument which est sp√©cifique aux types de fichiers comportant plusieurs feuilles, tels que les fichiers Excel ou .Rdata. Si vous essayez de l‚Äôutiliser sur un fichier .csv l‚Äôargument sera ignor√©."
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html#aper√ßu-des-donn√©es",
    "href": "sessions_core/02_import_data.fr.html#aper√ßu-des-donn√©es",
    "title": "Importer des donn√©es",
    "section": "Aper√ßu des donn√©es",
    "text": "Aper√ßu des donn√©es\nNous avons import√© un jeu de donn√©es dans R et l‚Äôavons assign√© √† un objet (df_linelist). Nous pouvons maintenant inspecter le data frame cr√©√© pour v√©rifier que l‚Äôexport s‚Äôest bien pass√©, et commencer √† √©valuer le nettoyage √† faire.\nNous pouvons commencer par jeter un coup d‚Äô≈ìil rapide aux premi√®res lignes du data frame √† l‚Äôaide de la fonction head(). Son premier argument est le data frame √† inspecter et le second, n, accepte un nombre de lignes √† afficher (optionnel).\n\nhead(df_linelist, n = 10) # Affiche les 10 premi√®res lignes\n\n\nUtilisez head() pour examiner les 12 premi√®res lignes de df_linelist.\n\nNous pouvons inspecter la structure du data frame √† partir de l‚Äôonglet Environnement dans le panneau sup√©rieur droit. Nous pouvons √©galement visualiser le data frame dans le le visualiseur de donn√©es de RStudio (en haut √† gauche).\n\nCliquez sur le bouton rond bleu √† c√¥t√© de df_linelist dans votre environnement pour examiner sa structure. Cliquez ensuite sur le nom du data frame pour le visualiser.\n\nLe visualiseur permet d‚Äôafficher le data frame comme dans un tableur et est un moyen pratique d‚Äôexaminer rapidement vos donn√©es. Vous pouvez trier et filtrer vos donn√©es dans cet onglet mais ces actions ne modifieront pas l‚Äôobjet df_linelist. Le visualiseur peut √©galement √™tre ouvert en utilisant directement la fonction View() sur le data frame."
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html#cest-fini",
    "href": "sessions_core/02_import_data.fr.html#cest-fini",
    "title": "Importer des donn√©es",
    "section": "C‚Äôest fini !",
    "text": "C‚Äôest fini !\nBravo et n‚Äôoubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/02_import_data.fr.html#pour-aller-plus-loin",
    "href": "sessions_core/02_import_data.fr.html#pour-aller-plus-loin",
    "title": "Importer des donn√©es",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices suppl√©mentaires\n\nUtilisez dim() pour examiner les dimensions de votre data frame.\nUtilisez str() pour v√©rifier le type de donn√©es de chaque colonne. Voyez-vous quelque chose d‚Äô√©trange ? N‚Äôoubliez pas que vous pouvez √©galement utiliser des fonctions telles que is.character() et is.numeric() si vous souhaitez tester le type d‚Äôune colonne particuli√®re.\nEn utilisant une fonction apprise lors de la premi√®re session, pouvez-vous extraire les noms des colonnes du data frame ? Ces r√©sultats correspondent-ils √† ce que vous voyez lorsque vous ouvrez les donn√©es dans Excel ?\nEssayez d‚Äôex√©cuter la fonction summary() sur votre data frame. Qu‚Äôest ce que le r√©sultat vous apprend sur les variables ?\n\n\n\nRessources compl√©mentaires\n\nLe site web de {rio}\nPlus d‚Äôexemples sur l‚Äôimportation de donn√©es de diff√©rents types de fichiers"
  },
  {
    "objectID": "sessions_core/01_introduction.html",
    "href": "sessions_core/01_introduction.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Familiarize yourself with RStudio\nLearn how to work with the console\nCreate and execute a script\nCreate basic R objects, including vectors and data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#objectives",
    "href": "sessions_core/01_introduction.html#objectives",
    "title": "Introduction to R",
    "section": "",
    "text": "Familiarize yourself with RStudio\nLearn how to work with the console\nCreate and execute a script\nCreate basic R objects, including vectors and data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#exercise-format",
    "href": "sessions_core/01_introduction.html#exercise-format",
    "title": "Introduction to R",
    "section": "Exercise Format",
    "text": "Exercise Format\nThese exercises are in the format of a self-paced tutorial containing short explanations of key concepts, examples, and exercises for you to follow. The course uses a ‚Äúlearning by doing‚Äù approach, and while this first session will start with a lot of time exploring the RStudio interface, future sessions will focus heavily on having you write your own code.\nInstructions for exercises will be given in the following formats:\n\nThis is a general action block. You will typically see it at the beginning of a session with instructions about the setup for that lesson.\n Example: Open a blank new script and name it my_first_script.R.\n\n\nThis is a code block, it indicates a coding exercise where you will actually write your own code.\n Example: Create an object called region that contains the value \"Mandoul\".\n\n\nThis is an observation block, it will have instructions about something that you are expected to look at or investigate.\n Example: Inspect the RStudio interface.\n\nAs you move through these exercises, you may run into some errors, which occur when R is unable to complete a command. This can happen for many reasons: maybe you misspelled the name of an object, asked R to look for a file that doesn‚Äôt exist, or provided the wrong type of data to a function. Whenever an error occurs, R will stop any ongoing calculation and give you a message explaining what went wrong. Having errors is completely normal and happens to all programmers, novice and expert. Much like a natural language, R is something you will get better at the more you practice and work through your mistakes."
  },
  {
    "objectID": "sessions_core/01_introduction.html#rstudio-and-r",
    "href": "sessions_core/01_introduction.html#rstudio-and-r",
    "title": "Introduction to R",
    "section": "RStudio and R",
    "text": "RStudio and R\nR is a functional programming language that can be used to clean and manipulate data, run analyses (especially statistical ones), visualize results, and much more.\nRStudio is a piece of software that provides a user-friendly interface for R (also called an IDE, for Integrated Development Environment). While using a graphical interface isn‚Äôt required, it is strongly recommended for beginners.\n\nGetting Started with RStudio\nLet‚Äôs get started!\n\nOpen RStudio using the start menu or desktop shortcut; if RStudio is already open, please close it and open it again.\n\nYou should see an interface that looks something like this:\n\n\n\nView of the Rstudio IDE interface at opening\n\n\n\nInspect the RStudio interface.\n\nYou will have either three or four panels, including:\n\nUpper Right Corner\nTo the upper right there will be a panel with several tabs. Many of these are beyond the scope of this course, but we will use the following two tabs during the course:\n\nEnvironment. A list of the objects saved by the user in the current session. Because you‚Äôve just started a new session, your environment should be empty.\nHistory. A record of all the commands you have executed during the current session.\n\n\n\n\n\n\n\nNote\n\n\n\nYou can think of an R session like you would think of starting up a computer. Whenever a session starts, everything is blank and ready for computation in the same way that there aren‚Äôt any programs open when you first turn on your computer. In general, we encourage you to stop and start your R sessions regularly, you may just find that turning it off an on again will fix some of your bugs.\n\n\n\n\nBottom Right Corner\nTo the bottom right there will be another multi tab panel, including:\n\nFiles. A file explorer for the working directory, which is the folder location where R is currently working.\nPlots. A location where RStudio will display static visualizations; this tab should be empty for the moment.\nPackages. A list of all the R packages installed on your computer. Packages are collections of functions that help extend the functionality of R, and we will discuss them in greater detail in the next lesson.\nHelp. A place to read help pages and documentation for functions and packages.\nViewer. A location where RStudio will display html outputs such as tables, interactive widgets, or even full on dashboards.\n\n\n\nLeft Side\n\nTo the left (or bottom left if you have four panels) you should see the console, where R itself is run.\nTo the top left (if you have four panels) will be any open scripts.\n\nIn the next two sections, let‚Äôs talk about the console and scripts in more detail.\n\n\n\nThe Console\nThe console is where R itself is run.\nWhenever you open a new session, R will start by printing a bit of information about your set up, such as your R version number. Below this there should be a line containing the &gt; symbol and a blinking cursor. To run a command in R, you simply need to type it in after this &gt; and press Enter. R will then process your code and print the result (if there is one). A new &gt; line will then appear ready for the next command.\n\n\n\n\n\n\nImportant\n\n\n\nIf the last line shown in the console starts with a + instead of a &gt; that means the console is not ready for a new command either because it is still processing a previous one or because it received a bit of incomplete code. If at any point you would like to cancel an ongoing or incomplete command, press Esc.\n\n\n\nRun the following commands in the console one line at a time and observe the output.\n\n5 + 90\n\n6 * 171\n\n189 / 36.6\n\n92^3\n\n(12 + 9)^4 / 1000\n\nNow, run the following command. Note that the final ) is missing, making the command incomplete. What happens when you do this?\n\n3 / (2 + 97\n\n\nYou may have noticed in the above examples that our code includes a lot of spaces between characters. This is not by accident. It is considered best practice to include spaces around most operators, such as +, -, *, /, &lt;, &gt;, =, and &lt;-. Not only do these spaces make your code easier for other people to read and understand, in some (rare) cases they may even be necessary to avoid errors. That said, do be aware that there are a small number of operators that should not be surrounded by spaces, such as ^, . and :.\n\n1+29+4.8/3*3           # BAD\n1 + 29 + 4.8 / 3 * 3   # GOOD\n\n1 ^ 2 # BAD\n1^2   # GOOD\n\nWe can also run functions in the console. We will discuss functions in more depth later in this lesson, but meanwhile know that the idea of functions in R is very similar to the one in Excel, where you no doubt are familiar with functions such as SUM or MEAN.\n\nRun the following commands in the console (one line at a time).\n\n# Find the minimum value\nmin(5, 10)\nmin(1, 8, 56, 0.3)\n\n# Find the maximum value\nmax(568, 258, 314)\n\n\n\n\nScripts\nScripts are text files that contain a series of commands for a particular programming language. The extension of the file indicates which language the commands were written in, and we will be using .R. Scripts allow us to create code that can be reused, shared, and even automated.\n\nWriting Your First Script\n\n\n\nSteps to create a new script in the RStudio IDE\n\n\nTo create a new script, follow the menu File &gt; New File &gt; R Script. Alternatively, you can click on the small green + sign just below the File menu or use the keyboard shortcut CTRL+SHIFT+N. This new and unsaved script will appear as a blank document in the top left panel.\nTo save your script, either use the menu File &gt; Save As or the keyboard shortcut CTRL+S.\n\nCreate and save a new script called discovery.R. Don‚Äôt forget to include the .R extension. For now, you can save it on your Desktop or any convenient location, but we will talk more about organizing your scripts in the next session.\n\n\n\nExecuting Code from a Script\nTo run code from a script simply place your cursor on the line you wish to run (or select multiple lines) and do one of the following:\n\nClick the Run icon at the top right of the script panel\nUse the shortcut CTRL+Enter (cursor will move to the next line afterwards)\nUse the shortcut ALT+Enter (cursor will stay on the current line afterwards)\n\n\nCopy the code you ran in the previous exercises into your script and run it using each of the above methods.\nFrom now on, you will write your code in your script and execute it from there, unless told otherwise in the instructions.\n\n\n\nComments\nIn R, any text prefaced by a # (until the end of a line) is called a comment. R does not consider comments to be code and will ignore them whenever you run your scripts. This makes comments an excellent way to document your code.\n\n# This is a comment\n\n2 + 3  # This is also a comment\n\nIt is helpful to future you and others to start your scripts with a few commented lines providing some information about the file.\n\n#### IMPORT & PREPARE DATA ####\n# Author :  Mathilde Mousset\n# Creation Date : 23/11/2024\n# Last Update : 30/11/2024\n# Description : Import and clean measles surveillance data from Moissala\n\n\nAdd some comments to the top of your script describing it.\n\nComments are also a handy way to split longer scripts into thematic sections, such as ‚ÄúData Importation‚Äù, ‚ÄúAnalysis‚Äù, ‚ÄúVisualization‚Äù, etc. For example:\n\n# NAME OF SECTION 1 -----------------------------------------------             \n\n# NAME OF SECTION 2 -----------------------------------------------             \n\n\nUse comments to create sections in your script that correspond to the main sections in this tutorial.\n\nFinally, comments allow us write helpful notes for our colleagues (and our future selves) that can help them understand the code and why we wrote it the way we did. The general guidance is to focus on comments that explain the ‚Äúwhy‚Äù rather than the ‚Äúwhat‚Äù. This is because the ‚Äúwhat‚Äù of well written code should be relatively self explanatory.\nThis comment, for example, is completely superfluous:\n\n1 + 3  # Code to add one to three\n\nBy comparison, here are a few use cases that would warrant comments:\n\nYou define a constant, say a seroprevalence threshold value. You may want to add a comment providing the reference for where the value comes from.\nYour code contains a value or file name that needs to be updated every week. You should indicate this with a comment to ensure that anyone else using the code is aware.\nYou use a rare command or package that your colleague may not know or may find counter intuitive. You can use a comment to explain the rational behind that decision.\n\nThat being said, you are learning, and the scripts you are writing during this course are your notes, so feel free to us as many comments (of the ‚Äúwhat‚Äù and ‚Äúwhy‚Äù sort) as you need. You will naturally write less comments in the future, when some of the things that seem alien now become natural.\n\n\n\n\n\n\nTip\n\n\n\nYou can comment a selected line with the shortcut CTRL+SHIFT+C.\nYou can add a first level section with CTRL+SHIFT+R.\n\n\n\nAdd some comments to describe the code that you‚Äôve written thus far in your script."
  },
  {
    "objectID": "sessions_core/01_introduction.html#data-types",
    "href": "sessions_core/01_introduction.html#data-types",
    "title": "Introduction to R",
    "section": "Data Types",
    "text": "Data Types\nR has several different data types. The ones we will see most often in this course include:\n\nnumeric\nstring (text)\nboolean (TRUE / FALSE)\ndate\nfactor\n\n\nNumerics\nThe numeric type includes both integers and doubles (numbers that include a decimal) and can be created by simply writing the ‚Äúnaked‚Äù value into your script or console.\n\n\nStrings\nStrings are the R version of text and can be created by surrounding text with single or double quotation marks, for example \"district\" or 'cases' (double quotations are typically considered best practice).\n\nCompare the output in the console for the following commands:\n\n28         # numeric\n\"28\"       # text\n28 + \"28\"  # produces an error\n\n\nThe last command above will give an error because we cannot perform arithmetic operations that combine text and numbers.\n\n\n\n\n\n\nImportant\n\n\n\nR is case sensitive, meaning that the string \"ABC\" is not the same as \"abc\".\n\n\n\nIf you would like to create a string that contains a quotation mark the best practice is to escape the character by putting a \\ in front of it, ie: \"She said \\\"Hello\\\" then left\" or 'it\\'s a beautiful day'. Equivalently, if you used a double quotation to create the string you can use single quotes inside of it freely (ie: \"it's a beautiful day\") and vice versa (i.e.: 'She said \"Hello\" then left').\n\n\n\nBoolean (Logical)\nThe boolean (or ‚Äúlogical‚Äù) type stores true/false values and is created by writing either TRUE or FALSE without quotation marks.\nInternally, R thinks of TRUE and FALSE as being a special version of 1 and 0 respectively, and boolean values can be easily translated to these numeric equivalents for arithmetic operations.\n\n\n\n\n\n\nNote\n\n\n\nYou may find people using T or F but this is discouraged as T and F can also be used as object or variable names. TRUE and FALSE, however, are protected in R, meaning they cannot be reassigned to another value.\n\n\n\n\nDetermining the Type of an Object\nThere are several functions to determine the type of an object (often called the class of the object in R).\n\nType the following commands in your script and run them:\n\n# Get the Type of an Object\nclass(28)  \nclass(\"Mandoul\")\n\n# Test the Type of an Object\nis.numeric(28)\nis.numeric(\"Mandoul\")\nis.character(\"Mandoul\")\n\nis.numeric(TRUE)\nis.character(TRUE)\nis.logical(FALSE)"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-assignement-operator",
    "href": "sessions_core/01_introduction.html#sec-assignement-operator",
    "title": "Introduction to R",
    "section": "Creating an Object",
    "text": "Creating an Object\nIn R, pretty much everything is an object, including functions, scalar values, and other more complex data structures. Before introducing these structures, let‚Äôs take an important detour to discuss how objects are saved into your environment.\nOften, we will want to reuse the same values or data throughout a script and it is therefore very useful to store them as objects in our environment. To do this we use the assignment operator, &lt;-.\n\nLook at the environment panel on the top right, verifying that it is empty, then type the following command in your script and run it to save a variable called cases into your environment.\n\ncases &lt;- 28\n\nLook at the environment again. Is it still empty?\n\nIf you‚Äôd like to access the value of your new object, cases, you simply need to execute its name.\n\ncases\n\n[1] 28\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe reason we need to wrap strings in quotation marks is actually to allow R to differentiate between strings (\"cases\" and object names cases).\n\n\nOnce created, objects can be used in other commands:\n\ncases + 5\n\n[1] 33\n\n\n\nFrom your script, create an object called region that contains the value \"Mandoul\". Do you see it in your environment?\n\n\n\n\n\n\n\nTip\n\n\n\nDon‚Äôt forget that we should always surround &lt;- with spaces to improve readability and avoid errors.\n\nx&lt;-3     # BAD\nx &lt;- 3   # GOOD\n\n\n\n\nUpdating an Object\nWe often want to update the value stored in an object. To do this, we simply assign a new value with the same syntax we used to create it in the first place:\n\ncases &lt;- 32\n\n\nUpdate the value of region to \"Moyen Chari\".\n\n\n\nObject Names\nWhen naming your objects, there are a few (relatively) hard rules:\n\nDon‚Äôt start with a number\nDon‚Äôt use spaces (use a _ instead)\nDon‚Äôt use protected values (like TRUE and FALSE) or function names (like mean)\nDon‚Äôt use capital letters\n\nBeyond these hard rules, there are also more subjective best practices and personal styles. In general aim for names that are short and descriptive:\n\na &lt;- 19                             # BAD (not informative)\nage_du_patient_a_l_admission &lt;- 19  # BAD (too long)\nage &lt;- 19                           # GOOD\n\nGiving your objects clear and informative names helps to make your code readable, making it easy for others to understand without the need for checking the data dictionary every two seconds."
  },
  {
    "objectID": "sessions_core/01_introduction.html#data-structures",
    "href": "sessions_core/01_introduction.html#data-structures",
    "title": "Introduction to R",
    "section": "Data Structures",
    "text": "Data Structures\nUp until now we have looked only at simple objects that store single values, let‚Äôs now turn our focus to more complex structures that can store entire datasets.\n\nVectors\nWe can collect multiple values (such as numerics or strings) into a single object, called a vector.\nTechnically, there are several types of vectors, for example:\n\nSimple vectors (or atomic vectors) can only contain one type of values. For example, a numeric vector 2, 4, 6 or a string vector \"Mandoul\", \"Moyen Chari\".\nRecursive vectors (usually called lists) are far more complex and can contain multiple dimensions and types of data. We will not learn about them in this lesson.\n\nThis course will not go into detail on the more abstract concepts behind these structures and instead focus only on those you will encounter most often in your daily work.\n\nSimple Vectors\nSimple vectors can contain one or more values of a single data type, they thus have two key properties: length and type. For the purpose of this class, we will use the terms ‚Äúsimple vector‚Äù and ‚Äúvector‚Äù interchangeably (as is typical in the R community).\nYou‚Äôve technically already created your first simple vector when you built cases and region. These were simply vectors with a length of one. To create a vector with more than one value, we will use the function c() (mnemonic):\n\ncases &lt;- c(2, 5, 8, 0, 4)\n\n\nUpdate cases with the above values and update region to create a string vector containing the values: Mandoul, Moyen-Chari, Logone Oriental, Tibesti, and Logone Occidental.\n\nWe can now use functions on the objects we have created:\n\nmean(cases)      # calculate the mean value of the cases vector\n\n[1] 3.8\n\ntoupper(region)  # convert all the values in region to upper case\n\n[1] \"MANDOUL\"           \"MOYEN-CHARI\"       \"LOGONE ORIENTAL\"  \n[4] \"TIBESTI\"           \"LOGONE OCCIDENTAL\"\n\n\n\nLet‚Äôs use some functions! Try to write code that does the following:\n\nCalculate the sum of cases using the function sum()\nConvert the text in region to lowercase using the function tolower()\n\n\n\n\n\nAccessing the Values of a Vector\nIt is possible to access the value of a vector using square brackets containing the index (position) of the desired value, ie: [3] or [189].\n\ncases[2]   # 2nd value of cases\n\n[1] 5\n\ncases[10]  # 10th value of cases\n\n[1] NA\n\n\nOoops it does not exist! We will come back to what this NA means in the Missing Values section.\nWe can also access a range of values, just as we might do in Excel. To create a range we use the : operator to separate the desired minimum and maximum index:\n\ncases[2:4]  # 2nd to 4th values of cases\n\n[1] 5 8 0\n\n\n\nGet the 3rd value of region.\nWrite code to access the values ‚ÄúMandoul‚Äù and ‚ÄúMoyen-Chari‚Äù in the vector region.\n\n\n\nData frames\nData frames are tabular structures / 2D tables with rows and columns. It is very similar to a ‚Äútable‚Äù structure in Excel. As epidemiologists, this type of data structure is perhaps the most useful and you will likely use them on a daily basis, to store linelist data for example.\n\nCreating a data frame\nWe can create a data frame using the function data.frame():\n\ndata.frame(col1 = c(1, 4, 2, 9),\n           col2 = c(\"a bit of text\", \"some more text\", \"hello\", \"epidemiologists!\"))\n\n  col1             col2\n1    1    a bit of text\n2    4   some more text\n3    2            hello\n4    9 epidemiologists!\n\n\nSee how col1 was created from a numeric vector, and col2 from a vector of strings. Here we chose the names of the columns (col1 and col2), which is the normal way, but you can run the code without to see how R handles names by default.\n\nIn your script, create a data frame called data_cases that contains cases in one column and region in the other.\n\n\n\nExploring a data frame\ndata_cases should now appear in your environment. You can click on the blue circle with a white triangle in to see some additional information, or click on its name to open the object in the same pane as the scripts to view it.\n\n\n\nThe data_case data frame now appears in the Environment pane\n\n\nThere are several handy functions we can use to explore a data frame:\n\nRun the following commands and try to determine what type of information they are returning.\n\nstr(data_cases)     # STRucture of the object\ndim(data_cases)     # DIMension of the object\nnrow(data_cases)    # Number of ROWs\nncol(data_cases)    # Number of COLumns\nnames(data_cases)   # column NAMES\n\n\nLet‚Äôs practice a bit more! R comes with several built in data sets that can be accessed directly, including one called iris. It is convenient today as we have not learned to import data in R yet (don‚Äôt worry, we will work on linelist data from the second session then onwards).\nWe can see the first few lines of this data frame using the function head():\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nHow many rows and columns are there in iris? What are the names of its columns?\n\n\n\nAccessing Data in a data frame\nIn R, there are several methods for accessing the rows and/or columns of a data frame. In this introductory session we will focus on the [ ] syntax.\nWe use square brackets to access single values or ranges within our data frame. To do this we must give R both a row number (or range of rows) and column number/name (or range of columns), using the syntax [row, column].\n\ndata_cases[1, 2]          # the value of row one, column 2\n\n[1] \"Mandoul\"\n\ndata_cases[1, \"region\"]   # first value in the region column\n\n[1] \"Mandoul\"\n\n\nIf we want to access all of the rows (or columns) we can simple leave a space in the place of the number/name:\n\ndata_cases[1, ]           # values of all columns in row one\n\n  cases  region\n1     2 Mandoul\n\ndata_cases[2:4, ]         # values of all columns for rows 2 through 4\n\n  cases         region\n2     5       Sud Kivu\n3     8 Kasai oriental\n4     0          Kasai\n\ndata_cases[ , \"region\"]   # values of all rows for the region column\n\n[1] \"Mandoul\"        \"Sud Kivu\"       \"Kasai oriental\" \"Kasai\"         \n[5] \"Haut Katanga\"  \n\n\nWe can even select multiple non-consecutive indices by using a numeric vector:\n\ndata_cases[c(1, 3), ]  # lines 1 and 3 (all columns)\n\n  cases         region\n1     2        Mandoul\n3     8 Kasai oriental\n\n\nDo be careful, as the type of output returned when extracting data from a data frame can sometimes depend on the style of indexing used:\n\nstr(data_cases[1 , ])   # returns a data frame\n\n'data.frame':   1 obs. of  2 variables:\n $ cases : num 2\n $ region: chr \"Mandoul\"\n\nstr(data_cases[ , 1])   # returns a simple vector\n\n num [1:5] 2 5 8 0 4\n\n\nAnother syntaxt to extract the various columns of a data frame:\n\ndata_cases[2]           # returns the second column (as a data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\ndata_cases[\"region\"]    # returns the region column (as a data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\n\nNotice that these commands returned single-column data frames.\n\nWrite some code to:\n\nextract the third value in the region column of your data frame\n\nextract the second and third values of the cases column\n\ncalculate the sum of the cases column of your data frame"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-missing-values",
    "href": "sessions_core/01_introduction.html#sec-missing-values",
    "title": "Introduction to R",
    "section": "Missing Values",
    "text": "Missing Values\nAs epidemiologists, we work with missing data all the time. In R, missing values are coded using a special value: NA (meaning Not Available). NA is somewhat unique in R as it doesn‚Äôt per se have a fixed type, rather, it will take on the type of the values around it. For example, an NA in a numeric column will then take on the numeric type. We will discuss the idea of missing data in more depth in later sessions of the course."
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-functions",
    "href": "sessions_core/01_introduction.html#sec-functions",
    "title": "Introduction to R",
    "section": "Functions",
    "text": "Functions\nFunctions are objects that contain commands (instead of values) that are run whenever the function is called. You are without doubt familiar with functions in Excel such as SUM or MEAN and the idea of functions in R is exactly the same.\nMost functions require some sort of input, such as a dataset or parameter. These inputs are called arguments and are normally named. For example, when we ran sum(cases), we provided the vector cases as the first (and only) argument to the function sum().\nOften, a function will have a combination of both required and optional arguments. The first argument of a function is almost always required and is typically a dataset. As an obligatory and rather obvious argument, most people omit its name when calling a function; ie: i.e.¬†people will write mean(cases) instead of mean(x = cases). Optional arguments on the other hand are usually added using their name, i.e.: mean(x = cases, na.rm = TRUE).\nOptional arguments typically have default values and we only include them when we want to change their defaults (and thus change the default behavior of the function). For example, the na.rm argument of mean() determines whether R will ignore missing values when calculating a mean. The default state of the na.rm argument is FALSE, so by default, the mean performed on data with missing values will always return NA as the result:\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nThis is true for many arithmetic operations in R. If we want R to calculate the mean on whatever data is available (and ignore the missing values) we need to explicitly set na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nTip\n\n\n\nNotice that arguments are separated by commas. These commas should always be followed by a space and whenever a named argument is used the = should be surrounded by spaces:\n\nmean(cases,na.rm=TRUE)     # BAD\nmean(cases, na.rm = TRUE)  # GOOD\n\nAs you work with increasingly complex functions, you may start to have a lot of arguments. For readability, it is typically recommended to split each argument onto its own line:\n\nmean(cases, \n     na.rm = TRUE) \n\n\n\nWhat happens if we put the arguments in the wrong order? If you provided the name of the arguments in you command, the function will still work exactly as expected. That being said, doing this would make your code harder to read and we encourage you to stick with a standard order of putting obligatory arguments like data first.\n\n# technically functional but hard to read:\nmean(na.rm = TRUE,  \n     x = cases) \n\n# better:\nmean(cases,         \n     na.rm = TRUE)\n\nOf course, if you mess up the ordering of arguments and didn‚Äôt include their names your code will not work as expected, or even throw an error:\n\nmean(TRUE, cases)   # not what you expect"
  },
  {
    "objectID": "sessions_core/01_introduction.html#done",
    "href": "sessions_core/01_introduction.html#done",
    "title": "Introduction to R",
    "section": "Done!",
    "text": "Done!\nThat‚Äôs all for this session, congratulations on taking your first steps with R and RStudio!\n\n\n\n Solutions file"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html",
    "href": "sessions_core/04_data_verbs_conditional.html",
    "title": "Data Manipulation with Conditional Logic",
    "section": "",
    "text": "Understand basic conditional logic statements\nLearn how to filter a data frame using filter()\nLearn how to recode variables using case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#objectives",
    "href": "sessions_core/04_data_verbs_conditional.html#objectives",
    "title": "Data Manipulation with Conditional Logic",
    "section": "",
    "text": "Understand basic conditional logic statements\nLearn how to filter a data frame using filter()\nLearn how to recode variables using case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#setup",
    "href": "sessions_core/04_data_verbs_conditional.html#setup",
    "title": "Data Manipulation with Conditional Logic",
    "section": "Setup",
    "text": "Setup\nDependencies. This session assumes that you know the basics of data manipulation with {dplyr}. If you need a refresher on this, please review the third session in the learning pathway.\n\nThis session will work with the raw Moissala linelist data, which can be downloaded here:\n\n\n\n  Download Data\n\n\n\n Make sure this dataset is saved into the appropriate subdirectory of your R project and create a new script called filtering_and_recoding_practice.R in your R directory. Add an appropriate header and load the following packages: {here}, {rio}, and {tidyverse}.  Finally, add an import section where you use {here} and {rio} to load your data into an object called df_raw."
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#using-conditional-logic-to-filter-data",
    "href": "sessions_core/04_data_verbs_conditional.html#using-conditional-logic-to-filter-data",
    "title": "Data Manipulation with Conditional Logic",
    "section": "Using Conditional Logic to Filter Data",
    "text": "Using Conditional Logic to Filter Data\nIn the last session we learned a lot of the core data verbs in {dplyr} for basic manipulation tasks like selecting particular variables of interest and modifying them to better suit our needs. Beyond selecting variables of interest, another common task we have as epidemiologists is selecting observations of interest; ie: filtering our data to look at particular observations that meet a certain criteria.\nFortunately, {dplyr} has our back with the conveniently named function, filter(). To understand how to use it, however, we will need to learn a bit about how to construct conditional logic statements in R. This will be the focus of our session today.\n\nThis Equals That\nThe basic syntax of filter() is pretty simple:\n\n# DO NOT RUN (PSEUDO-CODE)\ndf_raw |&gt;\n  filter([conditional logic statement])\n\nBut what is a conditional logic statement? These are statements that ask ‚ÄúIs this thing true?‚Äù. The simplest conditional logic statement asks ‚Äúdoes this variable equal this value?‚Äù. For example, ‚Äúwas this patient hospitalized?‚Äù. In R, we can ask if one value equals another using ==.\nTo create a filter asking, for each observation, whether the value of hospitalization is equal to yes we can then use the following syntax:\n\ndf_raw |&gt;\n  filter(hospitalisation == 'yes')\n\nWhat filter() is doing here is going down each row of our dataset and asking: ‚Äúfor this row, is the value of hospitalisation equal to \"yes\"?‚Äù. It then returns only the rows where the answer to this question is TRUE.\n\nCreate a filter that selects all of the patients who had a fever, ie: where the value of fever was \"Yes\". The head of fever should look like this:\n\n\n  fever\n1   Yes\n2   Yes\n3   Yes\n4   Yes\n5   Yes\n6   Yes\n\n\nTake a look at your output and then take a look at the head of df_raw. Why does df_raw still contain patients who didn‚Äôt present with fever?\n\n\n\nThis Does Not Equal That\nChecking if something is the same is great, but a lot of the time we might have a more complex question in mind. For example, we might want to know how many patients didn‚Äôt recover, whether this was because they died or because they left against medical advice.\nIn this case, instead of writing == we will instead use !=. So, for example if we want to select all observations where patients didn‚Äôt recover we would write:\n\ndf |&gt;\n  filter(outcome != 'recovered')\n\n\nCreate a filter that selects patients who did not have a card confirmed vaccination status. The head of vacc_status should look like this:\n\n\n  vacc_status\n1          No\n2  Yes - oral\n3          No\n4          No\n5          No\n6          No\n\n\nHint. Remember that you can use count() to check what the options were for vacc_status.\n\n\n\nGreater Than / Less Than\nThe other common question we have is whether a value was greater or less than a particular threshold. For example, how many patients were under 5 years old? Here we will use &lt; and &gt; to evaluate whether a variable is less than or greater than a particular value, respectively.\nFor example, to ask how many patients were less than 60 months old we can write:\n\ndf_raw |&gt;\n  filter(age &lt; 60)\n\n\nCreate a filter that selects all patients with severe accute malnutrition (ie: patients with a MUAC less than 110). The head of muac should look like this:\n\n\n  muac\n1   80\n2   88\n3   60\n4   85\n5   86\n6   68\n\n\nNow create another filter that selects patients who are over 15 years old. The head of your age column should look like this:\n\n\n  age\n1 348\n2 348\n3 312\n4 432\n5 444\n6 324\n\n\n\nSometimes, instead of asking if something is less or greater than a particular value, we want to ask if it is less than or equal to that value. Easy, we just need to add an equal sign! We write &lt;= for ‚Äúless than or equal to‚Äù and &gt;= for ‚Äúgreater than or equal to‚Äù. Careful here, the = must come after &lt; or &gt;, not before.\nSo if we want to ask for how many patients were 10 years of age or younger, we can write:\n\ndf_raw |&gt;\n  filter(age &lt;= 120)\n\n\nCreate a filter that selects all patients with a normal nutrition status, ie: patients with a MUAC greater than or equal to 125. The head of muac should look like this:\n\n\n  muac\n1  244\n2  232\n3  210\n4  220\n5  152\n6  155\n\n\n\n\n\nFilters with Multiple Conditions\nWant to combine several logic statements in a single filter? Easy. We can create a filter with multiple conditions by simply separating each condition with a comma:\n\n# DO NOT RUN (PSEUDO-CODE)\ndf |&gt;\n  filter([condition 1],\n         [condition 2],\n         [condition 3])\n\nSo for example, let‚Äôs say we want to select all patients under five who were hospitalized. In this case we can write:\n\ndf_raw |&gt;\n  filter(age &lt; 60,\n         hospitalised = \"true\")\n\n\nCreate a filter that selects all patients with severe accute malnutrition who were hospitalized in the Koumra health facility. The head of id, sub_prefecture, hospitalisation, and muac should look like this:\n\n\n    id sub_prefecture hospitalisation muac\n1 8624         KOUMRA             yes  103\n2 8939         KOUMRA             yes   67\n3 9957         KOUMRA             yes   71\n\n\nHint. This filter has a condition on both hospitalisation status, sub_prefecture, and muac.\n\n\n\nSummary of Basic Logic Statements\nGood job working through a quick tour of logic statements in R! Here is a handy table to help you remember the main logic statements we have learned so far:\n\n\n\nStatement\nR\n\n\n\n\nIs A the same as B?\nA == B\n\n\nIs A not the same as B\nA != B\n\n\nIs A greater than B?\nA &gt; B\n\n\nIs A greater than or equal to B?\nA &gt;= B\n\n\nIs A less than B?\nA &lt; B\n\n\nIs A less than or equal to B?\nA &lt;= B"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#recoding-with-case_when",
    "href": "sessions_core/04_data_verbs_conditional.html#recoding-with-case_when",
    "title": "Data Manipulation with Conditional Logic",
    "section": "Recoding with {case_when}",
    "text": "Recoding with {case_when}\nAs we have seen, conditional logic statements are increadibly useful when trying to filter our data, but you will find that they have many other uses as well. One of their other major use cases for us as epidemiologists is when we need to [recode our data]{.hovertip bs-toggle=‚Äòtooltip‚Äô bs-title=‚ÄúRecoding is the process of either standardizing the values of variable (such as making sure‚Äùf‚Äù and ‚Äúfemale‚Äù are both coded as ‚ÄúF‚Äù) or creating standardized groups of variable values (for example age groups).‚Äù}. This is where the {dplyr} function case_when() is here to help us.\nThe syntax of case_when() is a little more advanced than what we have seen so far, but we will go slowly and break it down. Once you get the hang of it, case_when() will become a very powerful part of your R toolbelt. We will almost always use case_when() inside of a mutate(), because we will use it either to recode an existing variable or to create a new one. The basic syntax works like this:\n\n# DO NOT RUN (PSEUDO-CODE)\ndf |&gt;\n  mutate(column_name = case_when([first condition] ~ [value when condition is TRUE],\n                                 [second condition] ~ [value when second condition is TRUE],\n                                 .default = [default value])\n\nOk, that‚Äôs a lot. Let‚Äôs break it down.\nSo the first thing to notice is that, with the exception of the last line, each line inside of case_when() starts with a conditional logic statement then a ~ followed by the value we want when that statement was true. So for example, if we want our case_when() to say that anytime a patient had a MUAC less than 110 we want to have a value of \"SAM\", the first part of our case when would be muac &lt; 110 ~ \"SAM'. Here the left side of the ~ provides the condition and the right side gives the value we want whenever that condition is true. We can add multiple possible outcomes by adding additional lines. So in this case, our next condition might check if the patient is moderately but not severly malnourished using the statement muac &lt; 125 ~ \"MAM\".\nThe last line, with the argument .default then gives the value we want case_when() to use when none of the above conditions have been met. In this case, we might give the value \"Normal\". To put this together, if we wanted to use case_when() to create a variable that classifies the malnutrition status of patients using their MUAC, we would write:\n\ndf_raw |&gt;\n  mutate(malnut = case_when(muac &lt; 110 ~ 'SAM',\n                            muac &lt; 125 ~ 'MAM',\n                            .default = 'Normal'))\n\n\nTry running the above code to see if it successfully creates a new column malnut with the malnutrition status of each case. You should get something like this:\n\n\n  malnut\n1 Normal\n2 Normal\n3    MAM\n4 Normal\n5    SAM\n6 Normal\n\n\n\nBe careful. The order of your statements is important here. What case_when() will do is go through each statement from top to bottom and assign the first value that is TRUE. So in our above example, case_when() will ask the following questions in sequence:\n\nDoes this patient have SAM (is muac &lt; 110)? If so, assign the value \"SAM\"\nIf the patient didn‚Äôt have SAM, do they have MAM (is muac &lt; 125)? If so, assign the value `‚ÄúMAM‚Äù\nIf none of the above conditions were true, assign the default value \"Normal\"\n\n\nTry reordering the first and second conditions in the above case_when() so that you first check if muac &lt; 125. The head of your new data frame should now look like this:\n\n\n  malnut\n1 Normal\n2 Normal\n3    MAM\n4 Normal\n5    MAM\n6 Normal\n\n\nNotice anything different? Save this new data frame to a tmp object and inspect it to see if we still have any patients classified as \"SAM\". Can you figure out why this no longer gives the correct classification?\n\n\n\n\n\n\n\nNote\n\n\n\nThe .default argument in case_when() is not obligatory. If you don‚Äôt include it then case_when() will use NA by default.\n\n\nAs we saw in our above example, case_when() is an easy way of creating new variables based on the values of an existing column. This can be used to classify status (as we saw with malnutrition) or to regroup variables into categories (like age groups).\n\nUse case_when() to create a new variable age_group with three categories: \"&lt; 5 Years\", \"5 - 15 Years\", and \"&gt; 15 Years\". Patients missing age data should be assigned a default value of \"Unknown\". Be careful with your ordering! The head of your new column should look like this:\n\n\n      age_group\n1     &lt; 5 Years\n2     &lt; 5 Years\n3 5 - 15  Years\n4     &lt; 5 Years\n5     &lt; 5 Years\n6     &lt; 5 Years\n\n\n\n\nThe %in% operator\nSo now we can regroup variables into categories, great. But we can also use case_when() to standardize the values we see in a variable.\n\nUsing count() inspect the categorical variables in df_raw to check if any have inconsistencies in their coding.\n\nIn our dataset, we see that there are some issues in the way sex was coded. For example, female patients are coded as f, female and femme. That simply won‚Äôt do. Thankfully, we can use case_when() to recode this variable. This time, instead of creating a new variable we will directly update sex:\n\ndf_raw |&gt;\n  mutate(sex = case_when(sex == \"f\" ~ \"Female\",\n                         sex == \"female\" ~ \"Female\",\n                         sex == \"femme\" ~ \"Female\",\n                         sex == \"m\" ~ \"Male\",\n                         sex == \"male\" ~ \"Male\",\n                         sex == \"homme\" ~ \"Male\",\n                         .default = \"Unknown\"))\n\nWell, that works, but it seems awfully repetititve. It would be easier if we could just list all the options that we want to reassign to ‚ÄúFemale‚Äù and ‚ÄúMale‚Äù respectively. This is where the %in% operator is here to help. The %in% operator will check if a value is in a vector of options using the following basic syntax:\n\n# DO NOT RUN (PSEUDO-CODE)\n[value] %in% [vector_of_options]\n\nSo, for example, we could check if the value \"f\" is in the options \"f\", \"female\" using the following:\n\n\"f\" %in% c(\"f\", \"female\")\n\n\nTry running the above statement. What is the data type of your outcome?\n\nSee how the outcome of the above statement is a boolean, ie: a logic outcome? That means we can use it as a condition in case_when()! This means that our verbose code above can now be written as:\n\ndf_raw |&gt;\n  mutate(sex = case_when(sex %in% c(\"f\", \"female\", \"femme\") ~ \"Female\",\n                         sex %in% c(\"m\", \"male\", \"homme\") ~ \"Male\",\n                         .default = \"Unknown\"))\n\nMuch nicer.\n\nUse case_when() and the %in% operator to create a new column vacc_status_strict that has the value \"Yes\" for cases with card confirmed vaccination status, \"No\" for cases who said they were unvaccinated, and \"Unverified\" otherwise. The head of your new column should look like this:\n\n\n  vacc_status_strict\n1         Unverified\n2                 No\n3         Unverified\n4                 No\n5                 No\n6                 No"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#a-last-bit-of-cleanup",
    "href": "sessions_core/04_data_verbs_conditional.html#a-last-bit-of-cleanup",
    "title": "Data Manipulation with Conditional Logic",
    "section": "A Last Bit of Cleanup",
    "text": "A Last Bit of Cleanup\nNow that we know how to leverage case_when() and conditional logic (in addition to what we learned in the last session, we can actually put together a decent cleaning pipeline. I hope you kept your code from last time handy‚Ä¶\n\nUsing what you have learned above and what you practiced in the last session, create a basic data cleaning pipe that creates a new data frame, df, after doing the following:\n\nRemove the variables full_name and age_unit\nRename the following variables:\n\nage becomes age_months\nsub_prefecture becomes prefecture\nvillage_commune becomes village\nhealth_facility_name becomes facility\n\nAdd a variable age_years with patient age in years\nUpdate region and prefecture to use title case\nUpdate all date columns to use Date type\nCreate a new varialbe age_group age to include the groups: &lt; 6 months, 6 - 11 months, 12 - 59 months, 5 - 15 years, and &gt; 15 years (patients with unknown sex should have a value ‚ÄúUnknown‚Äù)\nRecode sex to have only the values: Female, Male, and Unknown\nRemove any duplicate observations\n\nThe head of your final data should look something like this:\n\n\n  id    sex age_months  region prefecture        village date_onset\n1  1 Female         36 Mandoul   Moissala Sangana Ko√Øtan 2022-08-13\n2  2 Female          5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3 Female        156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6   Male          8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7   Male          7 Mandoul   Moissala      T√©tindaya 2022-08-30\n6 10   Male          4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             yes     2022-08-14\n2        2022-08-25             yes     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25              no           &lt;NA&gt;\n5        2022-09-02              no           &lt;NA&gt;\n6        2022-09-02             yes     2022-09-02\n                         facility malaria_rdt fever rash cough red_eye\n1 H√¥pital du District de Moissala    negative    No &lt;NA&gt;   Yes      No\n2 H√¥pital du District de Moissala    negative    No   No   Yes      No\n3                      CS Silambi    negative   Yes &lt;NA&gt;    No      No\n4 H√¥pital du District de Moissala    negative    No   No    No    &lt;NA&gt;\n5                      CS Silambi    negative  &lt;NA&gt;   No   Yes     Yes\n6                    Moissala Est    negative   Yes   No    No    &lt;NA&gt;\n  pneumonia encephalitis muac vacc_status vacc_doses   outcome date_outcome\n1        No           No  244        &lt;NA&gt;       &lt;NA&gt; recovered   2022-08-18\n2      &lt;NA&gt;           No  232          No       &lt;NA&gt;      &lt;NA&gt;   2022-08-28\n3        No         &lt;NA&gt;  123  Yes - oral       &lt;NA&gt; recovered         &lt;NA&gt;\n4        No           No  210          No       &lt;NA&gt; recovered         &lt;NA&gt;\n5        No           No   80          No       &lt;NA&gt; recovered         &lt;NA&gt;\n6        No           No  220          No       &lt;NA&gt; recovered   2022-09-03\n   age_years      age_group\n1  3.0000000 12 - 59 months\n2  0.4166667     &lt; 6 months\n3 13.0000000   5 - 15 years\n4  0.6666667  6 - 11 months\n5  0.5833333  6 - 11 months\n6  0.3333333     &lt; 6 months\n\n\n\nAmazing! Wouldn‚Äôt it be great to save this (more or less clean) dataset? I agree. To do that, we will go back to the packages {rio} and {here}. We can use the function export() from {rio} and use here() to specify where to save our output:\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.xlsx'))\n\nNotice here that we are putting our data in the appropriate clean subfolder of data.\n\n\n\n\n\n\nTip\n\n\n\nIn the above example we save our data as an xlsx, which is helpful if you want to be able to open the clean data in Excel. Often, however, we might prefer to use a file with the extension .rds instead. This is a filetype specific to R and is more robust to issues related to encoding or date formatting than files like xlsx or csv. To save your above file as an rds all you need to do is change the extension:\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.rds'))"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#done",
    "href": "sessions_core/04_data_verbs_conditional.html#done",
    "title": "Data Manipulation with Conditional Logic",
    "section": "Done!",
    "text": "Done!\nVery well done. You‚Äôve learned how to use basic data verbs, conditional logic, and create a basic data cleaning pipeline.\n\n\n\n Solution File"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#going-further",
    "href": "sessions_core/04_data_verbs_conditional.html#going-further",
    "title": "Data Manipulation with Conditional Logic",
    "section": "Going Further",
    "text": "Going Further\n\nExtra Exercises"
  },
  {
    "objectID": "pathway.fr.html",
    "href": "pathway.fr.html",
    "title": "Cours",
    "section": "",
    "text": "Ces sessions peuvent √™tre suivies afin d‚Äôobtenir un niveau de base dans R. La s√©rie suppose aucune exp√©rience pr√©alable dans R et convient bien aux d√©butants.\nVous en voulez plus ? Vous voulez plus de flexibilit√© ? Consultez le catalogue complet des sessions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to R\n\n\n\n\n\nYour first steps in R. Learn your way around Rstudio, and meet some common R objects.\n\n\n\n\n\nFeb 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImport data\n\n\n\n\n\nCreate an Rstudio project, install useful packages and start importing data to work in R\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "explore.html",
    "href": "explore.html",
    "title": "Explore",
    "section": "",
    "text": "Choose your own adventure by browsing all available sessions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBasic Data Manipulation\n\n\n\nCore\n\n\nData Manipulation\n\n\nData Cleaning\n\n\n\nAn introduction to data manipulation and cleaning using {dplyr}\n\n\n\n\n\n\nFeb 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Manipulation with Conditional Logic\n\n\n\nCore\n\n\nData Manipulation\n\n\nData Cleaning\n\n\nLogic\n\n\n\nUsing {dplyr} and conditional logic to filter and recode data\n\n\n\n\n\n\nFeb 12, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImport data\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCreate an Rstudio project, install useful packages and start importing data to work in R\n\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des donn√©es\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCr√©ez un projet Rstudio, installez les paquets utiles et importez des donn√©es pour travailler dans R.\n\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nYour first steps in R. Learn your way around Rstudio, and meet some common R objects.\n\n\n\n\n\n\nFeb 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction √† R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\nFeb 9, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSession Title\n\n\n\nCore\n\n\n\nShort description (appears on cards in pathway / explore pages)\n\n\n\n\n\n\nFeb 4, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nSummary tables\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nCreate summary tables.\n\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "pathway.html",
    "href": "pathway.html",
    "title": "Pathway",
    "section": "",
    "text": "These sessions can be followed in order to get a baseline level in R. The series assumes no prior experience in R and is suitable for beginners.\nLooking for more? Want more flexibility? Consider browsing the full session catalog.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to R\n\n\n\n\n\nYour first steps in R. Learn your way around Rstudio, and meet some common R objects.\n\n\n\n\n\nFeb 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImport data\n\n\n\n\n\nCreate an Rstudio project, install useful packages and start importing data to work in R\n\n\n\n\n\nFeb 10, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nBasic Data Manipulation\n\n\n\n\n\nAn introduction to data manipulation and cleaning using {dplyr}\n\n\n\n\n\nFeb 11, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.fr.html#salut",
    "href": "about.fr.html#salut",
    "title": "√Ä Propos",
    "section": "Salut",
    "text": "Salut\nBienvenue sur {repicentre}, un site open source d√©velopp√© par Epicentre pour vous aider √† apprendre R pour les contextes humanitaires. Le site est compos√© de tutoriels autodidactes et propose deux options principales d‚Äôapprentissage :\n\nLin√©aire. Con√ßu pour les personnes n‚Äôayant aucune exp√©rience pr√©alable de R, le cours lin√©aire vous guidera √† travers les concepts de base de R en utilisant une √©tude de cas sur la rougeole au Tchad. Le cours couvre les concepts suivants :\n\nStructures de donn√©es et l‚Äôinterface RStudio\nImportation de donn√©es\nManipulation de donn√©es\nNettoyage des donn√©es\nAgr√©gation de donn√©es\nVisualisation des donn√©es\n\nExploration. Si vous avez un peu plus d‚Äôexp√©rience ou si vous recherchez un sujet particulier, n‚Äôh√©sitez pas √† explorer la gamme compl√®te des tutoriels. Les tutoriels sont class√©s par cat√©gories et sont con√ßus pour √™tre autonomes."
  },
  {
    "objectID": "about.fr.html#recommandations-et-demandes",
    "href": "about.fr.html#recommandations-et-demandes",
    "title": "√Ä Propos",
    "section": "Recommandations et demandes",
    "text": "Recommandations et demandes\nY a-t-il un sujet sur lequel vous aimeriez voir un tutoriel qui n‚Äôest pas encore disponible ? C‚Äôest tr√®s bien ! N‚Äôh√©sitez pas √† nous le faire savoir en ouvrant un ‚Äúissue‚Äù sur le repo GitHub associ√© √† ce site web. Si vous ne savez pas comment ouvrir un issue, veuillez contacter Cat Eisenhauer."
  },
  {
    "objectID": "about.fr.html#contribuer",
    "href": "about.fr.html#contribuer",
    "title": "√Ä Propos",
    "section": "Contribuer",
    "text": "Contribuer\nVous souhaitez contribuer √† la r√©daction ou √† la maintenance de tutoriels ? Incroyable ! Veuillez contacter Cat."
  },
  {
    "objectID": "resources.fr.html",
    "href": "resources.fr.html",
    "title": "Ressources",
    "section": "",
    "text": "Cette page contiendra (√©ventuellement) des ressources externes pour poursuivre votre parcours d‚Äôapprentissage du R."
  }
]