<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Session complémentaire au module FETCH d’enquête">

<title>Enquête standardisée sur la mortalité – {repicentre}</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-6fbc3b7d0ac83ab8a043646d6c6d94a5.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-ebb886636e44b25a2e4e919ac2fea188.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-59274be23de1086093cf917752a9db10.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-31b7f221592b76be63f349b822ab6d6a.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../site_libs/font-awesome-6.5.2/js/script.js"></script>
<script type="text/javascript" src="../script.js"></script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">{repicentre}</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../pathway.html"> 
<span class="menu-text">Pathway</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../explore.html"> 
<span class="menu-text">Explore</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#objectifs" id="toc-objectifs" class="nav-link active" data-scroll-target="#objectifs">Objectifs</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#configuration" id="toc-configuration" class="nav-link" data-scroll-target="#configuration">Configuration</a></li>
  <li><a href="#import" id="toc-import" class="nav-link" data-scroll-target="#import">Import</a></li>
  <li><a href="#premier-aperçu-et-recodage" id="toc-premier-aperçu-et-recodage" class="nav-link" data-scroll-target="#premier-aperçu-et-recodage">Premier aperçu (et recodage)</a></li>
  <li><a href="#nettoyage" id="toc-nettoyage" class="nav-link" data-scroll-target="#nettoyage">Nettoyage</a>
  <ul class="collapse">
  <li><a href="#dates-en-tant-que-dates-simples" id="toc-dates-en-tant-que-dates-simples" class="nav-link" data-scroll-target="#dates-en-tant-que-dates-simples">Dates en tant que dates (simples)</a></li>
  <li><a href="#correction-des-problèmes-logiques" id="toc-correction-des-problèmes-logiques" class="nav-link" data-scroll-target="#correction-des-problèmes-logiques">Correction des problèmes logiques</a></li>
  </ul></li>
  <li><a href="#joindre-les-données-des-ménages" id="toc-joindre-les-données-des-ménages" class="nav-link" data-scroll-target="#joindre-les-données-des-ménages">Joindre les données des ménages</a></li>
  <li><a href="#calculs-de-mortalité" id="toc-calculs-de-mortalité" class="nav-link" data-scroll-target="#calculs-de-mortalité">Calculs de mortalité</a>
  <ul class="collapse">
  <li><a href="#personne-temps-à-risque" id="toc-personne-temps-à-risque" class="nav-link" data-scroll-target="#personne-temps-à-risque">Personne-temps à risque</a></li>
  <li><a href="#calculs-de-mortalité-1" id="toc-calculs-de-mortalité-1" class="nav-link" data-scroll-target="#calculs-de-mortalité-1">Calculs de mortalité</a></li>
  </ul></li>
  <li><a href="#cest-terminé" id="toc-cest-terminé" class="nav-link" data-scroll-target="#cest-terminé">C’est terminé !</a></li>
  <li><a href="#aller-plus-loin" id="toc-aller-plus-loin" class="nav-link" data-scroll-target="#aller-plus-loin">Aller plus loin</a>
  <ul class="collapse">
  <li><a href="#exercices-supplémentaires" id="toc-exercices-supplémentaires" class="nav-link" data-scroll-target="#exercices-supplémentaires">Exercices supplémentaires</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Enquête standardisée sur la mortalité</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Compagnon</div>
    <div class="quarto-category">Analyse</div>
  </div>
  </div>

<div>
  <div class="description">
    Session complémentaire au module FETCH d’enquête
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="objectifs" class="level2">
<h2 class="anchored" data-anchor-id="objectifs">Objectifs</h2>
<ul>
<li>Calculer personne-temps à risque</li>
<li>Utiliser <code>{srvyr}</code> pour estimer les taux de mortalité</li>
</ul>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Cette session se concentre sur les analyses de base pour une enquête rétrospective sur la mortalité à l’aide du protocole standard de MSF. Nous utiliserons une étude de cas dans laquelle une enquête a été menée à la suite d’une épidémie de choléra en Haïti en 2010.</p>
<p>Cette session suppose que vous avez suivi le parcours d’apprentissage de base pour R et que vous êtes capable de :</p>
<ul>
<li>Importer des données</li>
<li>Effectuer un nettoyage de base à l’aide de <code>case_when()</code></li>
<li>Agrégation des données à l’aide de <code>count()</code> et <code>summarize()</code></li>
<li>Production de tableaux à l’aide de <code>gt()</code></li>
</ul>
<p>Si vous avez besoin de revoir ou d’apprendre l’un de ces sujets, veuillez vous reporter aux <a href="&quot;https://epicentre-msf.github.io/repicentre/pathway.html&quot;">sessions de base du parcours d’apprentissage</a>.</p>
</section>
<section id="configuration" class="level2">
<h2 class="anchored" data-anchor-id="configuration">Configuration</h2>
<div class="setup">
<p>Cette session utilise une étude de cas spécifique. Téléchargez et décompressez le dossier associé, puis ouvrez le script <code>main.R</code> à partir du dossier <code>R</code> :</p>
<div class="cell">
<div class="cell-output-display">
<a href="https://github.com/epicentre-msf/repicentre/raw/main/data/mod_survey/mortality_survey.zip">
<button class="btn btn-default"><i class="fa fa-save"></i> Télécharger</button>
</a>
</div>
</div>
</div>
<p>Le dossier que vous avez téléchargé contient un script R (presque) vide ainsi que des fichiers Excel pour le formulaire Kobo utilisé dans l’enquête et les données collectées avec celui-ci.</p>
<div class="look">
<p>Prenez une minute pour ouvrir et examiner le formulaire Kobo et les données brutes. Que contiennent les différents onglets des données brutes ?</p>
</div>
</section>
<section id="import" class="level2">
<h2 class="anchored" data-anchor-id="import">Import</h2>
<p>Notre ensemble de données comporte deux onglets, le premier contenant les données au niveau des ménages et le second les données individuelles. Pour l’instant, nous nous intéressons principalement aux données individuelles, mais nous aurons finalement besoin des deux. Chargeons tout cela dans R (ainsi que les paquets que nous utiliserons dans la session d’aujourd’hui).</p>
<div class="write">
<p>Dans votre script (<code>main.R</code>), ajoutez un en-tête approprié pour le fichier et créez une section qui charge les paquets suivants :</p>
<ul>
<li><code>here</code></li>
<li><code>rio</code></li>
<li><code>gt</code></li>
<li><code>srvyr</code></li>
<li><code>tidyverse</code></li>
</ul>
<p>Créez ensuite une nouvelle section appelée <code>Import</code> et utilisez <code>rio</code> pour importer la deuxième feuille de votre ensemble de données dans un objet appelé <code>df_raw</code>. Nous n’avons pas besoin de toutes les colonnes de ces données, utilisez <code>select()</code> pour sélectionner uniquement les suivantes :</p>
<ul>
<li><code>sex</code></li>
<li><code>age</code></li>
<li><code>born</code></li>
<li><code>born_date</code></li>
<li><code>joined</code></li>
<li><code>joined_date</code></li>
<li><code>left</code></li>
<li><code>died</code></li>
<li><code>died_date</code></li>
<li><code>died_cause</code></li>
<li><code>_parent_index</code> renommé <code>hh</code></li>
</ul>
<p>Créez ensuite un deuxième objet appelé <code>df_hh</code> contenant la première feuille de votre ensemble de données en conservant uniquement les colonnes suivantes :</p>
<ul>
<li><code>interview_date</code></li>
<li><code>clst_id</code></li>
<li><code>_index</code> renommé <code>hh</code></li>
<li><code>present</code></li>
<li><code>consent</code></li>
</ul>
<p><strong>Astuce</strong>. N’oubliez pas que lorsque vous utilisez <code>select()</code>, vous pouvez rapidement renommer un élément à l’aide d’un <code>=</code>, par exemple : <code>hh = "_parent_index"</code>.</p>
</div>
</section>
<section id="premier-aperçu-et-recodage" class="level2">
<h2 class="anchored" data-anchor-id="premier-aperçu-et-recodage">Premier aperçu (et recodage)</h2>
<p>Super ! Maintenant que nous avons chargé nos données, jetons-y un premier coup d’œil. L’une des premières choses que nous pouvons faire est de vérifier la structure de nos données :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>df_raw <span class="sc">|&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Nous pouvons également vérifier rapidement combien de personnes dans l’ensemble de données sont décédées, car notre enquête porte sur la mortalité :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>df_raw <span class="sc">|&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">count</span>(died)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="write">
<p>Utilisez <code>count()</code> pour déterminer le nombre de participants par sexe.</p>
</div>
<p>Hum, <code>1</code> et <code>2</code> pour le sexe sont un peu ambigus. Il pourrait être utile de recoder nos données catégorielles afin d’utiliser des étiquettes plus significatives. Par exemple :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> df_raw <span class="sc">|&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># recodage</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">sexe =</span> <span class="fu">case_when</span>(</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>      sexe <span class="sc">==</span> <span class="dv">1</span> <span class="sc">~</span> <span class="st">"Homme"</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      sexe <span class="sc">==</span> <span class="dv">2</span> <span class="sc">~</span> <span class="st">'Femme`,</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="st">      .default = NA</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="st">    )</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="st">  )</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="write">
<p>Créez une nouvelle section dans votre script intitulée <code>Nettoyage</code>. Cette section comprendra un ‘pipeline de nettoyage’ qui prendra <code>df_raw</code>, effectuera plusieurs étapes de nettoyage et stockera le cadre de données résultant dans un objet appelé ‘df’. <br><br> À l’aide de <code>case_when()</code>, créez une nouvelle étape dans votre pipeline de nettoyage qui recode les variables catégorielles de votre ensemble de données. Vous pouvez utiliser le recodage ci-dessus pour <code>sex</code>. Pour les variables <code>born</code>, <code>joined</code>, <code>left</code> et <code>died</code>, utilisez le recodage suivant :</p>
<ul>
<li>0 = Non</li>
<li>1 = Oui</li>
<li>99 = Inconnu</li>
</ul>
<p>Pour ‘died_cause’, utilisez le recodage suivant :</p>
<ul>
<li>1 = Diarrhée</li>
<li>2 = Fièvre</li>
<li>3 = Maladie respiratoire</li>
<li>4 = Accident</li>
<li>5 = Pendant l’accouchement</li>
<li>6 = Autre</li>
<li>99 = Inconnu</li>
<li>NA = N’est pas décédé</li>
</ul>
<p>La tête de ‘df’ devrait ressembler à ceci :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>    sex age born_date joined_date left_date died_date born joined left died
1 Femme  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
2  Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
3 Femme  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
4 Femme   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
5  Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
6 Femme  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
        died_cause hh
1 N'est pas décédé  1
2 N'est pas décédé  1
3 N'est pas décédé  1
4 N'est pas décédé  1
5 N'est pas décédé  1
6 N'est pas décédé  1</code></pre>
</div>
</div>
<p>Maintenant que nous avons des étiquettes plus claires, explorons un peu plus nos données. Par exemple :</p>
<ul>
<li>Combien de personnes sont décédées pour chaque cause potentielle ?</li>
<li>Observez les combinaisons de <code>died</code>, <code>left</code>, <code>joined</code> et <code>born</code>. Quelles sont les combinaisons les plus courantes ? Cela vous semble-t-il logique ?</li>
<li>Qui est le plus touché par le décès, les hommes ou les femmes ? Qui était le plus à risque ?</li>
</ul>
<p><br> <strong>Astuce</strong>. N’oubliez pas que vous pouvez attribuer plusieurs noms de colonnes à <code>count()</code> afin de créer des tableaux de contingence.</p>
</div>
</section>
<section id="nettoyage" class="level2">
<h2 class="anchored" data-anchor-id="nettoyage">Nettoyage</h2>
<section id="dates-en-tant-que-dates-simples" class="level3">
<h3 class="anchored" data-anchor-id="dates-en-tant-que-dates-simples">Dates en tant que dates (simples)</h3>
<p>Terminons le nettoyage de nos données pour l’analyse. Nous devons notamment nous assurer que toutes nos données sont du bon type. Nous avons déjà recodé toutes les variables catégorielles, mais nous n’avons pas encore examiné les dates.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(df_raw<span class="sc">$</span>born_date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "POSIXct" "POSIXt" </code></pre>
</div>
</div>
<p>Il semble que nos dates soient de type <code>POSITct</code>. Convertissons-les en un format de date plus simple à l’aide de <code>ymd()</code> de <code>{lubridate}</code>.</p>
<div class="write">
<p>Ajoutez une étape à votre pipeline de nettoyage qui utilise <code>ymd()</code> de <code>{lubridate}</code> pour convertir les dates de <code>born_date</code>, <code>joined_date</code>, <code>left_date</code> et <code>died_date</code> en dates simples. <br><br></p>
<p>La <code>classe ()</code> de <code>df$born_date</code> devrait désormais être <code>Date</code> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(df<span class="sc">$</span>born_date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Date"</code></pre>
</div>
</div>
</div>
</section>
<section id="correction-des-problèmes-logiques" class="level3">
<h3 class="anchored" data-anchor-id="correction-des-problèmes-logiques">Correction des problèmes logiques</h3>
<p>Un formulaire Kobo bien conçu peut grandement contribuer à garantir la collecte de données de bonne qualité dès le départ. Par exemple, nous pouvons rendre certaines questions obligatoires afin d’éviter les données manquantes. Nous pouvons également créer des ‘contraintes’ qui généreront des messages d’erreur lorsque les données saisies enfreignent les règles prédéfinies ; par exemple, nous pouvons créer une contrainte qui empêche l’enquêteur de saisir une date de décès qui ne correspond pas à la période de rappel.</p>
<div class="look">
<p>Ouvrez le fichier Excel de l’enquête Kobo ‘retrospective-mortality_kobo.xlsx’ et examinez la colonne ‘contrainte’. Quelles sont les contraintes créées dans ce fichier ? Pouvez-vous penser à quelque chose qui n’a pas été pris en compte ?</p>
</div>
<p>Malgré toutes les protections que nous avons mises en place dans le processus de collecte, un peu de nettoyage sera toujours nécessaire. Par exemple, bien que nous ayons veillé à ce que toutes les dates se situent dans la période de rappel, nous n’avons pas créé de contrôles pour d’autres relations illogiques entre les dates. Voyons, par exemple, si quelqu’un est né après son décès :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>df_raw <span class="sc">|&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> (died_date <span class="sc">&lt;</span> born_date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="write">
<p>Utilisez <code>filter()</code> pour vérifier s’il y a des cas de personnes qui ont rejoint la famille après leur décès. Combien de fois cela s’est-il produit ?</p>
<p>Le début de votre sortie devrait ressembler à ceci :</p>
</div>
<p>Ce n’est pas terrible. Comment pouvons-nous corriger cela ? La meilleure pratique à adopter ici fait l’objet d’un débat, mais nous vous recommandons de conserver la date de décès et de supprimer la date de naissance/d’adhésion (c’est-à-dire la remplacer par ‘NA’). Sinon, si vous constatez cette erreur pendant la collecte des données, vous pouvez interroger l’enquêteur à ce sujet. Il se peut qu’il s’agisse d’une faute de frappe et qu’il se souvienne des dates exactes. Dans la mesure du possible, essayez d’effectuer ce type de contrôle quotidiennement afin de pouvoir corriger les problèmes en temps réel.</p>
<p>Si nous ne pouvons conserver qu’une seule date, pourquoi privilégier la date de décès ? La date de décès est la variable la plus importante dans le cadre de cette enquête particulière. Il s’agit également d’un événement rare, ce qui signifie que toute date manquante pourrait avoir un impact disproportionné sur les résultats. De plus, on peut supposer que la date de décès est plus fiable que d’autres dates (telles que la date exacte de naissance ou la date d’arrivée/de départ d’une personne dans le foyer).</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dans ce cas précis, il n’y avait que quelques cas de ‘naissance ou entrée dans le foyer après le décès’ sur un ensemble de données de plus de 18 000 personnes, donc supprimer leurs dates de naissance/d’entrée dans le foyer n’est pas très grave. Toutefois, si des erreurs de ce type sont plus fréquentes, cela peut indiquer un problème important dans la conception du formulaire et/ou la formation des enquêteurs. Rechercher rapidement ce type de problèmes (même dans Excel) après la phase pilote et pendant la phase de collecte des données peut vous aider à repérer les problèmes tant que vous avez encore le temps de les corriger.</p>
</div>
</div>
<div class="write">
<p>À l’aide de <code>mutate()</code> et <code>case_when()</code>, ajoutez une étape à votre pipeline de nettoyage pour remplacer les dates de naissance/d’adhésion problématiques par <code>NA</code>. Comment pouvez-vous vérifier si cela a fonctionné correctement ?</p>
</div>
<p>Voyez-vous d’autres problèmes dans les données ? J’en vois deux :</p>
<ul>
<li>Quelques personnes sont nées pendant la période de rappel, mais ont un âge supérieur à 0</li>
<li>Une personne est décédée après avoir quitté le foyer</li>
</ul>
<div class="look">
<p>Comment traiteriez-vous ces deux problèmes ? Réfléchissez aux types de problèmes qui ont pu les causer et aux conséquences des différentes stratégies de nettoyage sur vos résultats finaux. <br><br> <strong>Bonus</strong>. Pensez-vous que l’un ou l’autre de ces problèmes aurait pu être évité grâce à une meilleure conception du Kobo ?</p>
</div>
<p>Examinons d’abord le problème des personnes nées pendant la période de rappel et dont l’âge est supérieur à 0. La manière de traiter les âges inférieurs à 1 peut être délicate et les enquêteurs doivent être formés de manière explicite pour savoir s’ils doivent ‘arrondir’ ou ‘arrondir à la baisse’. Sinon, les enquêtes modernes ont tendance à demander l’âge en mois pour les personnes en dessous d’une certaine limite (généralement 12, 23 ou 59 mois). Il est particulièrement important d’enregistrer l’âge en mois des jeunes enfants dans les enquêtes qui se concentrent sur des questions telles que la vaccination, la malnutrition ou la mortalité, où les problèmes de santé concernés sont (potentiellement) associés aux nourrissons ou aux enfants de moins de 5 ans. Une contrainte aurait également pu être ajoutée au formulaire Kobo pour éviter ce problème.</p>
<p>Dans le cadre de cette enquête, nous ne disposons d’aucune information sur les mois, donc la meilleure chose à faire est d’imposer une règle cohérente selon laquelle tout âge inférieur à 12 mois doit être enregistré comme 0. Cela signifie que si un enfant est né pendant la période de rappel (qui est une période inférieure à 12 mois), son âge doit être 0.</p>
<div class="write">
<p>Ajoutez une étape à votre pipeline qui garantit que toute personne née pendant la période de rappel a un âge de 0. Si vous avez effectué cette opération correctement, vous devriez pouvoir filtrer df pour ne voir que les personnes nées pendant la période de rappel et vérifier que leur âge est 0 :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df <span class="sc">|&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(born <span class="sc">==</span> <span class="st">'Oui'</span>) <span class="sc">|&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(age) <span class="sc">|&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unique</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0</code></pre>
</div>
</div>
</div>
<p>Le deuxième problème est un peu plus complexe. Examinons les individus concernés :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>df <span class="sc">|&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span>(left_date <span class="sc">&lt;</span> died_date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     sex age born_date joined_date  left_date  died_date born joined left died
1   Male  25      &lt;NA&gt;        &lt;NA&gt; 2010-11-02 2011-03-08  Non    Non  Oui  Oui
2 Female   3      &lt;NA&gt;  2011-01-05 2010-11-20 2011-03-28  Non    Oui  Oui  Oui
3 Female  60      &lt;NA&gt;  2011-03-08 2011-02-15 2011-03-15  Non    Oui  Oui  Oui
  died_cause   hh
1   Diarrhée   88
2   Diarrhée  236
3   Diarrhée 2861</code></pre>
</div>
</div>
<div class="look">
<p>Examinez les trois personnes dans le résultat ci-dessus. Sont-elles toutes problématiques ? Pourquoi ou pourquoi pas ?</p>
</div>
<p>Les personnes âgées de 3 et 60 ans ne posent pas de problème, elles ont simplement quitté le foyer puis l’ont réintégré. En revanche, la personne âgée de 25 ans semble avoir quitté le foyer puis être décédée sans jamais y revenir entre-temps. Que devons-nous faire ? Réfléchissons aux raisons pour lesquelles une telle situation pourrait apparaître dans nos données. Il existe deux options principales :</p>
<ul>
<li>Peut-être que la personne <strong>a</strong> réintégré le foyer, mais que le participant a oublié de le mentionner</li>
<li>Peut-être que le participant n’a pas bien compris que l’enquête ne prendrait en compte que les décès survenus alors que la personne était <strong>encore membre du foyer</strong> au moment de son décès</li>
</ul>
<p>Si possible, nous pourrions discuter avec l’enquêteur qui a mené cet entretien afin de déterminer quelle option est la plus probable. En l’absence d’informations supplémentaires, nous devrons probablement opter pour la deuxième option. Si nous faisons cela, nous devrons recoder cette personne comme étant vivante plutôt que décédée, car elle était encore en vie au moment où elle a quitté le ménage.</p>
<div class="write">
<p>Ajoutez une étape supplémentaire à votre pipeline qui recode cette personne comme étant vivante, c’est-à-dire : sa valeur ‘décédé’ doit être réinitialisée à ‘Non’ et sa date de décès doit être supprimée. Si vous vérifiez à nouveau les personnes qui ont quitté le foyer avant leur décès, vous ne devriez voir que deux personnes :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>    sex age born_date joined_date  left_date  died_date born joined left died
1 Femme   3      &lt;NA&gt;  2011-01-05 2010-11-20 2011-03-28  Non    Oui  Oui  Oui
2 Femme  60      &lt;NA&gt;  2011-03-08 2011-02-15 2011-03-15  Non    Oui  Oui  Oui
  died_cause   hh
1   Diarrhée  236
2   Diarrhée 2861</code></pre>
</div>
</div>
<p><strong>Remarque</strong>. La décision de supprimer un décès de l’ensemble de données est discutable. N’oubliez pas que les décès étant des événements rares, l’ajout ou la suppression d’un décès peut avoir un impact disproportionné sur les calculs de mortalité. Pour minimiser ce type de problème, veillez à consacrer suffisamment de temps à la formation des enquêteurs afin qu’ils comprennent parfaitement les concepts fondamentaux tels que la période de rappel et la notion de ‘ménage continu’. Donner des exemples spécifiques comme celui-ci pendant la formation peut aider les enquêteurs à gérer ces problèmes de manière appropriée lorsqu’ils se présentent pendant la collecte des données.</p>
</div>
</section>
</section>
<section id="joindre-les-données-des-ménages" class="level2">
<h2 class="anchored" data-anchor-id="joindre-les-données-des-ménages">Joindre les données des ménages</h2>
<p>Nos données individuelles semblent correctes, mais elles sont complètement déconnectées de nos données au niveau des ménages (vous vous souvenez de <code>df_hh</code> au début du tutoriel ?). Par exemple, nous aimerions connaître la date de l’entretien associée à chaque individu ainsi que le groupe auquel il appartenait. Pour ce faire, nous devons effectuer une <strong>jointure</strong>.</p>
<p>Une analyse approfondie des jointures dépasse le cadre de cette session, mais en substance, les jointures sont utilisées pour prendre les données d’un dataframe et les ajouter (ligne par ligne) à un autre dataframe sur la base d’une variable commune aux deux ensembles de données (telle qu’un identifiant). Par exemple, nous voulons ici parcourir ligne par ligne nos données individuelles (<code>df</code>) et ajouter des colonnes contenant les informations relatives au niveau des ménages pour chaque personne (à partir de <code>df_hh</code>). Pour ce faire, nous utiliserons la fonction <code>left_join()</code> de <code>{dplyr}</code> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>df <span class="sc">|&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">left_join</span>(df_hh) <span class="sc">|&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Joining with `by = join_by(hh)`</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>    sex age born_date joined_date left_date died_date born joined left died
1 Femme  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
2  Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
3 Femme  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
4 Femme   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
5  Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
6 Femme  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
        died_cause hh interview_date clst_id present consent
1 N'est pas décédé  1     2011-03-29       1       1       1
2 N'est pas décédé  1     2011-03-29       1       1       1
3 N'est pas décédé  1     2011-03-29       1       1       1
4 N'est pas décédé  1     2011-03-29       1       1       1
5 N'est pas décédé  1     2011-03-29       1       1       1
6 N'est pas décédé  1     2011-03-29       1       1       1</code></pre>
</div>
</div>
<p>Notez qu’ici, R a utilisé la colonne <code>hh</code> (identifiant du ménage) comme variable commune entre les ensembles de données ; vous pouvez voir un message indiquant cela juste au-dessus de la sortie de <code>head()</code>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Que signifie ‘left’ dans <code>left_join()</code> ? En termes simples, les jointures gauches impliquent un ensemble de données auquel des données sont <strong>ajoutées</strong> (ensemble de données A) et un autre dont des données sont <strong>extraites</strong> (ensemble de données B). L’ensemble de données A est l’‘ensemble de données principal’ et le résultat inclura toujours toutes ses lignes. Les lignes de l’ensemble de données B seront conservées si et seulement si <code>left_join()</code> trouve une ligne appropriée dans l’ensemble de données A à laquelle elles peuvent être ajoutées. Dans nos données, par exemple, les lignes de données sur les ménages qui n’avaient aucun membre (et qui n’apparaissent donc pas dans <code>df</code>) ne seront pas incluses dans le résultat de la jointure ci-dessus. <br><br> Dans une <code>left_join()</code>, R considérera toujours le premier argument comme l’ensemble de données principal (ensemble de données A) ; c’est-à-dire :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PSEUDO-CODE</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">left_join</span>(dataset_a, dataset_b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
<div class="write">
<p>Ajoutez une dernière étape à votre pipeline de nettoyage qui utilise <code>left_join()</code> pour ajouter les données au niveau des ménages à chacune des lignes de <code>df</code>, puis convertit <code>interview_date</code> pour utiliser un format de date de base (comme vous l’avez fait avec <code>born_date</code>, etc.). Votre pipeline final devrait maintenant effectuer les opérations suivantes :</p>
<ul>
<li>Utiliser <code>df_raw</code> comme entrée</li>
<li>Recoder les variables catégorielles</li>
<li>Convertir les dates au format simple a-m-j</li>
<li>Corriger les problèmes de données illogiques</li>
<li>Joindre les indicateurs des ménages</li>
</ul>
<p>Si tout s’est bien passé, l’en-tête de <code>df</code> devrait ressembler à ceci :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     sex age born_date joined_date left_date died_date born joined left died
1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
        died_cause hh interview_date clst_id present consent
1 N'est pas décédé  1     2011-03-29       1       1       1
2 N'est pas décédé  1     2011-03-29       1       1       1
3 N'est pas décédé  1     2011-03-29       1       1       1
4 N'est pas décédé  1     2011-03-29       1       1       1
5 N'est pas décédé  1     2011-03-29       1       1       1
6 N'est pas décédé  1     2011-03-29       1       1       1</code></pre>
</div>
</div>
</div>
</section>
<section id="calculs-de-mortalité" class="level2">
<h2 class="anchored" data-anchor-id="calculs-de-mortalité">Calculs de mortalité</h2>
<p>Une fois le nettoyage et la jonction terminés, nous pouvons enfin passer à la partie amusante, l’analyse. Nous voulons calculer les éléments suivants :</p>
<ul>
<li>Taux de mortalité brut</li>
<li>Taux de mortalité des moins de cinq ans</li>
<li>Taux de mortalité spécifique à la diarrhée</li>
</ul>
<div class="look">
<p>(Sur papier) Écrivez la formule pour chacun de ces indicateurs. Disposons-nous déjà de toutes les variables nécessaires dans notre ensemble de données pour effectuer les calculs ?</p>
</div>
<p>Ces indicateurs sont des <strong>taux</strong>, ce qui signifie qu’ils nécessitent un dénominateur en <strong>temps-personne à risque</strong>. Notre ensemble de données ne comporte pas encore de colonne pour cela. Corrigeons cela.</p>
<section id="personne-temps-à-risque" class="level3">
<h3 class="anchored" data-anchor-id="personne-temps-à-risque">Personne-temps à risque</h3>
<p>Pour notre enquête, le <strong>temps à risque par personne</strong> correspond au temps pendant lequel chaque individu était :</p>
<ul>
<li>En vie <strong>et</strong></li>
<li>Membre du ménage</li>
</ul>
<p>La plupart des personnes étaient en vie et faisaient partie du ménage pendant toute la période de rappel. Pour ces personnes, leur temps à risque correspond à la totalité de la période de rappel. Il existe cependant plusieurs autres options. Par exemple :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/companion/survey/person-time_FR.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<div class="look">
<p>La plupart de ces cas peuvent être traités de la même manière, à l’exception du dernier. Prenez une minute pour essayer de trouver sur papier une formule que nous pourrions utiliser pour le temps-personne. Vous gagnerez des points supplémentaires si vous parvenez à la convertir en code.</p>
</div>
<p>Il n’est pas facile de trouver une bonne formule ici, alors examinons-la ensemble. Imaginons une personne qui a rejoint le ménage fin 2010 et qui est décédée en février 2011. Si nous insérons les données de cette personne dans un cadre de données, nous pourrions obtenir quelque chose comme ceci :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>example <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">date_interview =</span> <span class="fu">as.Date</span>(<span class="st">"2011-04-07"</span>),</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">born =</span> <span class="st">"Non"</span>,</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">date_born =</span> <span class="cn">NA</span>,</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">joined =</span> <span class="st">"Oui"</span>,</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">date_joined =</span> <span class="fu">as.Date</span>(<span class="st">"2010-12-08"</span>),</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">left =</span> <span class="st">"Non"</span>,</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">date_left =</span> <span class="cn">NA</span>,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">died =</span> <span class="st">"Oui"</span>,</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">date_died =</span> <span class="fu">as.Date</span>(<span class="st">"2011-02-13"</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>example</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  date_interview born date_born joined date_joined left date_left died
1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui
   date_died
1 2011-02-13</code></pre>
</div>
</div>
<p>Pour calculer la durée d’exposition de cette personne, nous devons déterminer ‘quand sa période d’exposition a commencé’ et ‘quand elle s’est terminée’. Nous calculons ensuite la différence entre ces deux dates. Pour déterminer le début de la période d’exposition d’une personne, nous devons extraire la date à laquelle elle est née/a rejoint le foyer ou (si elle était présente pendant toute la période) la date de début de la période de rappel. Nous pouvons le faire à l’aide de <code>case_when()</code> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>recall_start <span class="ot">&lt;-</span> <span class="fu">as.Date</span>(<span class="st">"2010-10-17"</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>example <span class="sc">|&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">pt_start =</span> <span class="fu">case_when</span>(</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>      born <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_born,</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>      joined <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_joined,</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">.default =</span> recall_start</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  date_interview born date_born joined date_joined left date_left died
1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui
   date_died   pt_start
1 2011-02-13 2010-12-08</code></pre>
</div>
</div>
<p>De même, leur période à risque prend fin lorsqu’ils décèdent / quittent l’entreprise ou à la fin du rappel (lorsqu’ils ont été interrogés) :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>example <span class="sc">|&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">pt_end =</span> <span class="fu">case_when</span>(left <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_left,</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  died <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_died,</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">.default =</span> date_interview))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  date_interview born date_born joined date_joined left date_left died
1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui
   date_died     pt_end
1 2011-02-13 2011-02-13</code></pre>
</div>
</div>
<p>En rassemblant ces informations, nous pouvons alors calculer le temps total passé à risque par une personne comme étant la différence entre la fin et le début de ce temps :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>example <span class="sc">|&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">pt_start =</span> <span class="fu">case_when</span>(</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    born <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_born,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    joined <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_joined,</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">.default =</span> recall_start),</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">pt_end =</span> <span class="fu">case_when</span>(</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    left <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_left,</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    died <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> date_died,</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">.default =</span> date_interview),</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">pt =</span> pt_end <span class="sc">-</span> pt_start)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  date_interview born date_born joined date_joined left date_left died
1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui
   date_died   pt_start     pt_end      pt
1 2011-02-13 2010-12-08 2011-02-13 67 days</code></pre>
</div>
</div>
<div class="write">
<p>Créez une nouvelle section dans votre code intitulée ‘Calculer le temps de personne’ et initialisez un objet appelé ‘recall_start’ avec la date 2010-10-17. Ajoutez un bloc de code adaptant ce qui précède pour créer une colonne ‘pt’ dans ‘df’ qui calcule le temps de personne à risque. L’en-tête de ‘df’ devrait maintenant ressembler à ceci :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>     sex age born_date joined_date left_date died_date born joined left died
1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
        died_cause hh interview_date clst_id present consent   pt_start
1 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17
2 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17
3 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17
4 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17
5 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17
6 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17
      pt_end       pt
1 2011-03-29 163 days
2 2011-03-29 163 days
3 2011-03-29 163 days
4 2011-03-29 163 days
5 2011-03-29 163 days
6 2011-03-29 163 days</code></pre>
</div>
</div>
</div>
<p>Utilisons <code>range()</code> pour examiner les valeurs maximales et minimales de <code>pt</code> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(df<span class="sc">$</span>pt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Time differences in days
[1] NA NA</code></pre>
</div>
</div>
<p>Il semble que la valeur du temps de risque par personne soit parfois manquante. Cela se produit lorsque, par exemple, une personne est née / a rejoint / a quitté / est décédée, mais que les informations relatives à la date de cet événement sont manquantes. Comment devons-nous traiter cela ? Une option consiste à laisser la valeur manquante, ce qui signifie que cette personne ne contribue pas au temps de risque par personne dans les calculs ultérieurs de la mortalité. Une autre option consiste à nous pouvons prendre la première valeur disponible pour laquelle nous avons une date. Ainsi, par exemple, si nous ne savons pas quand une personne est née, nous utiliserons le début de la période de rappel comme début de son temps de risque.</p>
<div class="look">
<p>Quels sont les avantages et les inconvénients de ces deux options ? Comment ajusteriez-vous votre code ci-dessus pour mettre en œuvre la deuxième option ?</p>
</div>
<p>La première option réduit artificiellement le dénominateur de nos calculs de mortalité, ce qui entraîne une surestimation de la mortalité. La deuxième option aura l’effet inverse. Pour l’analyse d’aujourd’hui, nous choisirons la première option et laisserons notre code tel quel (valeurs manquantes comprises). Examinons à nouveau notre plage, en ignorant cette fois les valeurs manquantes :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(df<span class="sc">$</span>pt, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Time differences in days
[1] -141  172</code></pre>
</div>
</div>
<p>Nous obtenons maintenant des chiffres, mais il semble que nous ayons des valeurs négatives. Que se passe-t-il ? Repensez à la figure au début de cette section. Si la plupart des cas peuvent être gérés avec notre calcul actuel, celui-ci ne tient pas compte des personnes qui ont quitté puis rejoint le ménage, car ces personnes auront ‘joined_date &gt; left_date’.</p>
<div class="look">
<p>Réfléchissez à ces personnes qui quittent puis rejoignent un ménage, ainsi qu’aux dates concernées. Pouvez-vous imaginer une équation pour leur temps de risque individuel ? Comment pensez-vous que cela pourrait être codé ?</p>
</div>
<p>Pour ces personnes, au lieu de prendre la différence (entre la fin et le début du temps de risque), nous devons calculer deux tranches de temps (avant leur départ et après leur retour), puis les additionner. Voici comment procéder :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>tmp <span class="ot">&lt;-</span> df <span class="sc">|&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">pt =</span> <span class="fu">case_when</span>(</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    joined_date <span class="sc">&gt;</span> left_date <span class="sc">&amp;</span> born <span class="sc">==</span> <span class="st">"Oui"</span> <span class="sc">~</span> (left_date <span class="sc">-</span> born_date) <span class="sc">+</span> (interview_date <span class="sc">-</span> joined_date),</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    joined_date <span class="sc">&gt;</span> left_date <span class="sc">~</span> (left_date <span class="sc">-</span> recall_start) <span class="sc">+</span> (interview_date <span class="sc">-</span> joined_date),</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">.default =</span> pt</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(tmp<span class="sc">$</span>pt, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Time differences in days
[1]   0 172</code></pre>
</div>
</div>
<div class="write">
<p>Adaptez votre code pipe person-time afin d’inclure cette correction pour les personnes qui ont quitté puis réintégré le foyer. Ajoutez ensuite une ligne pour supprimer les colonnes <code>pt_start</code> et <code>pt_end</code>, car nous ne les utiliserons plus (et elles ne seront pas exactes pour les personnes qui ont quitté puis réintégré le foyer). La tête de <code>df</code> devrait désormais ressembler à ceci :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>     sex age born_date joined_date left_date died_date born joined left died
1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
        died_cause hh interview_date clst_id present consent       pt
1 N'est pas décédé  1     2011-03-29       1       1       1 163 days
2 N'est pas décédé  1     2011-03-29       1       1       1 163 days
3 N'est pas décédé  1     2011-03-29       1       1       1 163 days
4 N'est pas décédé  1     2011-03-29       1       1       1 163 days
5 N'est pas décédé  1     2011-03-29       1       1       1 163 days
6 N'est pas décédé  1     2011-03-29       1       1       1 163 days</code></pre>
</div>
</div>
<p><strong>Bonus</strong>. Pourquoi notre <code>case_when</code> ci-dessus devait-il comporter un cas distinct pour les personnes nées pendant la période de rappel ?</p>
</div>
<p>Parfait, nous sommes presque prêts à calculer la mortalité ! Notez qu’à l’heure actuelle, nos valeurs pour le temps-personne sont représentées sous forme de différence de temps (classe <code>difftime</code>) en nombre de jours. Pour la suite de nos calculs, il serait préférable que ce soit un type numérique simple.</p>
<div class="write">
<p>Ajoutez une dernière étape dans votre pipeline de temps-personne qui convertit <code>pt</code> en un type numérique à l’aide de <code>as.numeric()</code>.</p>
</div>
</section>
<section id="calculs-de-mortalité-1" class="level3">
<h3 class="anchored" data-anchor-id="calculs-de-mortalité-1">Calculs de mortalité</h3>
<p>Nous sommes (enfin) prêts à calculer les taux de mortalité. Nous pourrions effectuer un calcul de base directement à partir du nombre total de décès et du temps cumulé passé à risque :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(df<span class="sc">$</span>died <span class="sc">==</span> <span class="st">"Oui"</span>) <span class="sc">/</span> <span class="fu">sum</span>(df<span class="sc">$</span>pt, <span class="at">na.rm =</span> <span class="cn">TRUE</span>) <span class="sc">*</span> <span class="dv">10000</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5405712</code></pre>
</div>
</div>
<div class="look">
<p>Comment interpréteriez-vous ce taux de mortalité ? Est-il élevé ? <br><br> En 2010, le taux de mortalité de référence en Haïti était de 9 décès pour 1 000 personnes-années. Sachant cela, calculez la <strong>surmortalité</strong> observée pendant cette épidémie (exprimée en décès supplémentaires pour 10 000 personnes-jours). <br><br> <strong>Indice</strong>. Commencez par convertir le taux de référence en décès pour 10 000 jours-personnes.</p>
</div>
<p>Jusqu’ici tout va bien, mais nous n’avons n’avons pas inclus d’intervalles de confiance dans notre calcul et nous n’avons pas non plus pris en compte la conception de notre enquête. Pour ce faire, nous allons utiliser le package <code>{srvyr}</code>. Ce package a été conçu pour l’analyse complexe des données d’enquête et fournit des méthodes statistiques permettant d’ajuster l’effet de conception et la taille finie de la population. Une discussion approfondie de l’effet de conception et de la manière de l’ajuster dépasse le cadre de cette leçon, mais, en substance, les effets de conception apparaissent lorsque nous utilisons un processus d’échantillonnage qui n’est pas entièrement aléatoire . Par exemple, l’utilisation de l’échantillonnage en grappes dans cette enquête crée un effet de conception, car on peut s’attendre à ce que les personnes d’une même grappe soient plus similaires entre elles qu’elles ne le sont par rapport à d’autres personnes sélectionnées au hasard dans la population. Lorsque nous ajustons l’effet de conception, nous élargissons nos intervalles de confiance (nous réduisons notre précision) afin de tenir compte de cette similitude non aléatoire.</p>
<p>Pour effectuer ces ajustements, <code>{srvyr}</code> a besoin de connaître quelques informations :</p>
<ul>
<li>L’identifiant des unités d’échantillonnage nécessitant un ajustement (dans ce cas, les identifiants des grappes)</li>
<li>La taille de la population (nécessaire pour résoudre à la fois l’effet de conception et tenir compte de la taille finie de la population)</li>
<li>Le poids de chaque grappe</li>
</ul>
<p>Le poids de la grappe est le produit de deux fractions :</p>
<ol type="1">
<li>Taille totale de la population / taille de l’échantillon <strong>et</strong></li>
<li>Cluster attendu / taille réelle du cluster donné</li>
</ol>
<p>En principe, chacun de nos clusters aurait dû compter 32 ménages. Dans la pratique, la taille réelle des clusters a pu s’écarter dans certains cas. Nous pouvons utiliser la fonction <code>n_distinct()</code> dans <code>summarize()</code> pour ajouter une colonne avec la taille réelle du cluster associé à chaque individu :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>df <span class="sc">|&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">.by =</span> clst_id,</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">hh_count =</span> <span class="fu">n_distinct</span>(hh)) <span class="sc">|&gt;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  clst_id hh_count
1       1       32
2       2       32
3       3       32
4       4       32
5       5       32
6       6       32</code></pre>
</div>
</div>
<div class="write">
<p>Créez une nouvelle section de votre code intitulée ‘Calculer la mortalité’. Écrivez un tuyau qui utilise l’instruction summarize ci-dessus pour calculer le nombre de ménages observés par cluster, puis utilisez <code>mutate()</code> pour ajouter les colonnes <code>weight</code> et <code>pop</code> contenant respectivement les poids et la taille totale de la population (en 2010, celle-ci était de 228 425 personnes). Stockez la sortie de ce tuyau dans un objet appelé <code>df_wt</code>. La tête de <code>df_wt</code> devrait ressembler à ceci :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  clst_id hh_count   weight    pop
1       1       32 12.38546 228425
2       2       32 12.38546 228425
3       3       32 12.38546 228425
4       4       32 12.38546 228425
5       5       32 12.38546 228425
6       6       32 12.38546 228425</code></pre>
</div>
</div>
<p><strong>Astuce</strong>. La formule pour <code>weight</code> est <code>(population_size / sample_size) * (32 / hh_count)</code>. <br><br> Maintenant, utilisez <code>left_join()</code> pour joindre les données de poids et de population nouvellement créées à <code>df</code>. La tête de <code>df</code> devrait maintenant ressembler à ceci :</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Joining with `by = join_by(clst_id)`</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>     sex age born_date joined_date left_date died_date born joined left died
1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non
        died_cause hh interview_date clst_id present consent  pt hh_count
1 N'est pas décédé  1     2011-03-29       1       1       1 163       32
2 N'est pas décédé  1     2011-03-29       1       1       1 163       32
3 N'est pas décédé  1     2011-03-29       1       1       1 163       32
4 N'est pas décédé  1     2011-03-29       1       1       1 163       32
5 N'est pas décédé  1     2011-03-29       1       1       1 163       32
6 N'est pas décédé  1     2011-03-29       1       1       1 163       32
    weight    pop
1 12.38546 228425
2 12.38546 228425
3 12.38546 228425
4 12.38546 228425
5 12.38546 228425
6 12.38546 228425</code></pre>
</div>
</div>
</div>
<p>Pour que <code>{srvyr}</code> utilise nos variables nouvellement ajoutées et effectue des calculs, nous devons créer un ‘objet d’enquête’. Il s’agit d’une classe spéciale de dataframe spécifique à <code>{srvyr}</code> et créée à l’aide de la fonction <code>as_survey_design()</code> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>tmp <span class="ot">&lt;-</span> df <span class="sc">|&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_survey_design</span>(</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">ids =</span> clst_id,</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">wt =</span> weight,</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">fpc =</span> pop</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="look">
<p>Essayez d’exécuter le code ci-dessus. Quelle est la classe de <code>tmp</code> ? Cet objet se comporte-t-il comme un cadre de données normal ? Essayez d’effectuer quelques manipulations de base, par exemple :</p>
<ul>
<li>Extrayez les données de la colonne ‘age’</li>
<li>Filtrez pour ne voir que les personnes décédées</li>
</ul>
</div>
<p>Comme vous pouvez le constater, une fois que nous avons appliqué <code>as_survey_design()</code>, nous n’avons plus de dataframe normal. Nous devons donc <strong>stocker son résultat dans un objet séparé</strong>, par exemple <code>tmp</code> ou <code>df_srvy</code>. Cela garantit que <code>df</code> reste un dataframe standard disponible pour d’autres calculs, visualisations, etc.</p>
<p><code>{srvyr}</code> offre un certain nombre de fonctions permettant de calculer des indicateurs à partir des données d’enquête, la plupart du temps utilisées <span class="hovertip" data-bs-toggle="tooltip" data-bs-title="En effet, ces indicateurs impliquent généralement une **agrégation** des données.">à l’intérieur d’une fonction <code>summarize()</code></span>. Dans notre cas, nous utiliserons la fonction <code>survey_ratio()</code> pour calculer les taux de mortalité bruts et spécifiques. La syntaxe de base de <code>survey_ratio()</code> est assez simple. Par exemple, nous pouvons utiliser ce qui suit pour calculer le taux de mortalité brut :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 4
    cmr cmr_low cmr_upp cmr_deff
  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
1 0.531   0.405   0.656     2.28</code></pre>
</div>
</div>
<p>C’est assez simple, mais analysons les arguments :</p>
<ul>
<li><code>numerator</code> est le numérateur de notre ratio, dans ce cas le nombre de personnes décédées (individus pour lesquels <code>died</code> était <code>"Oui"</code>) multiplié par 10 000 (pour obtenir un résultat final en 10 000 jours-personnes)</li>
<li><code>denominator</code> est le dénominateur de notre ratio, dans ce cas le nombre de personnes-jours à risque (<code>pt</code>)</li>
<li><code>vartype</code> toute variable que nous voulons inclure pour estimer l’erreur, ici nous avons choisi l’intervalle de confiance (<code>"ci"</code>) mais nous pourrions également demander l’erreur type (<code>"se"</code>)</li>
<li><code>deff</code> indique si nous voulons inclure une estimation de l’effet de conception</li>
<li><code>na.rm</code> indique si <code>{srvyr}</code> doit ignorer les valeurs manquantes lors du calcul</li>
</ul>
<p>Le résultat de ce code est un nouveau cadre de données avec notre estimation ponctuelle (<code>cmr</code>), l’intervalle de confiance (<code>cmr_low</code> et <code>cmr_upp</code>) et l’effet de conception associé.</p>
<div class="write">
<p>Dans l’exemple ci-dessus, nous avons calculé la mortalité brute. Comme cette enquête est associée à une épidémie particulière (de choléra), nous pourrions également nous intéresser à la mortalité spécifique à la maladie attribuable à la diarrhée. En utilisant le code de mortalité brute comme modèle, écrivez un code pour calculer le taux de mortalité spécifique à la diarrhée. Vous devriez obtenir les résultats suivants :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 4
   dsmr dsmr_low dsmr_upp dsmr_deff
  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
1 0.369    0.257    0.482      2.64</code></pre>
</div>
</div>
<p>Nous souhaitons également calculer le taux de mortalité des moins de 5 ans. Dans ce cas, nous calculons la mortalité brute sur le <strong>sous-ensemble</strong> de notre population âgé de moins de 5 ans, c’est-à-dire que nous devons filtrer notre cadre de données pour ne conserver que les enfants de moins de 5 ans. Écrivez du code pour calculer la mortalité des moins de 5 ans, en gardant à l’esprit que vous devrez filtrer avant de créer votre objet de conception d’enquête. Vous devriez obtenir le résultat suivant :</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 4
   u5mr u5mr_low u5mr_upp u5mr_deff
  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
1 0.677    0.363    0.990      1.14</code></pre>
</div>
</div>
<p>Comment interpréteriez-vous tous les taux de mortalité ci-dessus ? Prenez une minute pour décrire comment vous pourriez présenter ces résultats. Y a-t-il d’autres indicateurs que vous aimeriez calculer pour une analyse plus complète ?</p>
</div>
</section>
</section>
<section id="cest-terminé" class="level2">
<h2 class="anchored" data-anchor-id="cest-terminé">C’est terminé !</h2>
<p>Bravo, vous avez maintenant appris à importer, nettoyer et calculer les taux de mortalité à partir de données d’enquête de base sur la mortalité.</p>
<div class="cell">
<div class="cell-output-display">
<a href="https://github.com/epicentre-msf/repicentre/blob/main/solutions/companion/survey_solutions.R">
<button class="btn btn-default"><i class="fa fa-save"></i> Solutions</button>
</a>
</div>
</div>
</section>
<section id="aller-plus-loin" class="level2">
<h2 class="anchored" data-anchor-id="aller-plus-loin">Aller plus loin</h2>
<section id="exercices-supplémentaires" class="level3">
<h3 class="anchored" data-anchor-id="exercices-supplémentaires">Exercices supplémentaires</h3>
<ol type="1">
<li><p>Précédemment, nous avons calculé le <strong>taux de mortalité excédentaire</strong>, c’est-à-dire la différence entre la mortalité observée et la mortalité de référence. Un autre indicateur que nous présentons souvent est le nombre de <strong>décès excédentaires</strong> observés pendant la période de rappel. Comment le calculeriez-vous ?</p></li>
<li><p>Utilisez <code>{ggplot2}</code> pour créer un graphique à barres représentant les décès au fil du temps.</p></li>
<li><p>Consultez la documentation relative à <code>{srvyr}</code> et voyez si vous pouvez utiliser <code>survey_mean()</code> pour calculer la mortalité proportionnelle par cause de décès.</p></li>
<li><p>Utilisez <code>{gt}</code> pour créer un tableau attrayant présentant les données de mortalité proportionnelle que vous avez générées ci-dessus.</p></li>
<li><p>Dans la section consacrée au nettoyage, nous avons corrigé les cas où une personne était née pendant la période de rappel mais avait un âge &gt; 0. Comment cela aurait-il pu être évité avec une contrainte Kobo ?</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>