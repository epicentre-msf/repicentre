[
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html",
    "href": "sessions_core/04_data_verbs_conditional.html",
    "title": "Recoder les variables et filtrer les observations",
    "section": "",
    "text": "Dans la session précédente vous avez appris les bases du traitement de données en R avec les fonctions du {tidyverse}, en particulier comment sélectionner et modifier les colonnes d’un data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre à :\n\nécrire des conditions logiques basiques, ce qui va nous permettre de :\nsélectionner des lignes d’un data frame avec filter()\nrecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "href": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "title": "Recoder les variables et filtrer les observations",
    "section": "",
    "text": "Dans la session précédente vous avez appris les bases du traitement de données en R avec les fonctions du {tidyverse}, en particulier comment sélectionner et modifier les colonnes d’un data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre à :\n\nécrire des conditions logiques basiques, ce qui va nous permettre de :\nsélectionner des lignes d’un data frame avec filter()\nrecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "href": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "title": "Recoder les variables et filtrer les observations",
    "section": "Mise en place",
    "text": "Mise en place\nPrérequis : cette leçon part du principe que vous connaissez les bases de la manipulation de données avec {dplyr}, et en particulier la fonction mutate(). Aller vous rafraîchir si besoin.\n\nNous utiliserons la liste linéaire avec les données brutes qui peut être téléchargée ici :\n\n\n\n Télécharger les données\n\n\n\n Si ce n’est pas déjà fait, enregistrez la dans le sous-dossier approprié de votre projet RStudio puis créez un nouveau script appelé filtrer_recoder.R dans votre sous-dossier R. Ajoutez un en-tête approprié et chargez les paquets suivants : {here}, {rio} et {tidyverse}.  Enfin, ajoutez une section dédiée à l’import des données, utilisez {here} et {rio} pour importer vos données dans R, et assignez-les à un objet que nous appellerons df_brut"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#filtrer-des-données-avec-des-conditions-logiques",
    "href": "sessions_core/04_data_verbs_conditional.html#filtrer-des-données-avec-des-conditions-logiques",
    "title": "Recoder les variables et filtrer les observations",
    "section": "Filtrer des données avec des conditions logiques",
    "text": "Filtrer des données avec des conditions logiques\nNous avons appris précédemment comment comment sélectionner les colonnes d’un data frame. Nous allons à présent apprendre la tâche complémentaire, qui est la sélection des lignes d’un data frame. C’est une tâche particulièrement courante du travail d’épidémiologiste qui permet de sélectionner des observations qui satisfont à certains critères. Le paquet {dplyr} possède bien évidement une fonction pour ça, la fonction filter().\nAvant de pouvoir l’utiliser nous allons néanmoins devoir apprendre à écrire des conditions logique, qui sont également un prérequis pour recoder des variables. Les conditions logiques sont des questions (ou tests) auxquelles R va répondre par TRUE ou FALSE (ou NA).\n\nEgalité\nLa syntaxe de filter() est assez simple :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition_logique])\n\nCette syntaxe permet de conserver les lignes où condition_logique est vraie. Ici, la condition logique va demander si quelque chose est égale à autre chose. Par exemple, si telle variable est égale à telle valeur (est ce que patient a été hospitalisé ?). En R, nous testons l’égalité avec l’opérateur ==.\nEn pratique, pour créer un filtre qui ne garde que les patients hospitalisés nous écrivons :\n\ndf_brut |&gt;\n  filter(hospitalisation == \"oui\")\n\nIci, filter() parcourt chaque ligne de notre data frame et teste si la valeur d’hospitalisation dans cette ligne est égale à \"oui\". La fonction ne renvoie alors que les lignes où la réponse à la question est TRUE [vrai].\n\nFiltrez vos données pour ne conserver que les patients qui avaient de la fièvre (c’est à dire les patients contenant la valeur \"Yes\" dans la colonne fievre. Le début de la colonne fievre dans la sortie filtrée est :\n\n\n  fievre\n1    Yes\n2    Yes\n3    Yes\n4    Yes\n5    Yes\n6    Yes\n\n\nInspectez la sortie et df_brut. Pourquoi df_brut contient-il encore les patients qui n’avaient pas de fièvre ?\n\n\n\nInégalité\nParfois, nous préférons tester l’inégalité plutôt que l’égalité ; pour examiner les patients qui ne se sont pas rétablis, par exemple, qu’ils soient décédés ou sorti contre avis médical. Dans ce cas nous utiliserons l’opérateur !=, ce qui donne ce code :\n\ndf_brut |&gt;\n  filter(issue != 'gueri') # Garde les lignes avec patients NON guéris\n\n\nFiltrez votre data frame pour ne montrer que les patients qui n’ont pas de carte confirmant leur statut vaccinal. Le début de la colonne filtrée ressemble à :\n\n\n  statut_vaccinal\n1             Non\n2             Non\n3             Non\n4             Non\n5             Non\n6             Non\n\n\nAstuce : Rappelez-vous que vous pouvez utiliser count() pour vérifier les modalités de statut_vaccinal.\n\n\n\nSupérieur à / Inférieur à\nDans le cas des variables numériques, on sera souvent intéressé par savoir si une valeur est supérieure ou inférieure à un seuil. Par exemple, quels sont les patients de moins de 5 ans. Ici, nous utiliserons les opérateurs &lt; et &gt; pour évaluer si une variable est inférieure à ou supérieure à une valeur donnée, respectivement.\nNous pouvons par exemple filtrer les patients de moins de 60 mois :\n\ndf_brut |&gt;\n  filter(age &lt; 60)\n\n\nAffichez un data frame ne contenant que les patients souffrant de malnutrition aiguë sévère. Le début de la colonne concernée est :\n\n\n    pb\n1  244\n2  232\n3  123\n4  210\n5   80\n6  220\n7  152\n8  155\n9  232\n10 135\n\n\nEcrivez un autre filtre qui sélectionne les patients âgés de plus de 15 ans. L’en-tête de votre colonne d’âge doit ressembler à ceci :\n\n\n  age\n1 348\n2 348\n3 312\n4 432\n5 444\n6 324\n\n\n\nSi nous ne voulons pas l’égalité stricte nous pouvons ajouter un signe égal aux opérateurs précédents, ce qui donne &lt;= pour “inférieur ou égal à” et &gt;= pour “supérieur ou égal à”. Attention, le = doit venir après les opérateurs &lt; et &gt;, pas avant.\nPour filtrer les patients avec 10 ans ou moins :\n\ndf_brut |&gt;\n  filter(age &lt;= 120)\n\n\nSélectionnez tous les patients avec un état nutritionnel normal, c’est-à-dire les patients dont le PB est supérieur ou égal à 125mm. L’en-tête du pb devrait ressembler à ceci :\n\n\n    pb\n1  244\n2  232\n3  210\n4  220\n5  152\n6  155\n7  232\n8  135\n9  146\n10 202\n\n\n\n\n\nConditions multiples\nIl est possible de combiner plusieurs conditions logiques dans un même filtre ! Il suffit de séparer plusieurs conditions logiques par une virgule.\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition 1],\n         [condition 2],\n         [condition 3])\n\nPar exemple, nous pourrions sélectionner tous les patients hospitalisés de moins de cinq ans :\n\ndf_brut |&gt;\n  filter(age &lt; 5,\n         hospitalisation == \"oui\")\n\n\nCréez un filtre qui sélectionne tous les patients de la sous-préfecture de Koumra hospitalisés et sévèrement malnutris Cela donne :\n\n\n    id sous_prefecture hospitalisation  pb\n1 8624          KOUMRA             oui 103\n2 8939          KOUMRA             oui  67\n3 9957          KOUMRA             oui  71\n\n\nIndice :  if faut une condition sur le statut d’hospitalisation, une sur la sous-préfecture et une sur le PB.\n\n\n\nRésumé des conditions logiques\nNous avons fait le tour des conditions logiques les plus basiques en R. Les voici rassemblées dans un tableau pour références futures :\n\n\n\nCondition\nR\n\n\n\n\nA identique à B ?\nA == B\n\n\nA pas identique à B ?\nA != B\n\n\nA supérieur à B ?\nA &gt; B\n\n\nA supérieur ou égal à B ?\nA &gt;= B\n\n\nA inférieur à B ?\nA &lt; B\n\n\nA inférieur ou égal à B ?\nA &lt;= B"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "href": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "title": "Recoder les variables et filtrer les observations",
    "section": "Recoder des variables avec case_when()",
    "text": "Recoder des variables avec case_when()\nL’utilité des conditions logiques dans le traitement de données va bien plus loin que la sélection de lignes ! Elles sont par exemple très utiles quand nous voulons recoder des variables. Nous utiliserons les conditions logiques à l’intérieur de la fonction case_when() (également du paquet {dplyr}) pour recoder les variables.\nLa fonction case_when() est un peu plus complexe que ce que l’on a vu jusqu’à présent, mais très puissante (et va donc vous être très utile). Nous allons décomposer sa syntaxe pas à pas.\nVous utiliserez presque toujours case_when() dans un mutate() pour recoder une variable existante ou en créer une nouvelle, avec cette syntaxe :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  mutate(nouvelle_colonne = case_when(\n    [condition_1] ~ [valeur_si_condition_1_est TRUE],\n    [condition_2] ~ [valeur_si_condition_2_est TRUE],\n    .défaut = [valeur_par_défaut]))\n\nDécomposons-la commande.\nA l’exception de la dernière ligne, chaque ligne à l’intérieur de la fonction case_when() a le format suivant :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n[condition] ~ [valeur si condition est VRAIE]  # Les crochets sont là pour la lisibilité\n\nAinsi, pour recoder les patients avec un PB inférieur à 110mm comme \"MAS\", nous écrivons la commande suivante dans notre case_when() :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n# [condition] ~ [valeur si VRAIE]\n   pb &lt; 110   ~ \"MAS\"\n\nIl y a en général plus d’une condition ! Dans notre exemple, une autre condition logique testerait si le patient est modérément malnutri avec l’instruction pb &lt; 125 ~ \"MAM\".\nLa dernière ligne de notre pseudo code contient l’argument .default et sert à fournir la valeur à utiliser lorsqu’aucune des conditions n’est remplie. Dans notre exemple, ça pourrait être \"Normal\".\nPour résumer, pour résumer, pour créer une variable contenant le statut nutritionnel à partir du PB :\n\ndf_brut |&gt;\n  mutate(malnut = case_when(\n    pb &lt; 110 ~ \"MAS\",\n    pb &lt; 125 ~ \"MAM\",\n    .default = \"Normal\"))\n\n\nExécutez le code ci-dessus pour créer une variable malnut contenant le statut nutritionnel des patients. Le haut des deux colonnes concernées renvoie :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAS\n6 220 Normal\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nL’ordre des conditions logiques est important ! case_when() teste les conditions dans l’ordre que vous lui donnez et attribue une valeur dès qu’une condition est TRUE.\nAinsi, dans l’exemple ci-dessus, case_when() pose ces questions suivantes dans l’ordre :\n\nEst-ce que pb &lt; 110 pour ce patient ? Si oui, attribuer la valeur \"MAS\"\nSi le patient n’est pas MAS, est-ce que pb &lt; 125 ? Si oui, attribuer la valeur \"MAM\"\nSi aucune des conditions précédentes n’est vraie, attribuer la valeur \"Normal\"\n\n\n\n\nIntervertissez l’ordre des deux premières conditions dans le case_when()précédent (pb &lt; 125 testé en premier). Le haut des deux colonnes concernées est maintenant :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAM\n6 220 Normal\n\n\nVous pouvez enregistrer le data frame crée dans un objet temporaire temp pour l’inspecter plus facilement. Où sont les patients MAS ? Comprenez-vous ce qui s’est passé ?\n\n\n\n\n\n\n\nNote\n\n\n\nL’argument .default dans case_when() n’est pas obligatoire. Si vous ne l’incluez pas, case_when() utilisera la valeur NA par défaut.\n\n\nDans notre exemple, nous avons utilisé case_when() pour créer une variable catégorique (le statut nutritionnel) à partir d’une variable continue (le PB). Un autre exemple typique et similaire est de créer une colonne contenant les classes d’âge.\n\nUtilisez case_when() pour créer une variable groupe_age avec les catégories suivantes :\n\n\"&lt; 5 Ans\"\n\"5 - 15 Ans\"\n\"&gt; 15 Ans\".\nsi l’âge est manquant, attribuer la valeur \"Inconnu\".\n\nFaites attention à l’ordre ! L’en-tête des colonnes concernées doit ressembler à ceci :\n\n\n   age  age_group\n1   36    &lt; 5 Ans\n2    5    &lt; 5 Ans\n3  156 5 - 15 Ans\n4    8    &lt; 5 Ans\n5    7    &lt; 5 Ans\n6    4    &lt; 5 Ans\n7    2    &lt; 5 Ans\n8   48    &lt; 5 Ans\n9  156 5 - 15 Ans\n10 348   &gt; 15 Ans\n\n\n\n\nL’opérateur %in%\nNous savons maintenant recoder les variables en catégories, ce qui vous arrivera très souvent en épidémiologie. Un autre cas d’usage majeur est d’utiliser case_when() pour standardiser les valeurs d’une variable.\n\nUtilisez count() pour inspecter les variables catégorielles de votre jeu de données. Lesquelles devraient être standardisées ?\n\nVous avez dû voir que la variable sexe présente quelques problèmes d’encodage. Par exemple, les patientes sont codées comme f, female et femme. Utilisons case_when() pour recoder cette variable. Ici, nous ne créerons pas une nouvelle variable, mais remplacerons la variable existante :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(sexe == \"f\"      ~ \"Femme\",\n                          sexe == \"female\" ~ \"Femme\",\n                          sexe == \"femme\"  ~ \"Femme\",\n                          sexe == \"h\"      ~ \"Homme\",\n                          sexe == \"male\"   ~ \"Homme\",\n                          sexe == \"homme\"  ~ \"Homme\",\n                          .default = \"Inconnu\"))\n\nCe code fonctionne correctement mais est terriblement répétitif et verbeux. Heureusement il y a un raccourci pour lister toutes les options à réaffecter à “Femme” (et celles à “Homme”), l’opérateur %in% ! L’opérateur %in% permet de tester la condition “est ce que la valeur existe dans ce vecteur ?”.\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n[valeur] %in% [vector_des_options]\n\nAinsi, par exemple, nous pourrions vérifier si la valeur “f” est dans les options “f” et “femme” :\n\n\"f\" %in% c(\"f\", \"femme\")\n\n\nExécutez l’instruction ci-dessus. Quel est le type de données de votre résultat ?\n\nLa commande renvoie un bolléen, c’est-à-dire un résultat logique. C’est donc une condition logique valide à utiliser dans un case_when() (ou un filter()) ! On peut donc simplifier notre code :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(\n    sexe %in% c(\"f\", \"female\", \"femme\") ~ \"Femme\",\n    sexe %in% c(\"h\", \"male\", \"homme\") ~ \"Homme\",\n    .default = \"Inconnu\"))\n\nC’est plus court comme ça…\n\nUtilisez case_when() et l’opérateur %in% pour créer une nouvelle colonne vacc_status_strict qui a la valeur :\n\n\"Oui\" si le statut vaccinal est confirmé\n\"Non\" pour les cas non vaccinés\n\n\"Non vérifié\" sinon.\n\nLa tête de la nouvelle colonne ressemble à ceci :\n\n\n  statut_vaccinal statut_vaccinal_strict\n1            &lt;NA&gt;            Non vérifié\n2             Non                    Non\n3      Oui - oral            Non vérifié\n4             Non                    Non\n5             Non                    Non\n6             Non                    Non"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-données",
    "href": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-données",
    "title": "Recoder les variables et filtrer les observations",
    "section": "Pipeline de nettoyage des données",
    "text": "Pipeline de nettoyage des données\nMaintenant que vous savez utiliser les conditions logiques pour recoder colonnes avec case_when(), nous pouvons reprendre le pipeline de nettoyage que nous avions commencé dans la session précédente.\n\nReprenez, le code de la session précédente, amendez-le et complétez le pour créer un gros pipeline de nettoyage des données, qui crée un data frame df_linelist en effectuant les opérations suivantes :\n\nSupprimer les variables nom_complet et unite_age\nRenommer les variables suivantes :\n\nage devient age_ans\nsous_prefecture devient prefecture\nvillage_commune devient village\nnom_structure_sante devient structure\n\nAjouter une variable age_ans avec l’âge du patient en années\nMettre à jour region et prefecture pour utiliser la casse de titre\nMettre à jour toutes les colonnes contenant des dates pour utiliser le type Date\nCréer une nouvelle variable groupe_age avec les groupes &lt; 6 mois, 6 - 11 mois, 12 - 59 mois, 5 - 15 ans et &gt; 15 ans (les patients dont l’âge est inconnu sont Inconnu)\nRecoder le sexe pour n’avoir que les valeurs : Femme, Homme et Inconnu\n\nSupprimer toutes les lignes en double\n\nLe début de vos données finales devrait ressembler à ceci :\n\n\n  id  sexe age_mois  region prefecture        village date_debut\n1  1 Femme       36 Mandoul   Moissala Sangana Koïtan 2022-08-13\n2  2 Femme        5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3 Femme      156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 Homme        8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7 Homme        7 Mandoul   Moissala      Tétindaya 2022-08-30\n6 10 Homme        4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             oui     2022-08-14\n2        2022-08-25             oui     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25             non           &lt;NA&gt;\n5        2022-09-02             non           &lt;NA&gt;\n6        2022-09-02             oui     2022-09-02\n                        structure tdr_paludisme fievre eruption toux\n1 Hôpital du District de Moissala       negatif     No     &lt;NA&gt;  Yes\n2 Hôpital du District de Moissala       negatif     No       No  Yes\n3                      CS Silambi       negatif    Yes     &lt;NA&gt;   No\n4 Hôpital du District de Moissala       negatif     No       No   No\n5                      CS Silambi       negatif   &lt;NA&gt;       No  Yes\n6                    Moissala Est       negatif    Yes       No   No\n  yeux_rouges pneumonie encephalite  pb statut_vaccinal doses_vaccin issue\n1          No        No          No 244            &lt;NA&gt;         &lt;NA&gt; gueri\n2          No      &lt;NA&gt;          No 232             Non         &lt;NA&gt;  &lt;NA&gt;\n3          No        No        &lt;NA&gt; 123      Oui - oral         &lt;NA&gt; gueri\n4        &lt;NA&gt;        No          No 210             Non         &lt;NA&gt; gueri\n5         Yes        No          No  80             Non         &lt;NA&gt; gueri\n6        &lt;NA&gt;        No          No 220             Non         &lt;NA&gt; gueri\n  date_issue    age_ans   groupe_age\n1 2022-08-18  3.0000000 12 - 59 mois\n2 2022-08-28  0.4166667     &lt; 6 mois\n3       &lt;NA&gt; 13.0000000   5 - 15 ans\n4       &lt;NA&gt;  0.6666667  6 - 11 mois\n5       &lt;NA&gt;  0.5833333  6 - 11 mois\n6 2022-09-03  0.3333333     &lt; 6 mois\n\n\n\nTop ! Nous pouvons maintenant exporter ce data frame (presque) propre hors de R. Pour cela nous utiliserons la fonction export() de {rio} (et notre fidèle compagnon, la fonction here() de {here} pour gérer les chemins d’accès) :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.xlsx'))\n\nNotez ici que nous plaçons nos données dans le sous-dossier clean dans data.\n\n\n\n\n\n\nAstuce\n\n\n\nEnregistrer les données au format .xlsx est utile pour pouvoir les ouvrir dans Excel pour les inspecter ou les partager. Cependant, nous préférerons souvent utiliser un fichier avec l’extension .rds. Ce type de fichier est spécifique à R et est plus robuste aux problèmes liés à l’encodage ou au formatage des dates que les fichiers de type .xlsx ou .csv.\nPour exporter votre data frame vers un fichier .rds, il suffit de modifier l’extension :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.rds')) # TADAM !"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "href": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "title": "Recoder les variables et filtrer les observations",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo. Lors des deux dernières sessions vous avez appris à utiliser les fonctions qui forment le socle du traitement de données, mais aussi les conditions logiques et comment organiser votre code en un pipeline de nettoyage !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "href": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "title": "Recoder les variables et filtrer les observations",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires"
  },
  {
    "objectID": "sessions_core/01_introduction.html",
    "href": "sessions_core/01_introduction.html",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCréer et exécuter un script\nCréer des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#objectifs",
    "href": "sessions_core/01_introduction.html#objectifs",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCréer et exécuter un script\nCréer des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#format-des-exercices",
    "href": "sessions_core/01_introduction.html#format-des-exercices",
    "title": "Introduction à R",
    "section": "Format des exercices",
    "text": "Format des exercices\nCes exercices sont dans un format tutoriel contenant de brèves explications sur les concepts clés, des exemples et des instructions à suivre. Notre approche est très orientée sur la pratique, et à l’exception de cette première session partiellement axée sur l’interface, vous aurez beaucoup d’occasions de coder.\nLes instructions pour les exercices seront données dans les formats suivants :\n\nCet encadré contient des instructions généralistes. Vous le trouverez en général au début d’une session, avec des instructions de mise en place.\n Exemple : Ouvrez un script vide et nommez-le mon_premier_script.R.\n\n\nCet encadré contient des instructions de code que vous devez écrire dans votre script ou la console.\n Exemple : Créez un objet region qui contient la valeur \"Mandoul\".\n\n\nCet encadré vous demande d’observer ou étudier quelque chose.\n Exemple : Inspectez l’interface de RStudio.\n\nAu cours de ces exercices, vous rencontrerez certainement des erreurs, qui se produisent lorsque R n’est pas en mesure d’exécuter une commande. Cela peut se produire pour de nombreuses raisons : une faute d’orthographe dans le nom d’un objet ou d’une fonction, le mauvais type de données fournis etc. Lorsqu’une erreur se produit, R arrête les calculs en cours et affiche un message expliquant ce qu’il s’est passé. Il est tout à fait normal d’avoir des erreurs, ça arrive tout le temps, à tous les programmeurs, qu’ils soient novices ou experts. Comme lorsque vous apprenez une langue (non informatique), vous vous améliorerez avec la pratique, en faisant des erreurs et en apprenant à les corriger."
  },
  {
    "objectID": "sessions_core/01_introduction.html#rstudio-et-r",
    "href": "sessions_core/01_introduction.html#rstudio-et-r",
    "title": "Introduction à R",
    "section": "RStudio et R",
    "text": "RStudio et R\nR est un langage de programmation fonctionnel qui peut être utilisé pour nettoyer et manipuler des données, effectuer des analyses (en particulier des analyses statistiques), visualiser des résultats, et bien plus encore.\nRStudio est un logiciel qui fournit une interface facile à utiliser pour R (également appelé IDE, pour “Integrated Development Environment”). Son utilisation n’est pas obligatoire, mais très fortement recommandée pour les débutants.\n\nPremiers pas avec RStudio\n\nOuvrez RStudio en utilisant le menu de démarrage de votre ordinateur ou le raccourci créé par défaut sur le bureau ; si RStudio était déjà ouvert, fermez-le et ouvrez-le à nouveau.\n\nVous devriez voir une interface qui ressemble à ceci :\n\n\n\nVue de l’interface de l’IDE Rstudio à l’ouverture\n\n\n\nInspectez l’interface de RStudio.\n\nVous verrez trois ou quatre panneaux.\n\nPanneau supérieur droit\nEn haut à droite se trouve un panneau avec plusieurs onglets. La plupart d’entre eux dépassent le cadre de ce cours, mais nous utiliserons les deux onglets suivants :\n\nEnvironment : liste les objets enregistrés par l’utilisateur dans la session en cours. Comme vous venez de démarrer une nouvelle session, votre environnement devrait être vide.\nHistory : comprend l’historique de toutes les commandes que vous avez exécutées au cours de la session actuelle.\n\n\n\n\n\n\n\nNote\n\n\n\nOuvrir une nouvelle session R, c’est comme redémarer son ordinateur : tout est vide et prêt pour le calcul, de la même manière qu’il n’y a aucun programme ouvert lorsque vous allumez votre ordinateur pour la première fois.\nNous vous encourageons à arrêter et à re-démarrer vos sessions R régulièrement. Parfois cela corrigera certains de vos problèmes !\n\n\n\n\nPanneau inférieur droit\nEn bas à droite se trouve un autre panneau comprenant les onglets suivants :\n\nFiles : un explorateur de fichiers pour le répertoire de travail, qui est l’emplacement du dossier dans lequel R travaille actuellement.\nPlots : là où RStudio affichera les graphiques statiques. Cet onglet devrait être vide pour le moment.\nPackages : liste de tous les paquets R installés sur votre ordinateur. Les paquets sont des collections de fonctions qui permettent d’étendre les fonctionnalités de R. Nous les aborderons plus en détail dans la prochaine leçon.\nHelp : un endroit pour lire les pages d’aide et la documentation pour les fonctions et les paquets.\nViewer : un emplacement où RStudio affichera des sorties html telles que des tableaux, des widgets interactifs ou même des tableaux de bord.\n\n\n\nPartie gauche\n\nA gauche (ou en bas à gauche si vous avez déjà quatre panneaux), vous devriez voir l’onglet console, où le code R est exécuté.\nEn haut à gauche (si vous avez quatre panneaux) se trouvent les scripts R ouverts.\n\n\n\n\nLa console\nLa console est l’endroit où le code R s’exécute.\nAu début d’une nouvelle session, un texte d’information sur votre cofiguration apparaît tout en haut de la console, dont le numéro et nom de la version de R. En dessous de ces informations, il y a une ligne avec le symbole &gt; et un curseur clignotant.\nPour exécuter une commande dans R, tapez-la à la suite du &gt; et pressez Entrée. R traitera alors votre code et affichera le résultat (s’il y en a un). Un nouveau &gt; s’affichera alors sur la ligne suivante, indiquant que la console est prête pour la commande suivante.\n\n\n\n\n\n\nImportant\n\n\n\nSi la dernière ligne est préfacée d’un + au lieu d’un &gt;, cela signifie que la console n’est pas prête. Soit elle attend qu’un calcul d’une commande précédente finisse, soit elle attend la fin d’une commande incomplète. A tout moment, vous pouvez interrompre l’exécution en pressant la touche Echap.\n\n\n\nExécutez les commandes suivantes dans la console, une ligne à la fois, et observez les résultats.\n\n5 + 90\n\n6 * 171\n\n189 / 36.6\n\n92^3\n\n(12 + 9)^4 / 1000\n\nExécutez maintenant la commande suivante. Notez que le ) fermant est manquant, ce qui rend la commande incomplète. Que se passe-t-il ?\n\n3 / (2 + 97\n\n\nVous avez peut-être noté dans les exemples précédents que notre code contient beaucoup d’espaces. C’est en effet une bonne pratique que d’inclure des espaces autour de la plupart des opérateurs, tels que +, -, *, /, &lt;, &gt;, = et &lt;-. Ces espaces facilitent la lecture et la compréhension de votre code, et dans certains cas (rares) ils permettent d’éviter des erreurs. Néanmoins, certains opérateurs ne doivent pas être entourés d’espaces, tels que ^, . et :.\n\n1+29+4.8/3*3           # Mauvais\n1 + 29 + 4.8 / 3 * 3   # Bien\n\n1 ^ 2  # Mauvais\n1^2    # Bien\n\nNous pouvons également exécuter des fonctions dans la console. Nous aborderons les fonctions plus en détail plus tard mais sachez que les fonctions dans R sont similaires aux fonctions dans Excel (telles que SOMME ou MOYENNE).\n\nExécutez les commandes suivantes dans la console (une ligne à la fois).\n\n# Trouvez la valeur minimale\nmin(5, 10)\nmin(1, 8, 56, 0.3)\n\n# Trouvez la valeur maximale\nmax(568, 258, 314)\n\n\n\n\nScripts\nLes scripts sont des fichiers texte qui contiennent une série de commandes pour un langage de programmation particulier. L’extension du fichier indique le langage dans lequel les commandes sont écrites. Ici nous utiliserons l’extension .R. Les scripts nous permettent de créer du code qui peut être réutilisé, partagé et même automatisé.\n\nÉcrire son premier script\nPour créer un nouveau script, allez dans le menu File &gt; New File &gt; R Script. Alternativement, cliquez sur la petite icône avec un + vert sur une page blanche située en dessous du menu File. Ou encore, utilisez le raccourci clavier CTRL + MAJ + N. Ce nouveau script non sauvegardé apparaîtra sous la forme d’un document vierge dans le panneau supérieur gauche.\n\n\n\nEtapes pour créer un nouveau script dans RStudio\n\n\nPour enregistrer votre script, utilisez le menu File &gt; Save As ou le raccourci clavier CTRL + S.\n\nCréez un script et enregistrez-le sous le nom decouverte.R(n’oubliez l’extension !). Pour l’instant, vous pouvez l’enregistrer sur votre bureau ou à tout autre endroit pratique, mais nous aborderons l’organisation des scripts dans la prochaine session.\n\n\n\nExécuter du code à partir d’un script\nPour exécuter du code à partir d’un script, placez votre curseur sur la ligne que vous souhaitez exécuter (ou sélectionnez plusieurs lignes) et effectuez l’une des opérations suivantes :\n\nCliquez sur le bouton Run en haut à droite de la fenêtre de script\nUtilisez le raccourci CTRL + Entrée (le curseur passera ensuite à la ligne suivante)\nUtiliser le raccourci ALT + Entrée (le curseur restera sur la ligne actuelle)\n\n\nCopiez le code que vous aviez exécuté dans la console lors des exercices précédents dans votre script et exécutez-le en testant les différentes méthodes ci-dessus.\nA partir de maintenant, vous écrirez votre code dans votre script et l’exécuterez à partir de là, sauf indication contraire de notre part.\n\n\n\nCommentaires\nDans R, le code qui est précédé d’un # (dièse) n’est pas exécuté, il est juste ignoré jusqu’à la fin de la ligne. C’est donc un bon moyen de documenter votre code.\n\n# Ceci est un commentaire\n\n2 + 3  # Ceci est aussi un commentaire\n\nIl est utile pour vous et vos collègues de commencer vos scripts par quelques lignes commentées fournissant des informations importantes sur le contenu de votre script.\n\n# IMPORT & PREPARATION DES DONNEES #\n# Auteure :  Mathilde Mousset\n# Date de création : 23/11/2024\n# Dernière mise à jour : 28/01/2024\n# Description : Importat et nettoyage des données de surveillance rougeole de Moissala\n\n\nAjoutez quelques commentaires au début de votre script pour le décrire.\n\nLes commentaires sont également un moyen pratique de diviser les scripts longs en sections thématiques, telles que “Import des données”, “Analyse”, “Visualisation”, etc. Par exemple :\n\n# NOM DE LA SECTION 1 -----------------------------------------------             \n\n# NOM DE LA SECTION 2 -----------------------------------------------             \n\n\nUtilisez les commentaires pour créer des sections dans votre script qui correspondent aux sections principales de ce tutoriel.\n\nEnfin, les commentaires permettent de prendre des notes sur votre code pour aider à la compréhension (celle de votre “moi futur” et celle de vos collègues). On entend souvent le conseil de se focaliser sur les commentaires qui expliquent le “pourquoi” plutôt que le “quoi”, car le “quoi” d’un code bien écrit devrait être clair.\nPar exemple, ce commentaire est superflu :\n\n1 + 3  # Code pour additionner un et trois\n\nEn comparaison, voici quelques cas où un commentaire est mérité :\n\nVous définissez une constante, une valeur seuil de séroprévalence par exemple. Ajoutez un commentaire indiquant la référence d’où provient la valeur.\nVotre code contient une valeur ou un nom de fichier qui doit être mis à jour chaque semaine. Indiquez le dans un commentaire afin que toute personne utilisant le code en soit informée.\nVous utilisez une commande contre-intuitive de premier abord, ou un paquet rare que votre collègue ne connaît peut-être pas. Commentez pour expliquer vos raisons.\n\nCeci étant dit, vous êtes en plein apprentissage, et les scripts que vous écrivez pendant ce cours sont l’équivalent de vos notes de cours, alors n’hésitez pas à utiliser autant de commentaires que vous le souhaitez pour expliquer les commandes et vous rappeler de ce qu’elles font. Vous écrirez naturellement moins de commentaires avec la pratique, lorsque les choses qui nouvelles aujourd’hui deviendront naturelles.\n\n\n\n\n\n\nAstuce\n\n\n\nCommentez une ligne sélectionnée avec le raccourci CTRL + MAJ + C.\nAjoutez une section de premier niveau avec CTRL + MAJ + R.\n\n\n\nAjoutez quelques commentaires pour décrire le code que vous avez écrit jusqu’à présent dans votre script."
  },
  {
    "objectID": "sessions_core/01_introduction.html#types-de-données",
    "href": "sessions_core/01_introduction.html#types-de-données",
    "title": "Introduction à R",
    "section": "Types de données",
    "text": "Types de données\nR dispose de plusieurs types de données. Ceux que nous verrons le plus souvent dans ce cours sont les suivants :\n\nnumérique [numeric en anglais]\nchaîne de caractères (texte) [string en anglais]\nbooléen (VRAI / FAUX) [boolean en anglais]\ndate [date]\nfacteur [factor]\n\n\nNumérique\nLe type numérique englobe les entiers [integers en anglais] et les doubles (nombres décimaux). Les nombres en R n’ont pas de signalétique, tapez simplement la valeur brute dans votre script ou votre console.\n\n\nChaînes de caractères\nLes chaînes de caractères [strings] représentent le texte en R. Elles sont tapées en entourant votre texte de guillemets simples ou doubles, \"district\" ou 'cas' par exemple (les guillemets doubles sont généralement considérés comme la meilleure pratique).\n\nComparez la sortie dans la console pour les commandes suivantes :\n\n28         # numérique\n\"28\"       # texte\n28 + \"28\"  # donne une erreur\n\n\nLa dernière commande ci-dessus a renvoyé une erreur car nous ne pouvons pas effectuer d’opérations arithmétiques combinant du texte et des nombres.\n\n\n\n\n\n\nImportant\n\n\n\nR est sensible à la casse (majuscules ou minuscules), ce qui signifie que \"ABC\" n’est pas équivalent à \"abc\".\n\n\n\nSi vous souhaitez créer une chaîne de caractères contenant des guillemets, il faut échapper les guillements les faisant précéder d’un \\. Par exemple : \"Elle dit \\\"Bonjour\\\" et s'en alla\" ou 'C\\'est une belle journée'. Si vous avez utilisé des guillements doubles pour créer votre chaîne de caractères, vous pouvez utiliser des guillemets simples à l’intérieur de celle-ci (par exemple : \"C'est une belle journée\") et vice versa (par exemple : 'Elle dit \"Bonjour\" et s'en alla').\n\n\n\nBooléen (logique)\nLe type booléen (ou logique) stocke des valeurs vrai/faux et est créé en écrivant soit TRUE [VRAI] ou FALSE [FAUX] sans guillemets.\nEn interne, R traduit TRUE et FALSE en équivalents numériques 1 et 0 respectivement, ce qui peut être utile pour des opérations arithmétiques.\n\n\n\n\n\n\nNote\n\n\n\nVous verrez peut-être des personnes qui utilisent T ou F mais c’est déconseillé car T et F peuvent également être utilisés comme noms d’objets ou de variables. En revanche, les valeurs TRUE et FALSE sont réservées (protégées), ce qui signifie qu’elles ne peuvent pas être réaffectés à une autre valeur.\n\n\n\n\nDéterminer le type d’un objet\nIl existe plusieurs fonctions permettant de déterminer le type d’un objet (souvent appelé la classe de l’objet en R [class].\n\nTapez les commandes suivantes dans votre script et exécutez-les :\n\n# Obtenir le type\nclass(28)  \nclass(\"Mandoul\")\n\n# Test du type\nis.numeric(28)\nis.numeric(\"Mandoul\")\nis.character(\"Mandoul\")\n\nis.numeric(TRUE)\nis.character(TRUE)\nis.logical(FALSE)"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-assignement-operator",
    "href": "sessions_core/01_introduction.html#sec-assignement-operator",
    "title": "Introduction à R",
    "section": "Enregistrer un objet",
    "text": "Enregistrer un objet\nEn R, presque tout est un objet y compris les fonctions, les vecteurs et les structures plus complexes. Souvent, nous souhaitons réutiliser certains objets tout au long d’un script (un jeu de données par exemple). Il est donc très utile de les stocker dans notre environnement (la mémoire de R). Pour ce faire, nous utilisons l’opérateur d’assignation &lt;-.\n\nRegardez le panneau environnement en haut à droite. Il devrait être vide. Tapez la commande suivante dans votre script et exécutez-la. Elle enregistre une variable appelée cas dans votre environnement.\n\ncas &lt;- 28\n\nInspectez à nouveau l’environnement. Est-il toujours vide ?\n\nSi vous souhaitez accéder à la valeur de votre nouvel objet, cas il vous suffit d’exécuter son nom.\n\ncas\n\n[1] 28\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous écrivons les chaînes de caractères entre guillements pour permettre à R de faire la différence entre un objet cas et le texte \"cas\".\n\n\nUne fois créés, les objets peuvent être utilisés dans d’autres commandes :\n\ncas + 5\n\n[1] 33\n\n\n\nDans votre script, créez un objet appelé region qui contient la valeur \"Mandoul\". Est-il bien apparu dans votre environnement ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN’oubliez pas que nous devons toujours entourer l’opérateur &lt;- par des espaces afin d’améliorer la lisibilité et d’éviter les erreurs.\n\nx&lt;-3     # MAUVAIS\nx &lt;- 3   # BIEN\n\n\n\n\nMettre à jour d’un objet\nNous souhaitons souvent mettre à jour la valeur stockée dans un objet. Pour ce faire, il suffit d’assigner une nouvelle valeur avec la même syntaxe que celle utilisée lors de la création de l’objet :\n\ncas &lt;- 32\n\n\nMettez à jour l’objet region avec la valeur \"Moyen Chari\".\n\n\n\nNoms d’objets\nPour nommer vos objets, il existe quelques règles (relativement) strictes :\n\nNe pas commencer par un chiffre\nNe pas utiliser d’espaces (utiliser un _ à la place)\nNe pas utiliser de valeurs réservées (comme TRUE et FALSE) ou des noms de fonctions (comme mean)\nNe pas utiliser de majuscules (c’est plus une convention qu’une règle dure)\n\nAu-delà de ces règles, il existe également des bonnes pratiques plus subjectives et des styles personnels. En règle générale, les noms doivent être courts et descriptifs :\n\na &lt;- 19                              # Pas informatif\nage_du_patient_a_l_admission &lt;- 19   # Trop long\nage &lt;- 19                            # Concis et précis\n\nDes noms clairs et informatifs contribuent à rendre votre code plus lisible, ce qui permet aux autres de le comprendre facilement sans avoir à constamment consulter le dictionnaire de données."
  },
  {
    "objectID": "sessions_core/01_introduction.html#structures-de-données",
    "href": "sessions_core/01_introduction.html#structures-de-données",
    "title": "Introduction à R",
    "section": "Structures de données",
    "text": "Structures de données\nJusqu’à maintenant, nous avons créé des objets simples qui contenaient une seule valeur. A présent nous allons nous intéresser à des structures plus complexes qui peuvent contenir des jeux de données.\n\nVecteurs\nIl est possible de rassembler plusieurs valeurs (telles que des valeurs numériques ou des chaînes de caractères) en un seul objet, appelé vecteur.\nTechniquement, il existe plusieurs types de vecteurs, dont :\n\nles vecteurs simples (ou vecteurs atomiques) ne peuvent contenir qu’un seul type de valeurs. Par exemple, un vecteur d’entiers contenant 2, 4, 6 ou un vecteur de texte contenant \"Mandoul\", \"Moyen Chari\".\nles vecteurs récursifs (généralement appelés listes) sont plus complexes et peuvent contenir plusieurs dimensions et types de données. Nous ne les aborderons pas dans cette leçon.\n\nCette leçon n’entrera pas dans les détails abstraits de ces structures et se concentrera sur celles que vous rencontrerez le plus souvent dans votre travail.\n\nVecteurs simples\nLes vecteurs simples peuvent contenir une ou plusieurs valeurs d’un seul type de données. Ils ont donc deux propriétés essentielles : une longueur et un type. Dans le cadre de ce cours, nous utiliserons indifféremment les termes “vecteur simple” et “vecteur”, comme c’est généralement le cas dans la communauté R.\nTechniquement, vous avez déjà créé vos premiers vecteurs simples lorsque vous avez construit les objets cas et region. Il s’agissait de vecteurs avec une longueur de taille une. Pour créer un vecteur avec plus d’une valeur, nous utiliserons la fonction c() (moyen mnémotechnique) :\n\ncas &lt;- c(2, 5, 8, 0, 4)\n\n\nMettez à jour cas avec les valeurs ci-dessus et mettez à jour region pour créer un vecteur de chaînes de caractères contenant les valeurs suivantes : Mandoul, Moyen-Chari, Logone Oriental, Tibesti et Logone Occidental.\n\nNous pouvons maintenant utiliser des fonctions sur les objets que nous avons créés :\n\nmean(cas)  # Calcule la moyenne des valeurs stockées dans le vecteur\n\n[1] 3.8\n\ntoupper(region)  # Convertit les valeurs du vecteur en majuscules\n\n[1] \"MANDOUL\"           \"MOYEN-CHARI\"       \"LOGONE ORIENTAL\"  \n[4] \"TIBESTI\"           \"LOGONE OCCIDENTAL\"\n\n\n\nEcrivez des commandes dans votre script pour effectuer les actions suivantes :\n\ncalculer la somme des valeurs de cas avec la fonction sum()\nconvertir le texte de region en minuscules à l’aide de la fonction tolower()\n\n\n\n\n\nAccès aux valeurs d’un vecteur\nIl est possible d’accéder à une valeur d’un vecteur en donnant son indice (i.e. sa position dans le vecteur) entre crochets :\n\ncas[2]   # Deuxième valeur de cas\n\n[1] 5\n\ncas[10]  # Dixième valeur de cas\n\n[1] NA\n\n\nOups il n’y a pas de dixième valeur dans cas ! Nous reviendrons sur ce que ce NA signifie dans la section valeurs manquantes.\nNous pouvons également accéder à une plage de valeurs, comme nous pourrions le faire dans Excel. Nous utilisons l’opérateur : entre la position minimum et maximum de la plage :\n\ncas[2:4]  # de la deuxième à la quatrième valeur\n\n[1] 5 8 0\n\n\n\nAffichez la 3ème valeur du vecteur region.\nAccédez aux valeurs “Mandoul” et “Moyen-Chari” du vecteur region.\n\n\n\nData frames\nLes data frames sont des structures tabulaires / tableaux en 2D avec des lignes et des colonnes. Il s’agit d’une structure très similaire à celle d’un “tableau” dans Excel. En tant qu’épidémiologistes, ce type d’objet est l’un des plus utiles et vous l’utiliserez quotidiennement pour stocker des jeux de données (des listes linéaires par exemple).\n\nCréation d’un data frame\nNous créons un data frame avec la fonction data.frame() :\n\ndata.frame(col1 = c(1, 4, 2, 9),\n           col2 = c(\"un peu de texte\", \"plus de text\", \"Salut !\", \"les epidemiologistes !\"))\n\n  col1                   col2\n1    1        un peu de texte\n2    4           plus de text\n3    2                Salut !\n4    9 les epidemiologistes !\n\n\nIci, on a crée col1 à partir d’un vecteur numérique, et col2 à partir d’un vecteur de chaînes de caractères. Nous avons choisi les noms des colonnes (col1 et col2), ce qui est normal, mais vous pouvez exécuter le code sans nommer les colonnes pour voir comment R crée lui même des noms.\n\nDans votre script, créez un data frame nomé data_cas qui contient cas dans une colonne et region dans l’autre.\n\n\n\nExploration d’un data frame\nL’objet data_cas devrait maintenant apparaître dans votre environnement. Vous pouvez cliquer sur le cercle bleu avec un triangle blanc pour dérouler des informations supplémentaires, ou cliquer sur son nom pour le visualiser dans un onglet dans le même volet que votre script.\n\n\n\nLe data frame data_cas apparaît désormais dans l’onglet Environnement.\n\n\nIl existe plusieurs fonctions pratiques pour explorer un data frame :\n\nExécutez les commandes suivantes et essayez de déterminer le type d’informations qu’elles renvoient.\n\nstr(data_cas)     # STRucture de l'object\ndim(data_cas)     # DIMension de l'object\nnrow(data_cas)    # Nombre de lignes (row = ligne)\nncol(data_cas)    # Nombre de COLonnes\nnames(data_cas)   # noms des colonnes\n\n\nPratiquons un peu plus ! R est livré avec quelques data frames intégrés auxquels il est possible d’accéder directement, dont un appelé iris. C’est pratique pour cette session car nous n’avons pas encore appris à importer des données dans R (ne vous inquiétez pas, nous travaillerons sur des données de liste linéaire dès la prochaine session !).\nNous pouvons afficher les premières lignes de ce data frame grâce à la fonction head() [head = la tête en anglais] :\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nCombien de lignes et de colonnes y a-t-il dans iris? Quels sont les noms des colonnes de ce data frame ?\n\n\n\nAccéder aux données d’un data frame\nEn R, il existe plusieurs méthodes pour accéder aux lignes et/ou colonnes d’un data frame. Dans cette session d’introduction, nous nous concentrerons sur la syntaxe [row, column].\nNous pouvons utiliser un numéro (ou un intervalle) de ligne pour extraire des lignes, et des numéros (ou un intervalle) de colonnes pour extraire les colonnes. Ont peut également utiliser le nom des colonnes pour y accéder.\n\ndata_cas[1, 2]    # Afficher la valeur de la ligne 1, deuxième colonne\n\n[1] \"Mandoul\"\n\ndata_cas[1, \"region\"]   # Afficher la valeur de la lignbe 1, pour la colonne région\n\n[1] \"Mandoul\"\n\n\nSi nous voulons isoler toutes les lignes (ou colonnes), nous pouvons simplement laisser un espace à la place du numéro/nom :\n\ndata_cas[1, ]  # Extrait la première ligne (garde toutes les colonnes)\n\n  cas  region\n1   2 Mandoul\n\ndata_cas[2:4, ]   # Valeurs des lignes 2 à 4, pour toutes les colonnes\n\n  cas         region\n2   5       Sud Kivu\n3   8 Kasai oriental\n4   0          Kasai\n\ndata_cas[ , \"region\"]   # Garde toutes les lignes mais que la colonne région\n\n[1] \"Mandoul\"        \"Sud Kivu\"       \"Kasai oriental\" \"Kasai\"         \n[5] \"Haut Katanga\"  \n\n\nNous pouvons même sélectionner plusieurs indices non consécutifs en utilisant un vecteur :\n\ndata_cas[c(1, 3), ]  # Ligne 1 et 3 (toutes les colonnes)\n\n  cas         region\n1   2        Mandoul\n3   8 Kasai oriental\n\n\nSoyez attentifs, le type de l’objet renvoyé par [ ] dépend de l’indexation utilisée :\n\nstr(data_cas[1 , ])   # Renvoit un data frame\n\n'data.frame':   1 obs. of  2 variables:\n $ cas   : num 2\n $ region: chr \"Mandoul\"\n\nstr(data_cas[ , 1])   # Renvoit un vecteur\n\n num [1:5] 2 5 8 0 4\n\n\nUne syntaxe simplifiée existe pour extraire des colonnes d’un data frame :\n\ndata_cas[2]           # Renvoit la deuxième colonne (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\ndata_cas[\"region\"]    # Renvoit la colonne région (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\n\n\nEcrivez le code pour :\n\nextraire la troisième valeur de la colonne region de votre data frame\nextraire les deuxième et troisième valeurs de la colonne cas\ncalculer la somme des valeurs de la colonne cas"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-missing-values",
    "href": "sessions_core/01_introduction.html#sec-missing-values",
    "title": "Introduction à R",
    "section": "Valeurs manquantes",
    "text": "Valeurs manquantes\nEn tant qu’épidémiologistes, nous sommes constamment confrontés aux données manquantes. Dans R, celles-ci sont codées à l’aide d’une valeur spéciale : NA [signifiant Not Available]. La valeur NA n’a pas de type fixe, elle prend celui des valeurs qui l’entourent. Par exemple, un NA dans une colonne numérique est traitée comme une valeur numérique. Nous aurons des occasions de manipuler les NA dans la suite du cours."
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-functions",
    "href": "sessions_core/01_introduction.html#sec-functions",
    "title": "Introduction à R",
    "section": "Fonctions",
    "text": "Fonctions\nLes fonctions sont des objets qui contiennent des commandes (au lieu de valeurs) qui sont exécutées chaque fois que la fonction est lancée. Vous êtes sans doute familiers avec les fonctions dans Excel, telles que la fonction SOMME() ou la fonction MOYENNE(). Bonne nouvelle, les fonctions sont similaires dans R !\nLa majorité des fonctions que vous allez utiliser ont besoin d’informations complémentaires : a minima des données, mais aussi d’autres paramètres. On appelle ces informations des arguments. Les arguments sont normalement nommés.\nPar exemple, lorsque nous avons exécuté la commande sum(cas), nous avons fourni le vecteur cas comme premier (et seul) argument de la fonction sum().\nParmis les arguments d’une fonction, certains peuvent être obligatoires, d’autres facultatifs. Le premier argument est presque toujours obligatoire et est souvent un data frame ou un vecteur de données. Comme c’est un argument évident, on omet souvent son nom (il vous a sans doute semblé naturel de taper mean(cas) au lieu de mean(x = cas)).\nLes arguments facultatifs, en revanche, sont généralement utilisés avec neur nom. Par exemple : mean(cas, na.rm = TRUE). Les arguments facultatifs sont souvent fournis avec des valeurs par défaut raisonnables, ce qui fait que l’utilisateur ne les spécifie que lorsqu’il a besoin de changer ces valeurs par défaut. Par exemple, l’argument na.rm de la fonction mean() controle comment les valeurs manquantes sont gérées lors du calcul de la moyenne [“na” en référence aux valeurs manquantes NA, et “rm” comme raccourci de “ReMove”, que l’on peut traduire dans ce contexte par enlever ou ignorer]. Par défault, la valeur de na.rm est FALSE Ainsi, par défaut, la moyenne de données avec des valeurs manquantes renverra toujours NA :\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nCeci est vrai pour de nombreuses opérations arithmétiques dans R. Si l’on veut que que R calcule la moyenne sur toutes les données disponibles et ignore les valeurs manquantes, nous devons explicitement fournir l’argument na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nAstuce\n\n\n\n\nLes arguments sont séparés par des virgules.\nCes virgules doivent toujours être suivies d’un espace\nChaque fois qu’un argument nommé est utilisé, l’attribut = doit être entouré d’espaces :\n\n\nmean(cas,na.rm=TRUE)     # MAUVAIS\nmean(cas, na.rm = TRUE)  # BON\n\nSi vous écrivez une commande avec de nombreux arguments, séparez chaque argument sur sa propre ligne pour améliorer la lisibilité :\n\nmean(cas, \n     na.rm = TRUE) \n\n\n\nQue se passe-t-il si l’on fournit plusieurs arguments dans le désordre ? Si vous avez nommé les arguments la fonction s’exécutera correctement, mais le code sera contre-intuitif et peu lisible. Nous vous conseillons de respecter l’ordre standard, en plaçant les arguments obligatoires tels que les données en premier.\n\n# Fonctionnel mais dur à lire\nmean(na.rm = TRUE,  \n     x = cas) \n\n# mieux\nmean(cas,         \n     na.rm = TRUE)\n\nEn revanche, si vous ne nommez pas les arguments et les passez dans le désordre, alors la fonction ne fonctionnera pas comme prévu, voire renverra une erreur :\n\nmean(TRUE, cas)  # Pas ce que vous attendez"
  },
  {
    "objectID": "sessions_core/01_introduction.html#terminé",
    "href": "sessions_core/01_introduction.html#terminé",
    "title": "Introduction à R",
    "section": "Terminé !",
    "text": "Terminé !\nC’est tout pour cette session, bravo pour vos débuts avec R et RStudio !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "pathway.html",
    "href": "pathway.html",
    "title": "Cours",
    "section": "",
    "text": "Ces sessions peuvent être suivies afin d’obtenir un niveau de base dans R. La série suppose aucune expérience préalable dans R et convient bien aux débutants.\nVous en voulez plus ? Vous voulez plus de flexibilité ? Consultez le catalogue complet des sessions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n18 févr. 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des données\n\n\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et importez des données pour travailler dans R.\n\n\n\n\n\n18 févr. 2025\n\n\n\n\n\n\n\n\n\n\n\n\nRecoder les variables et filtrer les observations\n\n\n\n\n\nApprenez à recoder vos variables avec {dplyr} et comment sélectionner les lignes d’un data frame suivant certains critères\n\n\n\n\n\n18 févr. 2025\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "explore.html",
    "href": "explore.html",
    "title": "Explorer",
    "section": "",
    "text": "Choisissez votre propre aventure en parcourant toutes les sessions disponibles.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des données\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et importez des données pour travailler dans R.\n\n\n\n\n\n\n18 févr. 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\n18 févr. 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecoder les variables et filtrer les observations\n\n\n\nCore\n\n\nManipulation des données\n\n\nNettoyage des données\n\n\nLogique\n\n\n\nApprenez à recoder vos variables avec {dplyr} et comment sélectionner les lignes d’un data frame suivant certains critères\n\n\n\n\n\n\n18 févr. 2025\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "about.html#salut",
    "href": "about.html#salut",
    "title": "À Propos",
    "section": "Salut",
    "text": "Salut\nBienvenue sur {repicentre}, un site open source développé par Epicentre pour vous aider à apprendre R pour les contextes humanitaires. Le site est composé de tutoriels autodidactes et propose deux options principales d’apprentissage :\n\nLinéaire. Conçu pour les personnes n’ayant aucune expérience préalable de R, le cours linéaire vous guidera à travers les concepts de base de R en utilisant une étude de cas sur la rougeole au Tchad. Le cours couvre les concepts suivants :\n\nStructures de données et l’interface RStudio\nImportation de données\nManipulation de données\nNettoyage des données\nAgrégation de données\nVisualisation des données\n\nExploration. Si vous avez un peu plus d’expérience ou si vous recherchez un sujet particulier, n’hésitez pas à explorer la gamme complète des tutoriels. Les tutoriels sont classés par catégories et sont conçus pour être autonomes."
  },
  {
    "objectID": "about.html#recommandations-et-demandes",
    "href": "about.html#recommandations-et-demandes",
    "title": "À Propos",
    "section": "Recommandations et demandes",
    "text": "Recommandations et demandes\nY a-t-il un sujet sur lequel vous aimeriez voir un tutoriel qui n’est pas encore disponible ? C’est très bien ! N’hésitez pas à nous le faire savoir en ouvrant un “issue” sur le repo GitHub associé à ce site web. Si vous ne savez pas comment ouvrir un issue, veuillez contacter Cat Eisenhauer."
  },
  {
    "objectID": "about.html#contribuer",
    "href": "about.html#contribuer",
    "title": "À Propos",
    "section": "Contribuer",
    "text": "Contribuer\nVous souhaitez contribuer à la rédaction ou à la maintenance de tutoriels ? Incroyable ! Veuillez contacter Cat."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{repicentre}",
    "section": "",
    "text": "Bienvenue à {repicentre}\nUne plateforme open source pour apprendre R dans les contextes humanitaires. Qu’aimeriez-vous faire ?\n\n\n\n\n\nApprendre Parcours linéaire en commençant par les bases  Start\n\n\n\n\n\nExplorer Catalogue complet de cours d’autoformation  Start\n\n\n\n\n\nÉlargir Ressources externes pour aller plus loin  Start"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Ressources",
    "section": "",
    "text": "Cette page contiendra (éventuellement) des ressources externes pour poursuivre votre parcours d’apprentissage du R."
  },
  {
    "objectID": "sessions_core/02_import_data.html",
    "href": "sessions_core/02_import_data.html",
    "title": "Importer des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets dans la session\nEcrire des chemins d’accès aux fichiers robustes\nImporter et inspecter des données dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des données s’appliquent aussi à votre code : on souhaite écrire un script qui fonctionne maintenant, mais également dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider à aller dans cette direction, et la première est d’avoir un code source propre et bien organisé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#objectifs",
    "href": "sessions_core/02_import_data.html#objectifs",
    "title": "Importer des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets dans la session\nEcrire des chemins d’accès aux fichiers robustes\nImporter et inspecter des données dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des données s’appliquent aussi à votre code : on souhaite écrire un script qui fonctionne maintenant, mais également dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider à aller dans cette direction, et la première est d’avoir un code source propre et bien organisé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "href": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "title": "Importer des données",
    "section": "Mise en place du projet",
    "text": "Mise en place du projet\n\nStructure des dossiers\n\nSi ce n’est pas déjà fait, téléchargez le dossier du cours décompressez-le. Sauvegardez le dossier non compressé à un endroit non connecté à OneDrive et ouvrez-le.\n\n\n\n  Dossier du cours\n\n\n\n\nCe dossier illustre une structure typique et recommandée pour vos projets de code :\n\n📁 data\n\n📁 raw\n📁 clean\n\n📁 R\n📁 outputs\n\nCe dossier sera votre répertoire de travail pour toutes les sessions de ce cours. Vous y créerez un projet RStudio (explications ci-dessous), et y enregistrerez tous vos scripts (sous dossier R). Les données brutes se trouvent déjà dans data/raw.\n\n\nDéfinitions\nVoici deux concepts importants que nous allons rencontrer dans cette session :\nRépertoire de travail. Le répertoire de travail est l’emplacement (dossier) où votre session R en cours travaille. Si vous enregistrez un fichier, par exemple, il sera enregistré dans ce dossier par défaut. De même, Si vous ouvrez un fichier, ce dossier sera affiché par défaut. Tous les chemins relatifs auront ce dossier pour origine. Par défaut, R choisit généralement votre dossier “Documents” comme répertoire de travail sur les machines Windows.\nRacine. La racine fait référence au niveau de dossier le plus élevé du répertoire de travail. Si le dossier de votre cours s’appelle FETCHR la racine se trouverait directement à l’intérieur de celui-ci (et non dans l’un de ses sous-dossiers comme R ou data).\n\n\nProjets RStudio\nUn projet RStudio est outil qui va faciliter votre vie et aider RStudio à trouver les différents fichiers.\nPour rappel, votre interface doit ressembler à ceci :\n\n\n\n\n\n\nFigure 1: Capture d’écran d’une interface RStudio typique\n\n\n\n\nOuvrez RStudio et suivez ces étapes pour créer un nouveau projet :\n\ncliquez sur File &gt; New Project &gt; Existing Directory &gt; Browse,\nnaviguez jusqu’au dossier du cours (en l’ouvrant)\ncliquez sur Create Project.\n\n\n\nDans l’explorateur Windows, examinez le dossier du cours. Vous devriez maintenant voir un nouveau fichier avec l’extension .Rproj qui a une petite icône bleue avec un R au milieu\n\n\n\n\nIcône associée aux projets RStudio\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi vous ne voyez pas ce fichier, c’est probablement parce qu’il est caché par défaut sur votre ordinateur. Pour modifier ce paramètre dans l’explorateur Windows, allez dans le menu Afficher et sélectionnez Extensions de noms de fichier.\n\n\nLorsque vous ouvrez un projet RStudio, RStudio démarre une nouvelle session R spécifique à ce projet, ouvre les fichiers associés et définit la racine de votre dossier comme répertoire de travail. Une conséquence immédiate est que le panneau Files en bas à droite de l’interface montre les sous dossiers présents dans le répertoire de travail, i.e. votre dossier de cours.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est fortement recommandé de mettre en place un projet RStudio distinct pour chacune de vos analyses afin de garantir que les fichiers de vos projets restent organisés.\n\n\nIl existe plusieurs façons d’ouvrir un projet RStudio :\n\nUtilisez le menu RStudio File &gt; Open Project puis sélectionnez le fichier .Rproj approprié\nCliquez sur le bouton Project: (none) en haut à droite de l’interface RStudio\nNaviguez dans l’explorateur de fichiers Windows jusqu’à votre dossier de cours et double-cliquez sur le fichier avec l’extension .Rproj\n\n\n\nLes options de RStudio\nAvant de poursuivre, allons modifier certaines des options de RStudio qui peuvent causer des problèmes.\n\nOuvrez les options globales (Tools &gt; Global Options) et ouvrez l’onglet General (menu de gauche). Déselectionnez toutes les cases des sections R Sessions, Workspace et History.\n\n\n\n\nCapture d’écran des options de RStudio\n\n\nLorsque ces options sont activées, RStudio enregistre les objets de votre environnement et les charge à chaque fois que vous ouvrez une nouvelle session R. Ca semble être une bonne idée, mais il est en fait préférable de toujours commencer votre travail à partir d’une session R vide afin d’éviter les erreurs.\n\n\n\n\n\n\nImportant\n\n\n\nN’oubliez pas que toutes les commandes nécessaires au nettoyage et à l’analyse de vos données doivent être enregistrées explicitement dans un script, dans le bon ordre. Faire retourner le script devrait arriver aux mêmes résultats que précédement.\n\n\n\n\nCréation d’un nouveau script\n\nOuvrez un nouveau script et enregistrez-le dans le sous-dossier R de votre projet sous le nom import_data.R.\nAjoutez des métadonnées au début du script, comme recommandé lors première session, en utilisant des commentaires. Veillez à inclure :\n\nLe titre\nL’auteur du script\nLa date de création\nUne description rapide de ce que fait le script\n\n\nNous sommes prêts à commencer à coder"
  },
  {
    "objectID": "sessions_core/02_import_data.html#sec-packages",
    "href": "sessions_core/02_import_data.html#sec-packages",
    "title": "Importer des données",
    "section": "Paquets",
    "text": "Paquets\nLes paquets [packages] sont des collections de fonctions qui étendent les fonctionalités de R. Vous en utiliserez un grand nombre pendant ce cours et dans votre travail quotidien. R étant open-souce, les packages sont téléchargeable et utilisable gratuitement.\n\n\n\n\n\n\nNote\n\n\n\nDans ce cours, nous utiliserons une convention commune qui est de référencer les paquets entre {}. Par exemple {ggplot2} est le nom du paquet ggplot2 qui contient des fonctions pour créer des graphes, telles que ggplot(), geom_point() etc…\n\n\n\nInstallation\nLa fonction install.packages() télécharge et installe un nouveau paquet sur votre ordinateur, dans la bibliothèque de paquets associée à R. Vous n’avez à faire cette opération qu’une seule fois par paquet et ordinateur.\n\ninstall.packages(\"here\") # installe le paquet {here} \n\nN’oubliez pas de mettre le nom du paquet entre guillemets lorsque vous utilisez la commande install.packages(). Que se passe-t-il si vous ne le faites pas ?\n\n\n\n\n\n\nNote\n\n\n\nSi vous suivez cette session dans le cadre d’un cours, pour éviter tout problème potentiel de connectivité internet pendant la formation, nous vous avons déjà fait installer la plupart des paquets du cours.\nSi vous suivez ce tutoriel seul ou si vous n’avez pas encore installé les paquets, vous devrez installer manuellement chaque nouveau paquet que nous rencontrerons avec la fonction install.packages().\n\n\n\n\nUtilisation\nUne fois qu’un paquet est installé, il faut indiquer à R que nous souhaitons l’utiliser pour une session donnée en le chargeant dans la session avec la fonction library().\n\nlibrary(here) # charge le paquet {here} dans la session\n\n\nUtilisez la fonction library() pour charger les paquets here et rio qui seront utilisés aujourd’hui.\n\nIl se peut que vous obteniez parfois un message d’avertissement signalant que certaines fonctions ont été masquées ou que la version actuelle du paquet a été construite pour une version différente de R. Ces messages ne doivent pas vous inquiéter, mais il faut les lire et essayer de comprendre ce qui se passe.\n\nExécutez le code suivant. Comprenez-vous le message d’erreur ?\n\nlibrary(ggplot)\n\n\nLe code ci-dessus génère une erreur car il y a une faute de frappe dans le nom du paquet, et vous avez donc essayé de charger un paquet qui n’existe pas. Rappelez-vous que R est pénible, et en particulier est sensible à la casse : beaucoup de vos erreurs viendront de petites fautes dans les noms de fonctions ou d’objets. Ici, par exemple, nous voulions charger le paquet ggplot2 mais nous avons écrit ggplot à la place.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est recommandé d’avoir une section au début de votre script qui charge tous les paquets dont vous aurez besoin dans votre script en un seul endroit :\n\n# Packages ----------------------------\nlibrary(tidyverse)   # manipulation de données\nlibrary(lubridate)   # manipulation des dates\n\nCelà permet de savoir rapidement quels paquets doivent être installés pour exécuter un script.\n\n\n\nCréez une section “Paquets” dans votre script à l’aide de commentaires\n\n\n\nMettre à jour les paquets\nR dispose d’une communauté de développeurs très active et il est assez courant que les paquets soient mis à jour, avec de nouvelles fonctionalités ou des corrections de bugs. Pour mettre à jour les paquets de votre bibliothèque, rendez-vous dans l’onglet Packages du panneau inférieur droit et cliquez sur Update. N’oubliez pas que vous devez être connecté à internet pendant ce processus.\n\n\n\n\n\n\nImportant\n\n\n\nLa mise à jour de certains paquets peut parfois changer le comportement de certaines fonctions, ce qui peut casser votre code. Pas de panique. La meilleure pratique consiste à adapter votre code mais, dans le pire des cas, vous pouvez installer une ancienne version du paquet incriminé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#importation-de-données",
    "href": "sessions_core/02_import_data.html#importation-de-données",
    "title": "Importer des données",
    "section": "Importation de données",
    "text": "Importation de données\n\nTrouver son chemin…\nPour ouvrir un fichier dans R, vous devez fournir un chemin d’accès au fichier. Un chemin d’accès est simplement un (long) nom pour un fichier qui inclut son emplacement sur votre ordinateur. Les chemins d’accès peuvent être absolus ou relatifs.\n\nChemins d’accès absolus\nLes chemins d’accès absolus sont spécifiques à votre ordinateur et vont jusqu’au niveau de votre disque dur. Par exemple : D:/OneDrive - MSF/Documents/monitoring/cholera/fancy_project/data/raw/example_linelist.xlsx. Il est clair que ce chemin ne fonctionne que sur un ordinateur particulier.\nL’utilisation de chemins absolus encodés en dur est fortement déconseillé car cela rend votre code fragile et augmente la maintenance : en effet, les chemins devront tous être mis à jour chaque fois quelqu’un d’autre exécute votre code, ou que le dossier du projet est déplacé sur votre ordinateur.\n\n\nChemins d’accès relatifs\nLes chemins relatifs sont définis par rapport à votre répertoire de travail. Comme l’emplacement du fichier .Rproj définit le répertoire de travail, les chemins sont relatifs à cette racine. Pour vous, un chemin relatif ressemblera à ça : data/raw/example_linelist.xlsx.\nCela signifie que tant que la structure interne du dossier contenant votre projet est préservée, le chemin d’accès relatif sera valable quelque soit l’ordinateur.\n\n\nChemins d’accès robustes avec la fonction here()\nLe paquet {here} dispose d’une fonction here() qui aide à créer des chemins d’accès. Elle présente deux avantages :\n\nElle détecte la présence d’un fichier .Rproj et est capable de construire un chemin absolu à partir d’un chemin relatif dans votre projet RStudio.\nElle choisit automatiquement le séparateur adapté à votre système d’exploitation : /, \\ ou //.\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"C:/Users/M-MOUSSET/AppData/Local/Temp/RtmpMPZhRL/file1c381401a77/data/raw/example_linelist.xlsx\"\n\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"C:/Users/M-MOUSSET/AppData/Local/Temp/RtmpMPZhRL/file1c381401a77/data/raw/example_linelist.xlsx\"\n\n\nVoyez comme nous n’avons défini que le chemin relatif et la fonction a reconstitué le chemin absolu. Celà marchera donc sur l’ordinateur d’un collègue, y compris sur un autre système d’exploitation, du moment que la structure du répertoire de travail est intacte.\nNous vous encourageons fortement à utiliser here() chaque fois que vous devez créer un chemin d’accès à un fichier.\n\nExécutez le code ci-dessus dans la console. Quel chemin d’accès here(\"data\", \"raw\") vous donne-t-il ?\n\n\nUtilisez here() pour créer le chemin vers le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx.\n\n\n\n\n\n\n\nImportant\n\n\n\nhere() crée une chaîne de caractères contenant l’adresse d’un fichier, mais ne vérifie pas si ce fichier existe réellement sur votre ordinateur. Si le fichier est absent ou s’il y a une faute de frappe dans votre code, vous obtiendrez une erreur lors de l’utilisation du chemin ainsi créé. Vous pouvez tester si un fichier existe à cette adresse avec la fonction file.exists().\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nOn veut souvent définir plusieurs chemins dans un projet (données brutes, données propres, où sauver les graphes etc.). C’est une bonne pratique que de créer une nouvelle section au début de votre script, après le chargement des paquets, pour définir et stocker les chemins d’accès dans des objets.\n\n\n\n\n\nImporter les données\nDans R, différents formats de fichiers sont importés par différentes fonctions spécialisées, ce qui est fastidieux à mémoriser et à charger. La fonction import() du paquet {rio} nous fait gagner du temps en reconnaissant l’extension des fichier et en appelent automatiquement une fonction spécialisée pour charger les données.\nComme import() ne fait qu’appeler d’autres fonctions en arrière-plan, il est possible qu’elle ait besoin d’arguments optionnels spécifiques pour certains types de fichier.\n\n\n\n\n\n\nAstuce\n\n\n\nLa (longue) liste des types de fichiers pris en charge par {rio} est sur le site du paquet. Dans la suite de la leçon, nous nous concentrerons sur l’importation de données à partir de fichiers Excel .xlsx.\n\n\n\nImport de la première feuille\nAu minimum la fonction import() a besoin qu’on lui donne le chemin du fichier avec l’argument file :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"))\n\nNotez que nous avons imbriqué la commande here() à l’intérieur de la commande import(). L’imbrication de fonctions est autorisée et même courrante en R. R évalue les fonctions imbriquées de l’intérieur (here()) à l’extérieur (import()). La valeur renvoyée par here() est donc utilisée comme valeur d’entrée d’import().\n\nImportez le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx en utilisant here() et import().\n\nSi votre importation a fonctionné correctement, R affichera les données dans la console mais ne les enregistrera pas dans l’environnement car nous ne les avons pas assignées à un objet.\n\nRéimportez vos données, mais cette fois-ci, sauvegardez-les dans un objet appelé df_linelist.\n\n\n\n\n\n\n\nAstuce\n\n\n\nSi votre jeu de données est très gros, il vaut mieux éviter de l’afficher dans la console…\n\n\n\n\nImport d’une autre feuille\nComme vous venez de le voir, la fonction import() importe la première feuille d’un fichier Excel par défaut. Il est cependant possible de passer le numéro de la feuille ou son nom (en chaîne de caractères) à l’argument which :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"),  # chemin\n       which = 2)                                            # spécifie la deuxième feuille\n\nNotez que l’argument which est spécifique aux types de fichiers comportant plusieurs feuilles, tels que les fichiers Excel ou .Rdata. Si vous essayez de l’utiliser sur un fichier .csv l’argument sera ignoré."
  },
  {
    "objectID": "sessions_core/02_import_data.html#aperçu-des-données",
    "href": "sessions_core/02_import_data.html#aperçu-des-données",
    "title": "Importer des données",
    "section": "Aperçu des données",
    "text": "Aperçu des données\nNous avons importé un jeu de données dans R et l’avons assigné à un objet (df_linelist). Nous pouvons maintenant inspecter le data frame créé pour vérifier que l’export s’est bien passé, et commencer à évaluer le nettoyage à faire.\nNous pouvons commencer par jeter un coup d’œil rapide aux premières lignes du data frame à l’aide de la fonction head(). Son premier argument est le data frame à inspecter et le second, n, accepte un nombre de lignes à afficher (optionnel).\n\nhead(df_linelist, n = 10) # Affiche les 10 premières lignes\n\n\nUtilisez head() pour examiner les 12 premières lignes de df_linelist.\n\nNous pouvons inspecter la structure du data frame à partir de l’onglet Environnement dans le panneau supérieur droit. Nous pouvons également visualiser le data frame dans le le visualiseur de données de RStudio (en haut à gauche).\n\nCliquez sur le bouton rond bleu à côté de df_linelist dans votre environnement pour examiner sa structure. Cliquez ensuite sur le nom du data frame pour le visualiser.\n\nLe visualiseur permet d’afficher le data frame comme dans un tableur et est un moyen pratique d’examiner rapidement vos données. Vous pouvez trier et filtrer vos données dans cet onglet mais ces actions ne modifieront pas l’objet df_linelist. Le visualiseur peut également être ouvert en utilisant directement la fonction View() sur le data frame."
  },
  {
    "objectID": "sessions_core/02_import_data.html#cest-fini",
    "href": "sessions_core/02_import_data.html#cest-fini",
    "title": "Importer des données",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo et n’oubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "href": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "title": "Importer des données",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices supplémentaires\n\nUtilisez dim() pour examiner les dimensions de votre data frame.\nUtilisez str() pour vérifier le type de données de chaque colonne. Voyez-vous quelque chose d’étrange ? N’oubliez pas que vous pouvez également utiliser des fonctions telles que is.character() et is.numeric() si vous souhaitez tester le type d’une colonne particulière.\nEn utilisant une fonction apprise lors de la première session, pouvez-vous extraire les noms des colonnes du data frame ? Ces résultats correspondent-ils à ce que vous voyez lorsque vous ouvrez les données dans Excel ?\nEssayez d’exécuter la fonction summary() sur votre data frame. Qu’est ce que le résultat vous apprend sur les variables ?\n\n\n\nRessources complémentaires\n\nLe site web de {rio}\nPlus d’exemples sur l’importation de données de différents types de fichiers"
  }
]