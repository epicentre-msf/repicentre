[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Ressources",
    "section": "",
    "text": "Cette page contiendra (éventuellement) des ressources externes pour poursuivre votre parcours d’apprentissage du R."
  },
  {
    "objectID": "sessions_extra/data_exploration.html",
    "href": "sessions_extra/data_exploration.html",
    "title": "Exploration des données",
    "section": "",
    "text": "Effectuer une exploration rapide d’un ensemble de données importé\nProduire des tableaux de fréquence pour les variables"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#objectifs",
    "href": "sessions_extra/data_exploration.html#objectifs",
    "title": "Exploration des données",
    "section": "",
    "text": "Effectuer une exploration rapide d’un ensemble de données importé\nProduire des tableaux de fréquence pour les variables"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#setup",
    "href": "sessions_extra/data_exploration.html#setup",
    "title": "Exploration des données",
    "section": "Setup",
    "text": "Setup\nDependances. Cette session supplémentaire suppose que vous avez suivi les sessions introduction à R et R studio, et importation de données.\n\nPour cette session, nous travaillerons avec notre liste brute de rougeole de Moissala qui peut être téléchargée ici :\n\n\n\n  Course Folder\n\n\n\n Assurez-vous qu’il est correctement stocké dans data/raw de votre projet. Ensuite, ouvrez un nouveau script appelé data-exploration.R, et assurez-vous que les paquets {here}, {rio} et {dplyr} sont chargés. Enfin, importez les données dans R sous la forme d’un objet appelé df_linelist."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-des-données",
    "href": "sessions_extra/data_exploration.html#exploration-des-données",
    "title": "Exploration des données",
    "section": "Exploration des données",
    "text": "Exploration des données\nJuste après avoir importé des données dans R, nous pouvons avoir envie d’y jeter un coup d’œil. Lorsque l’on parle d’exploration de données, on veut généralement faire plusieurs choses :\n\nExaminer les dimensions des données (c’est-à-dire le nombre de lignes et de colonnes).\nExaminer les noms des colonnes\nVisualiser les premières ou les dernières lignes\nDéterminer le type des variables\nDéterminer la plage de valeurs des variables continues\nObserver les valeurs possibles de chaque variable catégorielle\n\nCe processus est crucial et nous permettra de nous familiariser avec nos données et d’identifier les problèmes qui seront traités lors de l’étape de nettoyage des données."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-de-base",
    "href": "sessions_extra/data_exploration.html#exploration-de-base",
    "title": "Exploration des données",
    "section": "Exploration de base",
    "text": "Exploration de base\nLa toute première chose que vous voulez savoir sur vos données, ce sont les dimensions, c’est-à-dire le nombre de lignes et le nombre de colonnes qui composent vos données. Il existe plusieurs façons d’obtenir ces informations dans R :\n\nRegardez votre volet environnement dans RStudio et vérifiez vos données - le nombre à côté (5230x25) nous indique qu’il s’agit d’un data frame avec 5230 lignes et 25 colonnes.\nUtilisez dim() sur vos données pour renvoyer un vecteur avec le nombre de lignes et le nombre de colonnes.\nVous pouvez aussi utiliser ncol() pour obtenir le nombre de colonnes et nrow() pour le nombre de lignes.\n\nIl est bon de se souvenir de ces nombres afin de pouvoir repérer rapidement tout changement inattendu dans vos données au cours de votre analyse (c’est-à-dire plus ou moins de lignes ou de colonnes que prévu).\n\nEn utilisant la méthode de votre choix, obtenez les dimensions de votre data frame df_linelist."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#noms-de-variables",
    "href": "sessions_extra/data_exploration.html#noms-de-variables",
    "title": "Exploration des données",
    "section": "Noms de variables",
    "text": "Noms de variables\nComme nous allons utiliser les noms des variables très souvent au cours de notre analyse, nous voulons nous familiariser avec eux dès le début. De plus, nous devons identifier celles qui devront être renommées lors du nettoyage des données. La fonction names() renvoie un vecteur de tous les noms de variables dans notre cadre de données :\n\nnames(df_linelist)\n\n [1] \"id\"                   \"full_name\"            \"sex\"                 \n [4] \"age\"                  \"age_unit\"             \"region\"              \n [7] \"sub_prefecture\"       \"village_commune\"      \"date_onset\"          \n[10] \"date_consultation\"    \"hospitalisation\"      \"date_admission\"      \n[13] \"health_facility_name\" \"malaria_rdt\"          \"fever\"               \n[16] \"rash\"                 \"cough\"                \"red_eye\"             \n[19] \"pneumonia\"            \"encephalitis\"         \"muac\"                \n[22] \"vacc_status\"          \"vacc_doses\"           \"outcome\"             \n[25] \"date_outcome\"        \n\n\n\nQue pensez-vous des noms de votre ensemble de données ? Pouvez-vous déjà repérer des noms de variables que vous aimeriez renommer ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#inspecter-vos-données",
    "href": "sessions_extra/data_exploration.html#inspecter-vos-données",
    "title": "Exploration des données",
    "section": "Inspecter vos données",
    "text": "Inspecter vos données\nIl est également intéressant d’inspecter vos données, cela peut vous permettre de repérer plus facilement certaines incohérences, des variables avec beaucoup de valeurs manquantes, et cela vous permettra de voir à quelles valeurs s’attendre pour chacune d’entre elles. Vous pouvez “print” vos données dans la console en :\n\nExécutant l’objet df_linelist seul (attention, vous ne voudrez peut-être pas faire cela si vous avez un grand ensemble de données).\nUtilisant la fonction head() pour voir les 6 premières lignes (vous pouvez augmenter ce nombre en utilisant l’argument n)\nUtilisant la fonction tail() pour voir les 6 dernières lignes (encore une fois, vous pouvez augmenter ce nombre en utilisant l’argument n)\n\nCes méthodes n’afficheront que les 40 premières lignes de vos données au maximum, car c’est la limite de votre console. Alternativement, vous pouvez utiliser View() pour voir vos données sous forme de tableau. Cela ouvrira une nouvelle fenêtre avec vos données affichées comme dans une feuille de calcul Excel. Note : cette commande ne fait qu’afficher les données, elle ne vous permet pas de les modifier.\n\n\n\n\n\n\nAstuce\n\n\n\nSoyez très prudent avec View() sur un grand jeu de données car cela peut faire planter votre session RStudio. Pour éviter cela, vous pouvez imprimer la sortie dans la console.\n\n\n\nPouvez-vous afficher les 15 premières lignes de vos données ? Que se passe-t-il lorsque vous modifiez la largeur de votre fenêtre de console et que vous exécutez à nouveau la commande ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#types-des-variables",
    "href": "sessions_extra/data_exploration.html#types-des-variables",
    "title": "Exploration des données",
    "section": "Types des variables",
    "text": "Types des variables\nNous voulons maintenant vérifier le type des différentes variables. C’est important car une partie du nettoyage des données consiste à s’assurer que les variables numériques sont de type numeric, dates Date, et que les variables catégorielles sont de type factor ou character. Vous avez déjà vu la fonction class(), qui permet de vérifier le type d’un vecteur. Dans R, chaque variable d’un dataframe est un vecteur. Nous pouvons extraire toutes les valeurs de ce vecteur en utilisant le sign $, et les passer à la fonction class() :\n\nclass(df_linelist$age)\n\n\nEssayez d’extraire toutes les valeurs de la variable sex. Quelle est le type de cette variable ?\n\nVous pouvez également utiliser str() sur votre dataframe pour vérifier le type de toutes les variables à la fois :\n\nstr(df_linelist)\n\n\nUtilisez str() pour vérifier le type de données de chaque colonne. Y a-t-il quelque chose d’étrange ? Rappelez-vous que vous pouvez aussi utiliser des fonctions comme is.character() et is.numeric() si vous voulez tester le type d’une colonne en particulier."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-des-variables-continues",
    "href": "sessions_extra/data_exploration.html#exploration-des-variables-continues",
    "title": "Exploration des données",
    "section": "Exploration des variables continues",
    "text": "Exploration des variables continues\nMaintenant que vous savez comment extraire les valeurs d’une variable, vous pouvez vouloir explorer certaines des valeurs des variables numériques pour vérifier les incohérences. Calculer des statistiques récapitulatives pour ces variables, et Base R fournit de nombreuses fonctions pratiques :\n\n\n\n\n\n\n\n\n\nFonction\nDescription\nExemple\nRetours\n\n\n\n\nmin()\nValeur minimale\nmin(x)\nValeur minimale unique\n\n\nmax()\nValeur maximale\nmax(x)\nValeur maximale unique\n\n\nmean()\nMoyenne arithmétique\nmean(x)\nValeur moyenne\n\n\nmedian()\nValeur moyenne\nmedian(x)\nValeur moyenne\n\n\nrange()\nMin et max\nrange(x)\nVecteur de (min, max)\n\n\nIQR(x)\nQ3 - Q1\nIQR(x)\nQ3 - Q1\n\n\nquantile()\nQuantiles spécifiés\nquantile(x, probs = c(0.25, 0.75))\nQuantiles demandés\n\n\nsd()\nEcart-type\nsd()\nEcart-type\n\n\nvar()\nVariance\nvar(x)\nVariance\n\n\nsum()\nSomme des valeurs\nsum(x)\nSomme\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nCes fonctions exigent que vous supprimiez explicitement les valeurs manquantes (NA) en utilisant l’argument na.rm = TRUE\n\n\nVous pouvez extraire les valeurs d’une variable en utilisant $, et les passer à n’importe laquelle de ces fonctions.\n\nUtilisez la syntaxe $ pour obtenir :\n\nLa valeur minimale de age\nLe maximum de muac\n\nDes problèmes ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-des-variables-catégorielles",
    "href": "sessions_extra/data_exploration.html#exploration-des-variables-catégorielles",
    "title": "Exploration des données",
    "section": "Exploration des variables catégorielles",
    "text": "Exploration des variables catégorielles\nEnfin, examinons les valeurs de nos variables catégorielles. Pour ce faire, nous pouvons utiliser des tableaux de fréquence. C’est pratique car :\n\nIls nous permettent de voir rapidement les valeurs uniques d’une variable catégorielle\nLe nombre d’observations pour chacune de ces catégories\n\nPour ce faire, on utilise la fonction count() du package {dplyr}, qui accepte un dataframe et le nom d’une (ou plusieurs !) colonne(s) en tant qu’arguments. Il compte alors le nombre d’observations de chaque élément unique dans cette colonne. Par exemple, voyons les valeurs possibles de la variable sex :\n\ncount(df_linelist, sex)\n\nLe résultat est un nouveau dataframe, plus petit, contenant le nombre de patients observés, stratifié par sex. Il semble que cette variable nécessite un recodage… Nous le ferons dans une prochaine session.\n\nEn utilisant les données de votre liste, examinez les valeurs de la variable outcome. A quoi cela ressemble-t-il ?\nMaintenant, essayez d’ajouter l’argument sort = TRUE à la fonction count(). Que fait cet argument ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#cest-fait",
    "href": "sessions_extra/data_exploration.html#cest-fait",
    "title": "Exploration des données",
    "section": "C’est fait !",
    "text": "C’est fait !\nBravo pour ce premier coup d’œil sur vos données !\n\n\n\n Solution File"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{repicentre}",
    "section": "",
    "text": "Bienvenue à {repicentre}\nUne plateforme open source pour apprendre R dans les contextes humanitaires. Qu’aimeriez-vous faire ?\n\n\n\n\n\nApprendre Parcours linéaire en commençant par les bases  Start\n\n\n\n\n\nExplorer Catalogue complet de cours d’autoformation  Start\n\n\n\n\n\nRessources Ressources externes pour aller plus loin  Start"
  },
  {
    "objectID": "explore.html",
    "href": "explore.html",
    "title": "Explorer",
    "section": "",
    "text": "Choisissez votre propre aventure en parcourant toutes les sessions disponibles.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCourbes épidémiques hebdomadaires\n\n\n\nSatellite\n\n\nVisualization\n\n\n\nApprenez à tracer des courbes épidémiques hebdomadaires et à améliorer les étiquettes des axes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnquête standard sur la mortalité\n\n\n\nCompagnon\n\n\nAnalyse\n\n\n\nSession complémentaire au module FETCH de l’enquête\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExploration des données\n\n\n\nSatellite\n\n\nData Exploration\n\n\n\nExplorez vos données après l’importation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraphiques multiples (facetting)\n\n\n\nSatellite\n\n\nVisualization\n\n\n\nApprenez à créer plusieurs mini graphiques “par catégorie” en une seule commande\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportation des données\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et importez des données pour travailler dans R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to data visualization with ggplot2\n\n\n\nCore\n\n\nVisualization\n\n\n\nApprenez les bases de la visualisation avec ggplot2, et créez votre première épicurve\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurveillance\n\n\n\nCompagnon\n\n\nAnalyse\n\n\n\nTutoriel d’accompagnement au module Surveillance du FETCH\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTableaux récapitulatifs\n\n\n\nCore\n\n\nTableaux de resumé\n\n\n\nCréer des tableaux récapitulatifs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, les bases\n\n\n\nCore\n\n\nManipulation des données\n\n\nNettoyage des données\n\n\n\nUne introduction à la manipulation et au nettoyage des données à l’aide du paquet {dplyr}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, recoder et filtrer\n\n\n\nCore\n\n\nManipulation des données\n\n\nNettoyage des données\n\n\nLogique\n\n\n\nApprenez à recoder vos variables avec {dplyr} et comment sélectionner les lignes d’un data frame suivant certains critères\n\n\n\n\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html",
    "href": "sessions_core/03_data_verbs.html",
    "title": "Traitement de données, les bases",
    "section": "",
    "text": "Découvrir les fonctions de {dplyr} pour effectuer les actions essentielles sur les données :\n\nSélectionner des colonnes avec select()\nRenommer des colonnes avec rename()\nCréer de nouvelles colonnes ou modifier des colonnes existantes avec mutate()\nSupprimer les doublons avec distinct()\n\nEnchaîner ces actions avec l’opérateur “pipe” |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#objectifs",
    "href": "sessions_core/03_data_verbs.html#objectifs",
    "title": "Traitement de données, les bases",
    "section": "",
    "text": "Découvrir les fonctions de {dplyr} pour effectuer les actions essentielles sur les données :\n\nSélectionner des colonnes avec select()\nRenommer des colonnes avec rename()\nCréer de nouvelles colonnes ou modifier des colonnes existantes avec mutate()\nSupprimer les doublons avec distinct()\n\nEnchaîner ces actions avec l’opérateur “pipe” |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#mise-en-place",
    "href": "sessions_core/03_data_verbs.html#mise-en-place",
    "title": "Traitement de données, les bases",
    "section": "Mise en place",
    "text": "Mise en place\nPrérequis : cette leçon part du principe que vous savez comment utiliser RStudio et que vous êtes capable d’importer des données. Rafraîchissez-vous si besoin avec les deux premières leçons.\n\nNous utiliserons la linelist avec des données brutes que vous avez importée lors de la leçon précédente, et qui peut être téléchargée ici :\n\n\n\n Télécharger les données\n\n\n\n Si ce n’est pas déjà fait, enregistrez le jeu de données dans le sous-dossier approprié de votre projet RStudio puis créez un nouveau script appelé fonctions_donnees.R dans votre sous-dossier R. Ajoutez un en-tête approprié et chargez les paquets suivants : {here}, {rio} et {tidyverse}.  Enfin, ajoutez une section dédiée à l’import des données, utilisez {here} et {rio} pour importer vos données dans R, et assignez-les à un objet que nous appellerons df_brut."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#traiter-ses-données-avec-dplyr",
    "href": "sessions_core/03_data_verbs.html#traiter-ses-données-avec-dplyr",
    "title": "Traitement de données, les bases",
    "section": "Traiter ses données avec {dplyr}",
    "text": "Traiter ses données avec {dplyr}\nLa mise en place est terminée et nous pouvons maintenant nous focaliser sur nos données ! Cette leçon et les suivantes s’appuieront lourdement sur plusieurs paquets de la collection de paquets tidyverse pour manipuler des data frames, résumer et visualiser les données, et en particulier paquet {dplyr} pour aujourd’hui.\nLe traitement des données (aussi appelé manipulation des données) est un ensemble d’actions essentielles pour préparer et nettoyer les données avant une analyse (que ce soit dans R ou Excel). {dplyr} fournit un grand nombre de fonctions qui nous aident à manipuler les data frames et à réaliser de nombreuses tâches quotidiennes telles que :\n\ncréer des sous-ensembles de nos données en ne gardant que les variables d’intérêt\nrenommer des colonnes\najouter ou modifier des colonnes\nsupprimer les doublons\n\nCes fonctions ont en général un nom intuitif, qui correspond à un verbe. Par exemple, pour renommer des colonnes, on utilisera la fonction rename().\nAujourd’hui nous nous focaliserons sur les quatre verbes (fonctions !) qui permettent d’effectuer les tâches mentionnées précédemment, et que vous utiliserez en permanence. Nous vous montrerons également comment enchaîner les actions dans un “pipeline” pour plus de fluidité.\n\n\n\n\n\n\nNote\n\n\n\nPeut-être avez-vous noté que nous vous parlons du paquet {dplyr} mais nous vous avons fait charger le paquet {tidyverse} lors de la mise en place. C’est que le {tidyverse} est un méta-paquet, et le charger charge automatiquement plusieurs des paquets les plus utiles de l’univers du tidyverse, dont fait partie {dplyr} et d’autres paquets que nous verrons dans la session."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#actions-de-base-sur-les-données",
    "href": "sessions_core/03_data_verbs.html#actions-de-base-sur-les-données",
    "title": "Traitement de données, les bases",
    "section": "Actions de base sur les données",
    "text": "Actions de base sur les données\n\nSélectionner des colonnes\nIl est fréquent de souhaiter écarter des variables d’un jeu de données, soit car ces colonnes contiennent des données sensibles, soit parce que nous n’avons pas besoin d’elles pour une analyse donnée. Nous utiliserons pour cela la fonction select(), qui la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nselect(un_dataframe, colonne_a_garder, autre_colonne_a_garder)\n\nIci, le premier argument est le data frame contenant les données. Les arguments suivants sont les noms des colonnes que nous voulons conserver. Dans le tidyverse, les noms de colonnes n’ont pas besoin d’être écrits entre guillemets.\nLa commande suivante nous permet de sélectionner les colonnes id, sex et age, par exemple :\n\nselect(df_brut, id, sexe, age)\n\n\nUtilisez la fonction select() pour sélectionner les variables suivantes de votre data frame : id, sexe, age, sous_prefecture, date_debut et issue. L’en-tête du data frame renvoyé par la fonction ressemble à ceci :\n\n\n  id  sexe age date_debut issue\n1  1 femme  36 2022-08-13 gueri\n2  2     f   5 2022-08-18  &lt;NA&gt;\n3  3     f 156 2022-08-17 gueri\n4  6 homme   8 2022-08-22 gueri\n5  7     h   7 2022-08-30 gueri\n6 10     h   4 2022-08-30 gueri\n\n\n Comparez ce résultat à df_brut. Ce dernier contient toujours toutes les colonnes importées (ce qui est le comportement désiré). Comprenez-vous pourquoi c’est le cas ?\n\nIl arrive que nous ne voulions supprimer que quelques colonnes d’un jeu de données et si le jeu de données est large ça serait fastidieux d’écrire toutes les colonnes à garder comme nous l’avons fait ci-dessus… Heureusement, nous pouvons préfacer un nom de colonne par l’opérateur soustraction (-) pour indiquer à R de la supprimer.\nPar exemple, pour créer un data frame sans la colonne village_commune :\n\nselect(df_brut, -village_commune)\n\n\nUtilisez cette syntaxe pour créer un data frame qui conserve toutes les colonnes de df_brut à l’exception de nom_complet et unite_age.\n\n\n\nRenommer les colonnes\nIl arrive souvent que nous souhaitions renommer des colonnes d’un jeu de données. La fonction rename() est alors votre meilleure amie.\n\n# NE PAS EXÉCUTER (PSEUDO CODE)\nrename(un_dataframe,\n       nouveau_nom_1 = nom_tout_moche,\n       nouveau_nom_2 = autre_nom_pas_fou)\n\nComme pour select(), le premier argument est le data frame qui contient les données (ce sera le cas pour la majorité des verbes de {dplyr}). Ensuite, chaque nouvel argument est une paire nouveau_nom = ancien_nom indiquant à R les colonnes à renommer et leurs nouveaux noms. Nous vous conseillons d’aller à la ligne pour chaque nouvelle paire pour aider à la lisibilité.\nRenommons la colonne village_commune en village par exemple :\n\nrename(df_brut,\n       village = village_commune)\n\n\nUtilisez la fonction rename() sur df_brut pour renommer les colonnes :\n\nsous_prefecture en prefecture\nvillage_commune en village\nnom_structure_sante en structure\n\n\nIl peut être difficile de vérifier si une commande fonctionne car R affiche le data frame en entier. Dans ce cas, une première solution consiste à créer un objet temporaire plus facile à manipuler. Vous pouvez le nommer comme vous voulez, mais un nom commun est temp (ou tmp en anglais).\n\nRépétez le dernier exercice en assignant la sortie de la commande à un objet appelé temp. Vous pouvez alors utiliser la fonction names() pour vérifier que les noms des colonnes ont bien changé. La sortie de names() devrait être :\n\n\n [1] \"id\"                \"nom_complet\"       \"sexe\"             \n [4] \"age\"               \"unite_age\"         \"region\"           \n [7] \"prefecture\"        \"village\"           \"date_debut\"       \n[10] \"date_consultation\" \"hospitalisation\"   \"date_admission\"   \n[13] \"structure\"         \"tdr_paludisme\"     \"fievre\"           \n[16] \"eruption\"          \"toux\"              \"yeux_rouges\"      \n[19] \"pneumonie\"         \"encephalite\"       \"pb\"               \n[22] \"statut_vaccinal\"   \"doses_vaccin\"      \"issue\"            \n[25] \"date_issue\"       \n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLes objets comme le data frame temp sont généralement utilisés pour tester si quelque chose a fonctionné et peuvent donc être écrasés lorsque vous testez autre chose. Ils ne doivent pas être utilisés comme entrée pour d’autres parties de votre code. Utilisez des noms clairs et appropriés pour vos data frames destinés à être réutilisés, tels que df_linelist ou df_propre.\n\n\n\n\nModifier et ajouter des colonnes\nUne autre tâche essentielle du traitement de données est de modifier des colonnes ou d’en créer de nouvelles. La fonction mutate() permet de faire les deux [to mutate veut dire muter en anglais], avec la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nmutate(un_dataframe,\n       nouvelle_colonne_1 = action(colonne_existante),\n       nouvelle_colonne_2 = autre_action(une_autre_colonne_existante))\n\nDans le code ci-dessus nous créons une nouvelle colonne (nouvelle_colonne_1) en effectuant une action (des calculs par exemple) sur une colonne existante (colonne_existante) dans le data frame un_dataframe. Puis nous créons une autre colonne (nouvelle_colonne_2) sur le même principe. L’action en question peut être variée et plus ou moins complexe : calcul arithmétique, application d’une fonction sur une colonne (ou même plusieurs !) etc.\nPar exemple, nous pourrions créer une nouvelle colonne exprimant le périmètre brachial en cm :\n\nmutate(df_brut,\n       pb_cm = pb / 100) # une opération arithmétique simple\n\n\nUtilisez mutate() pour créer une nouvelle colonne age_ans qui exprime l’âge en années plutôt qu’en mois. L’en-tête de la colonne ressemble à ceci :\n\n\n   age_years\n1  3.0000000\n2  0.4166667\n3 13.0000000\n4  0.6666667\n5  0.5833333\n6  0.3333333\n\n\n\nPour modifier une colonne existante il suffit d’utiliser le nom de la colonne existante à gauche du = au lieu de fournir un nouveau nom.\nPar exemple, si nous voulions remplacer la colonne pb qui contenait des valeurs en mm par une colonne pb contenant les valeurs en cm :\n\nmutate(df_brut,\n       pb = pb / 100)\n\nNous voulons souvent conserver la colonne originelle, mais il existe des cas raisonnables où nous souhaitons écraser les données par une nouvelle version. Par exemple :\n\nmodifier des chaînes de caractères (format, correction de typos etc.)\ncorriger le type de données d’une colonne\n\nNotre jeu de données présente ces deux cas. Par exemple les colonnes region et sous_prefecture sont en majuscules, ce qui n’est pas un problème en soi, mais peut être améliorable. Pour corriger cela nous pouvons utiliser la fonction str_to_title() du paquet {stringr} (qui fait également partie du {tidyverse}) pour passer les valeurs en casse “titre”.\n\nmutate(df_brut,\n       region = str_to_title(region),\n       sous_prefecture = str_to_title(sous_prefecture))\n\n\nUtilisez la fonction mutate() pour mettre à jour le format de tdr_paludisme et issue afin d’utiliser la casse “titres”. L’en-tête de la sortie pour ces deux colonnes devrait maintenant être :\n\n\n  tdr_paludisme issue\n1       Negatif Gueri\n2       Negatif  &lt;NA&gt;\n3       Negatif Gueri\n4       Negatif Gueri\n5       Negatif Gueri\n6       Negatif Gueri\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous n’avons pas eu besoin de charger {stringr} car comme {dplyr}, ce paquet est chargé automatiquement lorsque nous chargeons{tidyverse}.\n\n\nPassons maintenant au problème des variables avec le mauvais type.\n\nVérifiez le type de vos colonnes. Y a-t-il des problèmes ?  Indice : str() peut être utile ici.\n\nLes classes semblent raisonnables sauf pour les dates : certaines colonnes ont la classe caractère et d’autres sont POSIXct. Nous préférerions que toutes ces colonnes utilisent le type Date.\nNous allons utiliser la fonction ymd() du paquet {lubridate} pour faire la conversion en Date. “ymd” est l’abréviation de year month day, c’est à dire année-mois-jour. Cela veut dire que la fonction attend une date fournie dans cet ordre-là (les séparateurs peuvent varier).\nPour corriger la date de décharge :\n\nmutate(df_brut,\n       date_issue = ymd(date_issue))\n\n\nUtilisez mutate() et ymd() pour modifier les colonnes date_debut et date_admission afin qu’elles soient de type Date.\nAstuce : n’hésitez pas à stocker la sortie de la fonction dans un data frame temporaire temp pour vérifier le type des variables modifiées.\n\n\n\nSupprimer les doublons\nNous connaissons désormais les fonctions pour sélectionner, renommer et modifier nos variables. Il est temps à présent de passer à une autre tâche essentielle du nettoyage : la suppression doublons.\nLa fonction distinct() permet de rapidement enlever les lignes identiques d’un data frame avec la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndistinct(un_dataframe)\n\nPar défaut, nous n’avons besoin que d’un seul argument : le jeu de données lui-même. Cela supprime alors toutes les lignes qui sont complètement en double en ne gardant qu’une seule copie. Il existe des usages plus sophistiqués de distinct() pour chercher des doublons partiels, mais leur correction dépasserait du cadre de cette session…\n\nUtilisez la fonction distinct() et créez un data frame temporaire, temp qui contient toutes les observations uniques dans df_brut. Comparez le nombre de lignes de temp à celui de df_brut. Avions-nous des doublons ?"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#lopérateur-pipe",
    "href": "sessions_core/03_data_verbs.html#lopérateur-pipe",
    "title": "Traitement de données, les bases",
    "section": "L’opérateur “pipe”",
    "text": "L’opérateur “pipe”\nNous avons profité de la présentation des fonctions essentielles de {dplyr} pour commencer le nettoyage du jeu de données. Il est temps de rassembler les commandes écrites dans les exercices en un ensemble cohérent pour créer un data frame contenant les données netoyées (au moins en partie) que nous appelerons df_linelist.\n\n\n\n\n\n\nAstuce\n\n\n\nEn général, il est recommandé de conserver une version brute de votre ensemble de données, ici df_brut, qui reste inchangée dans votre code. Ainsi, vous l’avez toujours à disposition dans votre environnement comme référence et elle est toujours disponible au début de votre pipeline de nettoyage pour améliorer la reproductibilité.\n\n\nIl y a plusieurs manières d’enchaîner les différentes étapes que nous avons vues. Intuitivement, nous pourrions commencer comme ceci :\n\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sous_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\nPuis mettre à jour df_linelist :\n\n# Étape 1 : Renommer les variables\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sub_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\n# Étape 2 : Sélectionner les variables à conserver\ndf_linelist &lt;- select(df_linelist,\n                      -nom_complet)\n\nNotez que dans cette deuxième étape, nous utilisons df_linelist comme entrée de select() plutôt que df_brut car nous voulons continuer à travailler sur la version modifiée des données.\nPuis nous ajoutons l’âge en années :\n\n# Étape 1 : Renommer les variables\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sub_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\n# Étape 2 : Sélectionner les variables à conserver\ndf_linelist &lt;- select(df_linelist,\n                      -nom_complet)\n\n# Étape 3 : Ajouter l'âge en années\ndf &lt;- mutate(df_linelist,\n             age_ans = age / 12)\n\nEt caetera. Ce code est tout à fait fonctionnel, mais devient lourd et répétitif si de nombreuses étapes s’enchaînent : à chaque étape nous utilisons en entrée le data frame renvoyé par l’étape précédente pour le mettre à jour…\nIl existe un raccourcis ! L’opérateur pipe (|&gt;) permet d’enchainer des actions de manière plus fluide avec cette syntaxe :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nune_entree |&gt; une_action\n\n# En particulier :\nun_dataframe |&gt; une_fonction()\n\nIci, le pipe prend l’entrée fournie à gauche et la transmet à la fonction à droite. Ainsi, par exemple, au lieu d’écrire\n\nselect(df_brut, id, sexe)\n\nnous pouvons écrire\n\ndf_brut |&gt; select(id, sexe)\n\n\nTestez le code ci-dessus de votre côté.\n\nOn peut se servir de l’opérateur pipe pour enchaîner plusieurs actions. C’est le style de code dit “du tidyverse”, qui ressemble à ceci :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_linelist &lt;- df_brut |&gt;\n  action_1() |&gt;\n  action_2() |&gt;\n  action_3() |&gt;\n  ...\n\n\n\n\n\n\n\nAstuce\n\n\n\nAller à la ligne entre chaque action est considéré comme une bonne pratique pour rendre le code plus facile à lire et à comprendre.\n\n\nNous pourrions donc remplacer le code précédent par ceci :\n\ndf_linelist &lt;- df_brut |&gt;\n  rename(prefecture = sub_prefecture,\n         village    = village_commune,\n         facility   = health_facility_name) |&gt;\n  select(-full_name) |&gt;\n  mutate(age_years = age / 12)\n\nC’est beaucoup plus fluide que de réaffecter df_linelist après chaque étape !\n\nA votre tour ! Rassemblez maintenant toutes les étapes de nettoyage de la leçon en une seule commande en un seul pipeline.\nUtilisez l’opérateur pipe |&gt;, les fonctions select() rename(), mutate(), str_to_title(), ymd() et distinct() pour créer un data frame df_linelist partiellement nettoyé.  Rappel des étapes :\n\nSupprimer les variables nom_complet et unite_age\nRenommer les variables suivantes :\n\nage devient age_ans\nsous_prefecture devient prefecture\nvillage_commune devient village\nnom_structure_sante devient structure\n\nAjouter une variable age_ans avec l’âge du patient en années\nMettre à jour region et prefecture pour utiliser la casse de titre\nMettre à jour toutes les colonnes contenant des dates pour utiliser le type Date\nSupprimer toutes les lignes en double\n\nL’en-tête de vos données finales devrait ressembler à ceci :\n\n\n  id  sexe age_mois  region prefecture        village date_debut\n1  1 femme       36 Mandoul   Moissala Sangana Koïtan 2022-08-13\n2  2     f        5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3     f      156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 homme        8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7     h        7 Mandoul   Moissala      Tétindaya 2022-08-30\n6 10     h        4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             oui     2022-08-14\n2        2022-08-25             oui     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25             non           &lt;NA&gt;\n5        2022-09-02             non           &lt;NA&gt;\n6        2022-09-02             oui     2022-09-02\n                        structure tdr_paludisme fievre eruption toux\n1 Hôpital du District de Moissala       negatif     No     &lt;NA&gt;  Yes\n2 Hôpital du District de Moissala       negatif     No       No  Yes\n3                      CS Silambi       negatif    Yes     &lt;NA&gt;   No\n4 Hôpital du District de Moissala       negatif     No       No   No\n5                      CS Silambi       negatif   &lt;NA&gt;       No  Yes\n6                    Moissala Est       negatif    Yes       No   No\n  yeux_rouges pneumonie encephalite  pb statut_vaccinal doses_vaccin issue\n1          No        No          No 244            &lt;NA&gt;         &lt;NA&gt; gueri\n2          No      &lt;NA&gt;          No 232             Non         &lt;NA&gt;  &lt;NA&gt;\n3          No        No        &lt;NA&gt; 123      Oui - oral         &lt;NA&gt; gueri\n4        &lt;NA&gt;        No          No 210             Non         &lt;NA&gt; gueri\n5         Yes        No          No  80             Non         &lt;NA&gt; gueri\n6        &lt;NA&gt;        No          No 220             Non         &lt;NA&gt; gueri\n  date_issue    age_ans\n1 2022-08-18  3.0000000\n2 2022-08-28  0.4166667\n3       &lt;NA&gt; 13.0000000\n4       &lt;NA&gt;  0.6666667\n5       &lt;NA&gt;  0.5833333\n6 2022-09-03  0.3333333\n\n\nAstuce :  soyez attentifs à vos noms de colonne. Si vous rennomez une colonne, il faudra utiliser le nouveau nom dans les étapes suivantes du pipeline.\n\nFantastique ! C’est un excellent début de pipeline de nettoyage de vos données. Sauvegardez ce code, car nous le complèterons lors de la prochaine session, durant laquelle nous apprendron une autre étape essentielle du traitement de données : recoder les variables !"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#cest-fini",
    "href": "sessions_core/03_data_verbs.html#cest-fini",
    "title": "Traitement de données, les bases",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo, vous avez appris les bases de la manipulation de données et comment enchaîner plusieurs commandes dans un pipeline. À partir de maintenant, les fichiers contenant les solutions des exercices fourniront le code final plutôt qu’une correction par exercice, afin d’avoir un script plus réaliste. Par exemple, la solution fournira le pipe final créé à la fin de la session d’aujourd’hui.\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#aller-plus-loin",
    "href": "sessions_core/03_data_verbs.html#aller-plus-loin",
    "title": "Traitement de données, les bases",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires\n\nAjoutez une ligne à votre mutate() pour mettre à jour la variable hospitalisation afin que son texte soit également en casse “titre”\nPeut-être préféreriez-vous utiliser des minuscules pour la colonne region plutôt que la casse “titre” ? Mettez votre code à jour pour le faire. Astuce : vous pouvez utiliser la fonction apprises dans la première session ou tester la fonction str_to_lower() de {stringr}.\nCréez une colonne delai_consultation, qui contient le nombre de jours entre l’apparition des symptômes et la consultation."
  },
  {
    "objectID": "sessions_core/01_introduction.html",
    "href": "sessions_core/01_introduction.html",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCréer et exécuter un script\nCréer des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#objectifs",
    "href": "sessions_core/01_introduction.html#objectifs",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCréer et exécuter un script\nCréer des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#format-des-exercices",
    "href": "sessions_core/01_introduction.html#format-des-exercices",
    "title": "Introduction à R",
    "section": "Format des exercices",
    "text": "Format des exercices\nCes exercices sont dans un format tutoriel contenant de brèves explications sur les concepts clés, des exemples et des instructions à suivre. Notre approche est très orientée sur la pratique, et à l’exception de cette première session partiellement axée sur l’interface, vous aurez beaucoup d’occasions de coder.\nLes instructions pour les exercices seront données dans les formats suivants :\n\nCet encadré contient des instructions généralistes. Vous le trouverez en général au début d’une session, avec des instructions de mise en place.\n Exemple : Ouvrez un script vide et nommez-le mon_premier_script.R.\n\n\nCet encadré contient des instructions de code que vous devez écrire dans votre script ou la console.\n Exemple : Créez un objet region qui contient la valeur \"Mandoul\".\n\n\nCet encadré vous demande d’observer ou étudier quelque chose.\n Exemple : Inspectez l’interface de RStudio.\n\nAu cours de ces exercices, vous rencontrerez certainement des erreurs, qui se produisent lorsque R n’est pas en mesure d’exécuter une commande. Cela peut se produire pour de nombreuses raisons : une faute d’orthographe dans le nom d’un objet ou d’une fonction, le mauvais type de données fournis etc. Lorsqu’une erreur se produit, R arrête les calculs en cours et affiche un message expliquant ce qu’il s’est passé. Il est tout à fait normal d’avoir des erreurs, ça arrive tout le temps, à tous les programmeurs, qu’ils soient novices ou experts. Comme lorsque vous apprenez une langue (non informatique), vous vous améliorerez avec la pratique, en faisant des erreurs et en apprenant à les corriger."
  },
  {
    "objectID": "sessions_core/01_introduction.html#rstudio-et-r",
    "href": "sessions_core/01_introduction.html#rstudio-et-r",
    "title": "Introduction à R",
    "section": "RStudio et R",
    "text": "RStudio et R\nR est un langage de programmation fonctionnel qui peut être utilisé pour nettoyer et manipuler des données, effectuer des analyses (en particulier des analyses statistiques), visualiser des résultats, et bien plus encore.\nRStudio est un logiciel qui fournit une interface facile à utiliser pour R (également appelé IDE, pour “Integrated Development Environment”). Son utilisation n’est pas obligatoire, mais très fortement recommandée pour les débutants.\n\nPremiers pas avec RStudio\n\nOuvrez RStudio en utilisant le menu de démarrage de votre ordinateur ou le raccourci créé par défaut sur le bureau ; si RStudio était déjà ouvert, fermez-le et ouvrez-le à nouveau.\n\nVous devriez voir une interface qui ressemble à ceci :\n\n\n\nVue de l’interface de l’IDE Rstudio à l’ouverture\n\n\n\nInspectez l’interface de RStudio.\n\nVous verrez trois ou quatre panneaux.\n\nPanneau supérieur droit\nEn haut à droite se trouve un panneau avec plusieurs onglets. La plupart d’entre eux dépassent le cadre de ce cours, mais nous utiliserons les deux onglets suivants :\n\nEnvironment : liste les objets enregistrés par l’utilisateur dans la session en cours. Comme vous venez de démarrer une nouvelle session, votre environnement devrait être vide.\nHistory : comprend l’historique de toutes les commandes que vous avez exécutées au cours de la session actuelle.\n\n\n\n\n\n\n\nNote\n\n\n\nOuvrir une nouvelle session R, c’est comme redémarer son ordinateur : tout est vide et prêt pour le calcul, de la même manière qu’il n’y a aucun programme ouvert lorsque vous allumez votre ordinateur pour la première fois.\nNous vous encourageons à arrêter et à re-démarrer vos sessions R régulièrement. Parfois cela corrigera certains de vos problèmes !\n\n\n\n\nPanneau inférieur droit\nEn bas à droite se trouve un autre panneau comprenant les onglets suivants :\n\nFiles : un explorateur de fichiers pour le répertoire de travail, qui est l’emplacement du dossier dans lequel R travaille actuellement.\nPlots : là où RStudio affichera les graphiques statiques. Cet onglet devrait être vide pour le moment.\nPackages : liste de tous les paquets R installés sur votre ordinateur. Les paquets sont des collections de fonctions qui permettent d’étendre les fonctionnalités de R. Nous les aborderons plus en détail dans la prochaine leçon.\nHelp : un endroit pour lire les pages d’aide et la documentation pour les fonctions et les paquets.\nViewer : un emplacement où RStudio affichera des sorties html telles que des tableaux, des widgets interactifs ou même des tableaux de bord.\n\n\n\nPartie gauche\n\nA gauche (ou en bas à gauche si vous avez déjà quatre panneaux), vous devriez voir l’onglet console, où le code R est exécuté.\nEn haut à gauche (si vous avez quatre panneaux) se trouvent les scripts R ouverts.\n\n\n\n\nLa console\nLa console est l’endroit où le code R s’exécute.\nAu début d’une nouvelle session, un texte d’information sur votre cofiguration apparaît tout en haut de la console, dont le numéro et nom de la version de R. En dessous de ces informations, il y a une ligne avec le symbole &gt; et un curseur clignotant.\nPour exécuter une commande dans R, tapez-la à la suite du &gt; et pressez Entrée. R traitera alors votre code et affichera le résultat (s’il y en a un). Un nouveau &gt; s’affichera alors sur la ligne suivante, indiquant que la console est prête pour la commande suivante.\n\n\n\n\n\n\nImportant\n\n\n\nSi la dernière ligne est préfacée d’un + au lieu d’un &gt;, cela signifie que la console n’est pas prête. Soit elle attend qu’un calcul d’une commande précédente finisse, soit elle attend la fin d’une commande incomplète. A tout moment, vous pouvez interrompre l’exécution en pressant la touche Echap.\n\n\n\nExécutez les commandes suivantes dans la console, une ligne à la fois, et observez les résultats.\n\n5 + 90\n\n6 * 171\n\n189 / 36.6\n\n92^3\n\n(12 + 9)^4 / 1000\n\nExécutez maintenant la commande suivante. Notez que le ) fermant est manquant, ce qui rend la commande incomplète. Que se passe-t-il ?\n\n3 / (2 + 97\n\n\nVous avez peut-être noté dans les exemples précédents que notre code contient beaucoup d’espaces. C’est en effet une bonne pratique que d’inclure des espaces autour de la plupart des opérateurs, tels que +, -, *, /, &lt;, &gt;, = et &lt;-. Ces espaces facilitent la lecture et la compréhension de votre code, et dans certains cas (rares) ils permettent d’éviter des erreurs. Néanmoins, certains opérateurs ne doivent pas être entourés d’espaces, tels que ^, . et :.\n\n1+29+4.8/3*3           # Mauvais\n1 + 29 + 4.8 / 3 * 3   # Bien\n\n1 ^ 2  # Mauvais\n1^2    # Bien\n\nNous pouvons également exécuter des fonctions dans la console. Nous aborderons les fonctions plus en détail plus tard mais sachez que les fonctions dans R sont similaires aux fonctions dans Excel (telles que SOMME ou MOYENNE).\n\nExécutez les commandes suivantes dans la console (une ligne à la fois).\n\n# Trouvez la valeur minimale\nmin(5, 10)\nmin(1, 8, 56, 0.3)\n\n# Trouvez la valeur maximale\nmax(568, 258, 314)\n\n\n\n\nScripts\nLes scripts sont des fichiers texte qui contiennent une série de commandes pour un langage de programmation particulier. L’extension du fichier indique le langage dans lequel les commandes sont écrites. Ici nous utiliserons l’extension .R. Les scripts nous permettent de créer du code qui peut être réutilisé, partagé et même automatisé.\n\nÉcrire son premier script\nPour créer un nouveau script, allez dans le menu File &gt; New File &gt; R Script. Alternativement, cliquez sur la petite icône avec un + vert sur une page blanche située en dessous du menu File. Ou encore, utilisez le raccourci clavier CTRL + MAJ + N. Ce nouveau script non sauvegardé apparaîtra sous la forme d’un document vierge dans le panneau supérieur gauche.\n\n\n\nEtapes pour créer un nouveau script dans RStudio\n\n\nPour enregistrer votre script, utilisez le menu File &gt; Save As ou le raccourci clavier CTRL + S.\n\nCréez un script et enregistrez-le sous le nom decouverte.R(n’oubliez l’extension !). Pour l’instant, vous pouvez l’enregistrer sur votre bureau ou à tout autre endroit pratique, mais nous aborderons l’organisation des scripts dans la prochaine session.\n\n\n\nExécuter du code à partir d’un script\nPour exécuter du code à partir d’un script, placez votre curseur sur la ligne que vous souhaitez exécuter (ou sélectionnez plusieurs lignes) et effectuez l’une des opérations suivantes :\n\nCliquez sur le bouton Run en haut à droite de la fenêtre de script\nUtilisez le raccourci CTRL + Entrée (le curseur passera ensuite à la ligne suivante)\nUtiliser le raccourci ALT + Entrée (le curseur restera sur la ligne actuelle)\n\n\nCopiez le code que vous aviez exécuté dans la console lors des exercices précédents dans votre script et exécutez-le en testant les différentes méthodes ci-dessus.\nA partir de maintenant, vous écrirez votre code dans votre script et l’exécuterez à partir de là, sauf indication contraire de notre part.\n\n\n\nCommentaires\nDans R, le code qui est précédé d’un # (dièse) n’est pas exécuté, il est juste ignoré jusqu’à la fin de la ligne. C’est donc un bon moyen de documenter votre code.\n\n# Ceci est un commentaire\n\n2 + 3  # Ceci est aussi un commentaire\n\nIl est utile pour vous et vos collègues de commencer vos scripts par quelques lignes commentées fournissant des informations importantes sur le contenu de votre script.\n\n# IMPORT & PREPARATION DES DONNEES #\n# Auteure :  Mathilde Mousset\n# Date de création : 23/11/2024\n# Dernière mise à jour : 28/01/2024\n# Description : Importat et nettoyage des données de surveillance rougeole de Moissala\n\n\nAjoutez quelques commentaires au début de votre script pour le décrire.\n\nLes commentaires sont également un moyen pratique de diviser les scripts longs en sections thématiques, telles que “Import des données”, “Analyse”, “Visualisation”, etc. Par exemple :\n\n# NOM DE LA SECTION 1 -----------------------------------------------             \n\n# NOM DE LA SECTION 2 -----------------------------------------------             \n\n\nUtilisez les commentaires pour créer des sections dans votre script qui correspondent aux sections principales de ce tutoriel.\n\nEnfin, les commentaires permettent de prendre des notes sur votre code pour aider à la compréhension (celle de votre “moi futur” et celle de vos collègues). On entend souvent le conseil de se focaliser sur les commentaires qui expliquent le “pourquoi” plutôt que le “quoi”, car le “quoi” d’un code bien écrit devrait être clair.\nPar exemple, ce commentaire est superflu :\n\n1 + 3  # Code pour additionner un et trois\n\nEn comparaison, voici quelques cas où un commentaire est mérité :\n\nVous définissez une constante, une valeur seuil de séroprévalence par exemple. Ajoutez un commentaire indiquant la référence d’où provient la valeur.\nVotre code contient une valeur ou un nom de fichier qui doit être mis à jour chaque semaine. Indiquez le dans un commentaire afin que toute personne utilisant le code en soit informée.\nVous utilisez une commande contre-intuitive de premier abord, ou un paquet rare que votre collègue ne connaît peut-être pas. Commentez pour expliquer vos raisons.\n\nCeci étant dit, vous êtes en plein apprentissage, et les scripts que vous écrivez pendant ce cours sont l’équivalent de vos notes de cours, alors n’hésitez pas à utiliser autant de commentaires que vous le souhaitez pour expliquer les commandes et vous rappeler de ce qu’elles font. Vous écrirez naturellement moins de commentaires avec la pratique, lorsque les choses qui nouvelles aujourd’hui deviendront naturelles.\n\n\n\n\n\n\nAstuce\n\n\n\nCommentez une ligne sélectionnée avec le raccourci CTRL + MAJ + C.\nAjoutez une section de premier niveau avec CTRL + MAJ + R.\n\n\n\nAjoutez quelques commentaires pour décrire le code que vous avez écrit jusqu’à présent dans votre script."
  },
  {
    "objectID": "sessions_core/01_introduction.html#types-de-données",
    "href": "sessions_core/01_introduction.html#types-de-données",
    "title": "Introduction à R",
    "section": "Types de données",
    "text": "Types de données\nR dispose de plusieurs types de données. Ceux que nous verrons le plus souvent dans ce cours sont les suivants :\n\nnumérique [numeric en anglais]\nchaîne de caractères (texte) [string en anglais]\nbooléen (VRAI / FAUX) [boolean en anglais]\ndate [date]\nfacteur [factor]\n\n\nNumérique\nLe type numérique englobe les entiers [integers en anglais] et les doubles (nombres décimaux). Les nombres en R n’ont pas de signalétique, tapez simplement la valeur brute dans votre script ou votre console.\n\n\nChaînes de caractères\nLes chaînes de caractères [strings] représentent le texte en R. Elles sont tapées en entourant votre texte de guillemets simples ou doubles, \"district\" ou 'cas' par exemple (les guillemets doubles sont généralement considérés comme la meilleure pratique).\n\nComparez la sortie dans la console pour les commandes suivantes :\n\n28         # numérique\n\"28\"       # texte\n28 + \"28\"  # donne une erreur\n\n\nLa dernière commande ci-dessus a renvoyé une erreur car nous ne pouvons pas effectuer d’opérations arithmétiques combinant du texte et des nombres.\n\n\n\n\n\n\nImportant\n\n\n\nR est sensible à la casse (majuscules ou minuscules), ce qui signifie que \"ABC\" n’est pas équivalent à \"abc\".\n\n\n\nSi vous souhaitez créer une chaîne de caractères contenant des guillemets, il faut échapper les guillements les faisant précéder d’un \\. Par exemple : \"Elle dit \\\"Bonjour\\\" et s'en alla\" ou 'C\\'est une belle journée'. Si vous avez utilisé des guillements doubles pour créer votre chaîne de caractères, vous pouvez utiliser des guillemets simples à l’intérieur de celle-ci (par exemple : \"C'est une belle journée\") et vice versa (par exemple : 'Elle dit \"Bonjour\" et s'en alla').\n\n\n\nBooléen (logique)\nLe type booléen (ou logique) stocke des valeurs vrai/faux et est créé en écrivant soit TRUE [VRAI] ou FALSE [FAUX] sans guillemets.\nEn interne, R traduit TRUE et FALSE en équivalents numériques 1 et 0 respectivement, ce qui peut être utile pour des opérations arithmétiques.\n\n\n\n\n\n\nNote\n\n\n\nVous verrez peut-être des personnes qui utilisent T ou F mais c’est déconseillé car T et F peuvent également être utilisés comme noms d’objets ou de variables. En revanche, les valeurs TRUE et FALSE sont réservées (protégées), ce qui signifie qu’elles ne peuvent pas être réaffectés à une autre valeur.\n\n\n\n\nDéterminer le type d’un objet\nIl existe plusieurs fonctions permettant de déterminer le type d’un objet (souvent appelé la classe de l’objet en R [class].\n\nTapez les commandes suivantes dans votre script et exécutez-les :\n\n# Obtenir le type\nclass(28)  \nclass(\"Mandoul\")\n\n# Test du type\nis.numeric(28)\nis.numeric(\"Mandoul\")\nis.character(\"Mandoul\")\n\nis.numeric(TRUE)\nis.character(TRUE)\nis.logical(FALSE)"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-assignement-operator",
    "href": "sessions_core/01_introduction.html#sec-assignement-operator",
    "title": "Introduction à R",
    "section": "Enregistrer un objet",
    "text": "Enregistrer un objet\nEn R, presque tout est un objet y compris les fonctions, les vecteurs et les structures plus complexes. Souvent, nous souhaitons réutiliser certains objets tout au long d’un script (un jeu de données par exemple). Il est donc très utile de les stocker dans notre environnement (la mémoire de R). Pour ce faire, nous utilisons l’opérateur d’assignation &lt;-.\n\nRegardez le panneau environnement en haut à droite. Il devrait être vide. Tapez la commande suivante dans votre script et exécutez-la. Elle enregistre une variable appelée cas dans votre environnement.\n\ncas &lt;- 28\n\nInspectez à nouveau l’environnement. Est-il toujours vide ?\n\nSi vous souhaitez accéder à la valeur de votre nouvel objet, cas il vous suffit d’exécuter son nom.\n\ncas\n\n[1] 28\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous écrivons les chaînes de caractères entre guillements pour permettre à R de faire la différence entre un objet cas et le texte \"cas\".\n\n\nUne fois créés, les objets peuvent être utilisés dans d’autres commandes :\n\ncas + 5\n\n[1] 33\n\n\n\nDans votre script, créez un objet appelé region qui contient la valeur \"Mandoul\". Est-il bien apparu dans votre environnement ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN’oubliez pas que nous devons toujours entourer l’opérateur &lt;- par des espaces afin d’améliorer la lisibilité et d’éviter les erreurs.\n\nx&lt;-3     # MAUVAIS\nx &lt;- 3   # BIEN\n\n\n\n\nMettre à jour d’un objet\nNous souhaitons souvent mettre à jour la valeur stockée dans un objet. Pour ce faire, il suffit d’assigner une nouvelle valeur avec la même syntaxe que celle utilisée lors de la création de l’objet :\n\ncas &lt;- 32\n\n\nMettez à jour l’objet region avec la valeur \"Moyen Chari\".\n\n\n\nNoms d’objets\nPour nommer vos objets, il existe quelques règles (relativement) strictes :\n\nNe pas commencer par un chiffre\nNe pas utiliser d’espaces (utiliser un _ à la place)\nNe pas utiliser de valeurs réservées (comme TRUE et FALSE) ou des noms de fonctions (comme mean)\nNe pas utiliser de majuscules (c’est plus une convention qu’une règle dure)\n\nAu-delà de ces règles, il existe également des bonnes pratiques plus subjectives et des styles personnels. En règle générale, les noms doivent être courts et descriptifs :\n\na &lt;- 19                              # Pas informatif\nage_du_patient_a_l_admission &lt;- 19   # Trop long\nage &lt;- 19                            # Concis et précis\n\nDes noms clairs et informatifs contribuent à rendre votre code plus lisible, ce qui permet aux autres de le comprendre facilement sans avoir à constamment consulter le dictionnaire de données."
  },
  {
    "objectID": "sessions_core/01_introduction.html#structures-de-données",
    "href": "sessions_core/01_introduction.html#structures-de-données",
    "title": "Introduction à R",
    "section": "Structures de données",
    "text": "Structures de données\nJusqu’à maintenant, nous avons créé des objets simples qui contenaient une seule valeur. A présent nous allons nous intéresser à des structures plus complexes qui peuvent contenir des jeux de données.\n\nVecteurs\nIl est possible de rassembler plusieurs valeurs (telles que des valeurs numériques ou des chaînes de caractères) en un seul objet, appelé vecteur.\nTechniquement, il existe plusieurs types de vecteurs, dont :\n\nles vecteurs simples (ou vecteurs atomiques) ne peuvent contenir qu’un seul type de valeurs. Par exemple, un vecteur d’entiers contenant 2, 4, 6 ou un vecteur de texte contenant \"Mandoul\", \"Moyen Chari\".\nles vecteurs récursifs (généralement appelés listes) sont plus complexes et peuvent contenir plusieurs dimensions et types de données. Nous ne les aborderons pas dans cette leçon.\n\nCette leçon n’entrera pas dans les détails abstraits de ces structures et se concentrera sur celles que vous rencontrerez le plus souvent dans votre travail.\n\nVecteurs simples\nLes vecteurs simples peuvent contenir une ou plusieurs valeurs d’un seul type de données. Ils ont donc deux propriétés essentielles : une longueur et un type. Dans le cadre de ce cours, nous utiliserons indifféremment les termes “vecteur simple” et “vecteur”, comme c’est généralement le cas dans la communauté R.\nTechniquement, vous avez déjà créé vos premiers vecteurs simples lorsque vous avez construit les objets cas et region. Il s’agissait de vecteurs avec une longueur de taille une. Pour créer un vecteur avec plus d’une valeur, nous utiliserons la fonction c() (moyen mnémotechnique) :\n\ncas &lt;- c(2, 5, 8, 0, 4)\n\n\nMettez à jour cas avec les valeurs ci-dessus et mettez à jour region pour créer un vecteur de chaînes de caractères contenant les valeurs suivantes : Mandoul, Moyen-Chari, Logone Oriental, Tibesti et Logone Occidental.\n\nNous pouvons maintenant utiliser des fonctions sur les objets que nous avons créés :\n\nmean(cas)  # Calcule la moyenne des valeurs stockées dans le vecteur\n\n[1] 3.8\n\ntoupper(region)  # Convertit les valeurs du vecteur en majuscules\n\n[1] \"MANDOUL\"           \"MOYEN-CHARI\"       \"LOGONE ORIENTAL\"  \n[4] \"TIBESTI\"           \"LOGONE OCCIDENTAL\"\n\n\n\nEcrivez des commandes dans votre script pour effectuer les actions suivantes :\n\ncalculer la somme des valeurs de cas avec la fonction sum()\nconvertir le texte de region en minuscules à l’aide de la fonction tolower()\n\n\n\n\n\nAccès aux valeurs d’un vecteur\nIl est possible d’accéder à une valeur d’un vecteur en donnant son indice (i.e. sa position dans le vecteur) entre crochets :\n\ncas[2]   # Deuxième valeur de cas\n\n[1] 5\n\ncas[10]  # Dixième valeur de cas\n\n[1] NA\n\n\nOups il n’y a pas de dixième valeur dans cas ! Nous reviendrons sur ce que ce NA signifie dans la section valeurs manquantes.\nNous pouvons également accéder à une plage de valeurs, comme nous pourrions le faire dans Excel. Nous utilisons l’opérateur : entre la position minimum et maximum de la plage :\n\ncas[2:4]  # de la deuxième à la quatrième valeur\n\n[1] 5 8 0\n\n\n\nAffichez la 3ème valeur du vecteur region.\nAccédez aux valeurs “Mandoul” et “Moyen-Chari” du vecteur region.\n\n\n\nData frames\nLes data frames sont des structures tabulaires / tableaux en 2D avec des lignes et des colonnes. Il s’agit d’une structure très similaire à celle d’un “tableau” dans Excel. En tant qu’épidémiologistes, ce type d’objet est l’un des plus utiles et vous l’utiliserez quotidiennement pour stocker des jeux de données (des listes linéaires par exemple).\n\nCréation d’un data frame\nNous créons un data frame avec la fonction data.frame() :\n\ndata.frame(col1 = c(1, 4, 2, 9),\n           col2 = c(\"un peu de texte\", \"plus de text\", \"Salut !\", \"les epidemiologistes !\"))\n\n  col1                   col2\n1    1        un peu de texte\n2    4           plus de text\n3    2                Salut !\n4    9 les epidemiologistes !\n\n\nIci, on a crée col1 à partir d’un vecteur numérique, et col2 à partir d’un vecteur de chaînes de caractères. Nous avons choisi les noms des colonnes (col1 et col2), ce qui est normal, mais vous pouvez exécuter le code sans nommer les colonnes pour voir comment R crée lui même des noms.\n\nDans votre script, créez un data frame nomé data_cas qui contient cas dans une colonne et region dans l’autre.\n\n\n\nExploration d’un data frame\nL’objet data_cas devrait maintenant apparaître dans votre environnement. Vous pouvez cliquer sur le cercle bleu avec un triangle blanc pour dérouler des informations supplémentaires, ou cliquer sur son nom pour le visualiser dans un onglet dans le même volet que votre script.\n\n\n\nLe data frame data_cas apparaît désormais dans l’onglet Environnement.\n\n\nIl existe plusieurs fonctions pratiques pour explorer un data frame :\n\nExécutez les commandes suivantes et essayez de déterminer le type d’informations qu’elles renvoient.\n\nstr(data_cas)     # STRucture de l'object\ndim(data_cas)     # DIMension de l'object\nnrow(data_cas)    # Nombre de lignes (row = ligne)\nncol(data_cas)    # Nombre de COLonnes\nnames(data_cas)   # noms des colonnes\n\n\nPratiquons un peu plus ! R est livré avec quelques data frames intégrés auxquels il est possible d’accéder directement, dont un appelé iris. C’est pratique pour cette session car nous n’avons pas encore appris à importer des données dans R (ne vous inquiétez pas, nous travaillerons sur des données de liste linéaire dès la prochaine session !).\nNous pouvons afficher les premières lignes de ce data frame grâce à la fonction head() [head = la tête en anglais] :\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nCombien de lignes et de colonnes y a-t-il dans iris? Quels sont les noms des colonnes de ce data frame ?\n\n\n\nAccéder aux données d’un data frame\nEn R, il existe plusieurs méthodes pour accéder aux lignes et/ou colonnes d’un data frame. Dans cette session d’introduction, nous nous concentrerons sur la syntaxe [row, column].\nNous pouvons utiliser un numéro (ou un intervalle) de ligne pour extraire des lignes, et des numéros (ou un intervalle) de colonnes pour extraire les colonnes. Ont peut également utiliser le nom des colonnes pour y accéder.\n\ndata_cas[1, 2]    # Afficher la valeur de la ligne 1, deuxième colonne\n\n[1] \"Mandoul\"\n\ndata_cas[1, \"region\"]   # Afficher la valeur de la lignbe 1, pour la colonne région\n\n[1] \"Mandoul\"\n\n\nSi nous voulons isoler toutes les lignes (ou colonnes), nous pouvons simplement laisser un espace à la place du numéro/nom :\n\ndata_cas[1, ]  # Extrait la première ligne (garde toutes les colonnes)\n\n  cas  region\n1   2 Mandoul\n\ndata_cas[2:4, ]   # Valeurs des lignes 2 à 4, pour toutes les colonnes\n\n  cas         region\n2   5       Sud Kivu\n3   8 Kasai oriental\n4   0          Kasai\n\ndata_cas[ , \"region\"]   # Garde toutes les lignes mais que la colonne région\n\n[1] \"Mandoul\"        \"Sud Kivu\"       \"Kasai oriental\" \"Kasai\"         \n[5] \"Haut Katanga\"  \n\n\nNous pouvons même sélectionner plusieurs indices non consécutifs en utilisant un vecteur :\n\ndata_cas[c(1, 3), ]  # Ligne 1 et 3 (toutes les colonnes)\n\n  cas         region\n1   2        Mandoul\n3   8 Kasai oriental\n\n\nSoyez attentifs, le type de l’objet renvoyé par [ ] dépend de l’indexation utilisée :\n\nstr(data_cas[1 , ])   # Renvoit un data frame\n\n'data.frame':   1 obs. of  2 variables:\n $ cas   : num 2\n $ region: chr \"Mandoul\"\n\nstr(data_cas[ , 1])   # Renvoit un vecteur\n\n num [1:5] 2 5 8 0 4\n\n\nUne syntaxe simplifiée existe pour extraire des colonnes d’un data frame :\n\ndata_cas[2]           # Renvoit la deuxième colonne (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\ndata_cas[\"region\"]    # Renvoit la colonne région (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\n\n\nEcrivez le code pour :\n\nextraire la troisième valeur de la colonne region de votre data frame\nextraire les deuxième et troisième valeurs de la colonne cas\ncalculer la somme des valeurs de la colonne cas"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-missing-values",
    "href": "sessions_core/01_introduction.html#sec-missing-values",
    "title": "Introduction à R",
    "section": "Valeurs manquantes",
    "text": "Valeurs manquantes\nEn tant qu’épidémiologistes, nous sommes constamment confrontés aux données manquantes. Dans R, celles-ci sont codées à l’aide d’une valeur spéciale : NA [signifiant Not Available]. La valeur NA n’a pas de type fixe, elle prend celui des valeurs qui l’entourent. Par exemple, un NA dans une colonne numérique est traitée comme une valeur numérique. Nous aurons des occasions de manipuler les NA dans la suite du cours."
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-functions",
    "href": "sessions_core/01_introduction.html#sec-functions",
    "title": "Introduction à R",
    "section": "Fonctions",
    "text": "Fonctions\nLes fonctions sont des objets qui contiennent des commandes (au lieu de valeurs) qui sont exécutées chaque fois que la fonction est lancée. Vous êtes sans doute familiers avec les fonctions dans Excel, telles que la fonction SOMME() ou la fonction MOYENNE(). Bonne nouvelle, les fonctions sont similaires dans R !\nLa majorité des fonctions que vous allez utiliser ont besoin d’informations complémentaires : a minima des données, mais aussi d’autres paramètres. On appelle ces informations des arguments. Les arguments sont normalement nommés.\nPar exemple, lorsque nous avons exécuté la commande sum(cas), nous avons fourni le vecteur cas comme premier (et seul) argument de la fonction sum().\nParmis les arguments d’une fonction, certains peuvent être obligatoires, d’autres facultatifs. Le premier argument est presque toujours obligatoire et est souvent un data frame ou un vecteur de données. Comme c’est un argument évident, on omet souvent son nom (il vous a sans doute semblé naturel de taper mean(cas) au lieu de mean(x = cas)).\nLes arguments facultatifs, en revanche, sont généralement utilisés avec neur nom. Par exemple : mean(cas, na.rm = TRUE). Les arguments facultatifs sont souvent fournis avec des valeurs par défaut raisonnables, ce qui fait que l’utilisateur ne les spécifie que lorsqu’il a besoin de changer ces valeurs par défaut. Par exemple, l’argument na.rm de la fonction mean() controle comment les valeurs manquantes sont gérées lors du calcul de la moyenne [“na” en référence aux valeurs manquantes NA, et “rm” comme raccourci de “ReMove”, que l’on peut traduire dans ce contexte par enlever ou ignorer]. Par défault, la valeur de na.rm est FALSE Ainsi, par défaut, la moyenne de données avec des valeurs manquantes renverra toujours NA :\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nCeci est vrai pour de nombreuses opérations arithmétiques dans R. Si l’on veut que que R calcule la moyenne sur toutes les données disponibles et ignore les valeurs manquantes, nous devons explicitement fournir l’argument na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nAstuce\n\n\n\n\nLes arguments sont séparés par des virgules.\nCes virgules doivent toujours être suivies d’un espace\nChaque fois qu’un argument nommé est utilisé, l’attribut = doit être entouré d’espaces :\n\n\nmean(cas,na.rm=TRUE)     # MAUVAIS\nmean(cas, na.rm = TRUE)  # BON\n\nSi vous écrivez une commande avec de nombreux arguments, séparez chaque argument sur sa propre ligne pour améliorer la lisibilité :\n\nmean(cas, \n     na.rm = TRUE) \n\n\n\nQue se passe-t-il si l’on fournit plusieurs arguments dans le désordre ? Si vous avez nommé les arguments la fonction s’exécutera correctement, mais le code sera contre-intuitif et peu lisible. Nous vous conseillons de respecter l’ordre standard, en plaçant les arguments obligatoires tels que les données en premier.\n\n# Fonctionnel mais dur à lire\nmean(na.rm = TRUE,  \n     x = cas) \n\n# mieux\nmean(cas,         \n     na.rm = TRUE)\n\nEn revanche, si vous ne nommez pas les arguments et les passez dans le désordre, alors la fonction ne fonctionnera pas comme prévu, voire renverra une erreur :\n\nmean(TRUE, cas)  # Pas ce que vous attendez"
  },
  {
    "objectID": "sessions_core/01_introduction.html#terminé",
    "href": "sessions_core/01_introduction.html#terminé",
    "title": "Introduction à R",
    "section": "Terminé !",
    "text": "Terminé !\nC’est tout pour cette session, bravo pour vos débuts avec R et RStudio !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/02_import_data.html",
    "href": "sessions_core/02_import_data.html",
    "title": "Importation des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets dans la session\nEcrire des chemins d’accès aux fichiers robustes\nImporter et inspecter des données dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des données s’appliquent aussi à votre code : on souhaite écrire un script qui fonctionne maintenant, mais également dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider à aller dans cette direction, et la première est d’avoir un code source propre et bien organisé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#objectifs",
    "href": "sessions_core/02_import_data.html#objectifs",
    "title": "Importation des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets dans la session\nEcrire des chemins d’accès aux fichiers robustes\nImporter et inspecter des données dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des données s’appliquent aussi à votre code : on souhaite écrire un script qui fonctionne maintenant, mais également dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider à aller dans cette direction, et la première est d’avoir un code source propre et bien organisé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "href": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "title": "Importation des données",
    "section": "Mise en place du projet",
    "text": "Mise en place du projet\n\nStructure des dossiers\n\nSi ce n’est pas déjà fait, téléchargez le dossier du cours décompressez-le. Sauvegardez le dossier non compressé à un endroit non connecté à OneDrive et ouvrez-le.\n\n\n\n  Dossier du cours\n\n\n\n\nCe dossier illustre une structure typique et recommandée pour vos projets de code :\n\n📁 data\n\n📁 raw\n📁 clean\n\n📁 R\n📁 outputs\n\nCe dossier sera votre répertoire de travail pour toutes les sessions de ce cours. Vous y créerez un projet RStudio (explications ci-dessous), et y enregistrerez tous vos scripts (sous dossier R). Les données brutes se trouvent déjà dans data/raw.\n\n\nDéfinitions\nVoici deux concepts importants que nous allons rencontrer dans cette session :\nRépertoire de travail. Le répertoire de travail est l’emplacement (dossier) où votre session R en cours travaille. Si vous enregistrez un fichier, par exemple, il sera enregistré dans ce dossier par défaut. De même, Si vous ouvrez un fichier, ce dossier sera affiché par défaut. Tous les chemins relatifs auront ce dossier pour origine. Par défaut, R choisit généralement votre dossier “Documents” comme répertoire de travail sur les machines Windows.\nRacine. La racine fait référence au niveau de dossier le plus élevé du répertoire de travail. Si le dossier de votre cours s’appelle FETCHR la racine se trouverait directement à l’intérieur de celui-ci (et non dans l’un de ses sous-dossiers comme R ou data).\n\n\nProjets RStudio\nUn projet RStudio est outil qui va faciliter votre vie et aider RStudio à trouver les différents fichiers.\nPour rappel, votre interface doit ressembler à ceci :\n\n\n\n\n\n\nFigure 1: Capture d’écran d’une interface RStudio typique\n\n\n\n\nOuvrez RStudio et suivez ces étapes pour créer un nouveau projet :\n\ncliquez sur File &gt; New Project &gt; Existing Directory &gt; Browse,\nnaviguez jusqu’au dossier du cours (en l’ouvrant)\ncliquez sur Create Project.\n\n\n\nDans l’explorateur Windows, examinez le dossier du cours. Vous devriez maintenant voir un nouveau fichier avec l’extension .Rproj qui a une petite icône bleue avec un R au milieu\n\n\n\n\nIcône associée aux projets RStudio\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi vous ne voyez pas ce fichier, c’est probablement parce qu’il est caché par défaut sur votre ordinateur. Pour modifier ce paramètre dans l’explorateur Windows, allez dans le menu Afficher et sélectionnez Extensions de noms de fichier.\n\n\nLorsque vous ouvrez un projet RStudio, RStudio démarre une nouvelle session R spécifique à ce projet, ouvre les fichiers associés et définit la racine de votre dossier comme répertoire de travail. Une conséquence immédiate est que le panneau Files en bas à droite de l’interface montre les sous dossiers présents dans le répertoire de travail, i.e. votre dossier de cours.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est fortement recommandé de mettre en place un projet RStudio distinct pour chacune de vos analyses afin de garantir que les fichiers de vos projets restent organisés.\n\n\nIl existe plusieurs façons d’ouvrir un projet RStudio :\n\nUtilisez le menu RStudio File &gt; Open Project puis sélectionnez le fichier .Rproj approprié\nCliquez sur le bouton Project: (none) en haut à droite de l’interface RStudio\nNaviguez dans l’explorateur de fichiers Windows jusqu’à votre dossier de cours et double-cliquez sur le fichier avec l’extension .Rproj\n\n\n\nLes options de RStudio\nAvant de poursuivre, allons modifier certaines des options de RStudio qui peuvent causer des problèmes.\n\nOuvrez les options globales (Tools &gt; Global Options) et ouvrez l’onglet General (menu de gauche). Déselectionnez toutes les cases des sections R Sessions, Workspace et History.\n\n\n\n\nCapture d’écran des options de RStudio\n\n\nLorsque ces options sont activées, RStudio enregistre les objets de votre environnement et les charge à chaque fois que vous ouvrez une nouvelle session R. Ca semble être une bonne idée, mais il est en fait préférable de toujours commencer votre travail à partir d’une session R vide afin d’éviter les erreurs.\n\n\n\n\n\n\nImportant\n\n\n\nN’oubliez pas que toutes les commandes nécessaires au nettoyage et à l’analyse de vos données doivent être enregistrées explicitement dans un script, dans le bon ordre. Faire retourner le script devrait arriver aux mêmes résultats que précédement.\n\n\n\n\nCréation d’un nouveau script\n\nOuvrez un nouveau script et enregistrez-le dans le sous-dossier R de votre projet sous le nom import_data.R.\nAjoutez des métadonnées au début du script, comme recommandé lors première session, en utilisant des commentaires. Veillez à inclure :\n\nLe titre\nL’auteur du script\nLa date de création\nUne description rapide de ce que fait le script\n\n\nNous sommes prêts à commencer à coder"
  },
  {
    "objectID": "sessions_core/02_import_data.html#sec-packages",
    "href": "sessions_core/02_import_data.html#sec-packages",
    "title": "Importation des données",
    "section": "Paquets",
    "text": "Paquets\nLes paquets [packages] sont des collections de fonctions qui étendent les fonctionalités de R. Vous en utiliserez un grand nombre pendant ce cours et dans votre travail quotidien. R étant open-souce, les packages sont téléchargeable et utilisable gratuitement.\n\n\n\n\n\n\nNote\n\n\n\nDans ce cours, nous utiliserons une convention commune qui est de référencer les paquets entre {}. Par exemple {ggplot2} est le nom du paquet ggplot2 qui contient des fonctions pour créer des graphes, telles que ggplot(), geom_point() etc…\n\n\n\nInstallation\nLa fonction install.packages() télécharge et installe un nouveau paquet sur votre ordinateur, dans la bibliothèque de paquets associée à R. Vous n’avez à faire cette opération qu’une seule fois par paquet et ordinateur.\n\ninstall.packages(\"here\") # installe le paquet {here} \n\nN’oubliez pas de mettre le nom du paquet entre guillemets lorsque vous utilisez la commande install.packages(). Que se passe-t-il si vous ne le faites pas ?\n\n\n\n\n\n\nNote\n\n\n\nSi vous suivez cette session dans le cadre d’un cours, pour éviter tout problème potentiel de connectivité internet pendant la formation, nous vous avons déjà fait installer la plupart des paquets du cours.\nSi vous suivez ce tutoriel seul ou si vous n’avez pas encore installé les paquets, vous devrez installer manuellement chaque nouveau paquet que nous rencontrerons avec la fonction install.packages().\n\n\n\n\nUtilisation\nUne fois qu’un paquet est installé, il faut indiquer à R que nous souhaitons l’utiliser pour une session donnée en le chargeant dans la session avec la fonction library().\n\nlibrary(here) # charge le paquet {here} dans la session\n\n\nUtilisez la fonction library() pour charger les paquets here et rio qui seront utilisés aujourd’hui.\n\nIl se peut que vous obteniez parfois un message d’avertissement signalant que certaines fonctions ont été masquées ou que la version actuelle du paquet a été construite pour une version différente de R. Ces messages ne doivent pas vous inquiéter, mais il faut les lire et essayer de comprendre ce qui se passe.\n\nExécutez le code suivant. Comprenez-vous le message d’erreur ?\n\nlibrary(ggplot)\n\n\nLe code ci-dessus génère une erreur car il y a une faute de frappe dans le nom du paquet, et vous avez donc essayé de charger un paquet qui n’existe pas. Rappelez-vous que R est pénible, et en particulier est sensible à la casse : beaucoup de vos erreurs viendront de petites fautes dans les noms de fonctions ou d’objets. Ici, par exemple, nous voulions charger le paquet ggplot2 mais nous avons écrit ggplot à la place.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est recommandé d’avoir une section au début de votre script qui charge tous les paquets dont vous aurez besoin dans votre script en un seul endroit :\n\n# Packages ----------------------------\nlibrary(tidyverse)   # manipulation de données\nlibrary(lubridate)   # manipulation des dates\n\nCelà permet de savoir rapidement quels paquets doivent être installés pour exécuter un script.\n\n\n\nCréez une section “Paquets” dans votre script à l’aide de commentaires\n\n\n\nMettre à jour les paquets\nR dispose d’une communauté de développeurs très active et il est assez courant que les paquets soient mis à jour, avec de nouvelles fonctionalités ou des corrections de bugs. Pour mettre à jour les paquets de votre bibliothèque, rendez-vous dans l’onglet Packages du panneau inférieur droit et cliquez sur Update. N’oubliez pas que vous devez être connecté à internet pendant ce processus.\n\n\n\n\n\n\nImportant\n\n\n\nLa mise à jour de certains paquets peut parfois changer le comportement de certaines fonctions, ce qui peut casser votre code. Pas de panique. La meilleure pratique consiste à adapter votre code mais, dans le pire des cas, vous pouvez installer une ancienne version du paquet incriminé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#importation-de-données",
    "href": "sessions_core/02_import_data.html#importation-de-données",
    "title": "Importation des données",
    "section": "Importation de données",
    "text": "Importation de données\n\nTrouver son chemin…\nPour ouvrir un fichier dans R, vous devez fournir un chemin d’accès au fichier. Un chemin d’accès est simplement un (long) nom pour un fichier qui inclut son emplacement sur votre ordinateur. Les chemins d’accès peuvent être absolus ou relatifs.\n\nChemins d’accès absolus\nLes chemins d’accès absolus sont spécifiques à votre ordinateur et vont jusqu’au niveau de votre disque dur. Par exemple : D:/OneDrive - MSF/Documents/monitoring/cholera/fancy_project/data/raw/example_linelist.xlsx. Il est clair que ce chemin ne fonctionne que sur un ordinateur particulier.\nL’utilisation de chemins absolus encodés en dur est fortement déconseillé car cela rend votre code fragile et augmente la maintenance : en effet, les chemins devront tous être mis à jour chaque fois quelqu’un d’autre exécute votre code, ou que le dossier du projet est déplacé sur votre ordinateur.\n\n\nChemins d’accès relatifs\nLes chemins relatifs sont définis par rapport à votre répertoire de travail. Comme l’emplacement du fichier .Rproj définit le répertoire de travail, les chemins sont relatifs à cette racine. Pour vous, un chemin relatif ressemblera à ça : data/raw/example_linelist.xlsx.\nCela signifie que tant que la structure interne du dossier contenant votre projet est préservée, le chemin d’accès relatif sera valable quelque soit l’ordinateur.\n\n\nChemins d’accès robustes avec la fonction here()\nLe paquet {here} dispose d’une fonction here() qui aide à créer des chemins d’accès. Elle présente deux avantages :\n\nElle détecte la présence d’un fichier .Rproj et est capable de construire un chemin absolu à partir d’un chemin relatif dans votre projet RStudio.\nElle choisit automatiquement le séparateur adapté à votre système d’exploitation : /, \\ ou //.\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"/tmp/RtmpZ3YPU1/file89d70775e0d67/data/raw/example_linelist.xlsx\"\n\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"/tmp/RtmpZ3YPU1/file89d70775e0d67/data/raw/example_linelist.xlsx\"\n\n\nVoyez comme nous n’avons défini que le chemin relatif et la fonction a reconstitué le chemin absolu. Celà marchera donc sur l’ordinateur d’un collègue, y compris sur un autre système d’exploitation, du moment que la structure du répertoire de travail est intacte.\nNous vous encourageons fortement à utiliser here() chaque fois que vous devez créer un chemin d’accès à un fichier.\n\nExécutez le code ci-dessus dans la console. Quel chemin d’accès here(\"data\", \"raw\") vous donne-t-il ?\n\n\nUtilisez here() pour créer le chemin vers le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx.\n\n\n\n\n\n\n\nImportant\n\n\n\nhere() crée une chaîne de caractères contenant l’adresse d’un fichier, mais ne vérifie pas si ce fichier existe réellement sur votre ordinateur. Si le fichier est absent ou s’il y a une faute de frappe dans votre code, vous obtiendrez une erreur lors de l’utilisation du chemin ainsi créé. Vous pouvez tester si un fichier existe à cette adresse avec la fonction file.exists().\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nOn veut souvent définir plusieurs chemins dans un projet (données brutes, données propres, où sauver les graphes etc.). C’est une bonne pratique que de créer une nouvelle section au début de votre script, après le chargement des paquets, pour définir et stocker les chemins d’accès dans des objets.\n\n\n\n\n\nImporter les données\nDans R, différents formats de fichiers sont importés par différentes fonctions spécialisées, ce qui est fastidieux à mémoriser et à charger. La fonction import() du paquet {rio} nous fait gagner du temps en reconnaissant l’extension des fichier et en appelent automatiquement une fonction spécialisée pour charger les données.\nComme import() ne fait qu’appeler d’autres fonctions en arrière-plan, il est possible qu’elle ait besoin d’arguments optionnels spécifiques pour certains types de fichier.\n\n\n\n\n\n\nAstuce\n\n\n\nLa (longue) liste des types de fichiers pris en charge par {rio} est sur le site du paquet. Dans la suite de la leçon, nous nous concentrerons sur l’importation de données à partir de fichiers Excel .xlsx.\n\n\n\nImport de la première feuille\nAu minimum la fonction import() a besoin qu’on lui donne le chemin du fichier avec l’argument file :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"))\n\nNotez que nous avons imbriqué la commande here() à l’intérieur de la commande import(). L’imbrication de fonctions est autorisée et même courrante en R. R évalue les fonctions imbriquées de l’intérieur (here()) à l’extérieur (import()). La valeur renvoyée par here() est donc utilisée comme valeur d’entrée d’import().\n\nImportez le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx en utilisant here() et import().\n\nSi votre importation a fonctionné correctement, R affichera les données dans la console mais ne les enregistrera pas dans l’environnement car nous ne les avons pas assignées à un objet.\n\nRéimportez vos données, mais cette fois-ci, sauvegardez-les dans un objet appelé df_linelist.\n\n\n\n\n\n\n\nAstuce\n\n\n\nSi votre jeu de données est très gros, il vaut mieux éviter de l’afficher dans la console…\n\n\n\n\nImport d’une autre feuille\nComme vous venez de le voir, la fonction import() importe la première feuille d’un fichier Excel par défaut. Il est cependant possible de passer le numéro de la feuille ou son nom (en chaîne de caractères) à l’argument which :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"),  # chemin\n       which = 2)                                            # spécifie la deuxième feuille\n\nNotez que l’argument which est spécifique aux types de fichiers comportant plusieurs feuilles, tels que les fichiers Excel ou .Rdata. Si vous essayez de l’utiliser sur un fichier .csv l’argument sera ignoré."
  },
  {
    "objectID": "sessions_core/02_import_data.html#aperçu-des-données",
    "href": "sessions_core/02_import_data.html#aperçu-des-données",
    "title": "Importation des données",
    "section": "Aperçu des données",
    "text": "Aperçu des données\nNous avons importé un jeu de données dans R et l’avons assigné à un objet (df_linelist). Nous pouvons maintenant inspecter le data frame créé pour vérifier que l’export s’est bien passé, et commencer à évaluer le nettoyage à faire.\nNous pouvons commencer par jeter un coup d’œil rapide aux premières lignes du data frame à l’aide de la fonction head(). Son premier argument est le data frame à inspecter et le second, n, accepte un nombre de lignes à afficher (optionnel).\n\nhead(df_linelist, n = 10) # Affiche les 10 premières lignes\n\n\nUtilisez head() pour examiner les 12 premières lignes de df_linelist.\n\nNous pouvons inspecter la structure du data frame à partir de l’onglet Environnement dans le panneau supérieur droit. Nous pouvons également visualiser le data frame dans le le visualiseur de données de RStudio (en haut à gauche).\n\nCliquez sur le bouton rond bleu à côté de df_linelist dans votre environnement pour examiner sa structure. Cliquez ensuite sur le nom du data frame pour le visualiser.\n\nLe visualiseur permet d’afficher le data frame comme dans un tableur et est un moyen pratique d’examiner rapidement vos données. Vous pouvez trier et filtrer vos données dans cet onglet mais ces actions ne modifieront pas l’objet df_linelist. Le visualiseur peut également être ouvert en utilisant directement la fonction View() sur le data frame."
  },
  {
    "objectID": "sessions_core/02_import_data.html#cest-fini",
    "href": "sessions_core/02_import_data.html#cest-fini",
    "title": "Importation des données",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo et n’oubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "href": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "title": "Importation des données",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices supplémentaires\n\nUtilisez dim() pour examiner les dimensions de votre data frame.\nUtilisez str() pour vérifier le type de données de chaque colonne. Voyez-vous quelque chose d’étrange ? N’oubliez pas que vous pouvez également utiliser des fonctions telles que is.character() et is.numeric() si vous souhaitez tester le type d’une colonne particulière.\nEn utilisant une fonction apprise lors de la première session, pouvez-vous extraire les noms des colonnes du data frame ? Ces résultats correspondent-ils à ce que vous voyez lorsque vous ouvrez les données dans Excel ?\nEssayez d’exécuter la fonction summary() sur votre data frame. Qu’est ce que le résultat vous apprend sur les variables ?\n\n\n\nRessources complémentaires\n\nLe site web de {rio}\nPlus d’exemples sur l’importation de données de différents types de fichiers"
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html",
    "href": "sessions_companion/surveillance_companion.html",
    "title": "Surveillance",
    "section": "",
    "text": "Travailler les compétences acquises dans les deux modules FETCH-R (importation, nettoyage et visualisation des données).\nAnalyser des données de surveillance rougeole pour détecter les alertes et aider à prioriser quelles alertes doivent être approfondies avec une enquête sur le terrain."
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#objectifs",
    "href": "sessions_companion/surveillance_companion.html#objectifs",
    "title": "Surveillance",
    "section": "",
    "text": "Travailler les compétences acquises dans les deux modules FETCH-R (importation, nettoyage et visualisation des données).\nAnalyser des données de surveillance rougeole pour détecter les alertes et aider à prioriser quelles alertes doivent être approfondies avec une enquête sur le terrain."
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#introduction",
    "href": "sessions_companion/surveillance_companion.html#introduction",
    "title": "Surveillance",
    "section": "Introduction",
    "text": "Introduction\nCette session accompagne l’étude de cas Réponse d’urgence contre la rougeole dans la région du Katanga (RDC) du module FETCH Surveillance. Ça n’a probablement pas beaucoup de sens d’essayer de le suivre sans les documents et les discussions de l’étude.\nEn ce qui concerne la partie R du module surveillance, nous nous appuierons sur les compétences acquises tout au long des modules FETCH-R, et introduirons quelques nouvelles fonctions utiles pour le nettoyage et les analyses.\n\n\n\n\n\n\nAstuce\n\n\n\nN’hésitez pas à checker vos notes, vos scripts ou les tutoriels des sessions précédentes pour vous rafraîchir sur le fonctionnement de certaines fonctions quand vous en éprouvez le besoin."
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#mise-en-place-question-2",
    "href": "sessions_companion/surveillance_companion.html#mise-en-place-question-2",
    "title": "Surveillance",
    "section": "Mise en place (Question 2)",
    "text": "Mise en place (Question 2)\nComme cette session fait partie d’un module spécifique, vous allez créer un nouveau projet RStudio. Jetez un coup d’œil à la session principale si vous ne vous rappelez plus comment faire.\n\nCréer le projet\n\n\nCréez un dossier surveillance_case_study sur votre ordinateur, associé avec le module Surveillance du FETCH. Ajoutez les sous dossiers suivants à l’intérieur :\n\n\n📁 data\n\n📁 clean\n📁 raw\n\n📁 R\n📁 outputs\n\n\nCréez un projet RStudio à la racine du dossier surveillance_case_study.\nSi vous n’avez pas encore les données, téléchargez-les.\n\n\n\n\n Télécharger les données brutes\n\n\n\n 4. Dézippez l’archive si vous venez de télécharger les données. Quelle que soit la source, enregistrez les deux fichiers Excel dans le sous dossier data/raw.  5. Créez un nouveau script import_nettoyage.R et enregistrez-le dans le sous dossier R. Ajoutez les métadonnées et une section pour charger les paquets {here}, {rio}, et {tidyverse}.\n\n\n\nImporter les données\nRappel de l’étude de cas : vous avez demandé l’accès aux données de surveillance de routine et aux données de laboratoire au MSP de la RDC. Le ministère a accepté de les partager avec vous toutes les semaines. Vous recevez le premier fichier à la semaine 20 en 2022 (note : les données sur lesquelles nous travaillerons sont simulées).\n\nSi vous ne l’avez pas déjà fait, ouvrez les deux fichiers dans un tableur (Excel ou autre) pour les inspecter avant l’importation.\n\nLe jeu de données de surveillance a l’air facile à importer. En revanche, le jeu de données laboratoire pourrait vous inquiéter, avec ses lignes supplémentaires avant les données… Heureusement, la fonction import() que nous utilisons a un argument skip qui permet de gérer ce cas courant :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nimport(\n  here(\"data\", \"raw\", \"fichier_exemple.xlsx\"), \n  skip = 3  # Sauter les trois premières lignes, l'import commence à la ligne 4\n) \n\n\n\nAjoutez une section pour l’import des données à votre script.\nImportez le jeu de données surveillance et stockez le dans un objet df_surv_brut. Ensuite, importez le jeu de données laboratoire et stockez le dans un objet df_labo_brut.\nVérifiez que l’importation s’est bien passée pour les deux data frames (vous avez plusieurs outils à votre disposition : Viewer, dimensions de l’objet, haut et bas du data frame…)."
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#nettoyage-question-2-and-3",
    "href": "sessions_companion/surveillance_companion.html#nettoyage-question-2-and-3",
    "title": "Surveillance",
    "section": "Nettoyage (Question 2 and 3)",
    "text": "Nettoyage (Question 2 and 3)\nMaintenant que les données sont importées, nous pouvons effectuer quelques vérifications dessus, et les nettoyer.\n\nDonnées de surveillance (Q2)\n\nInspection rapide\nPendant l’étude de cas vous n’aurez peut-être pas le temps d’inspecter et nettoyer toutes les colonnes. Nous vous proposons donc de vous focaliser sur quelques colonnes clés : zone_sante, semaine, totalcas et totaldeces.\n\n\n\n\n\n\nNote\n\n\n\nSi vous revenez sur le tutoriel plus tard ou finissez en avance, n’hésitez pas à vérifier la qualité des autres variables, et à recouper les informations de différentes colonnes. Nous vous renvoyons à la discussion lors de l’étude ou aux documents du module de gestion des données pour des idées de vérifications à effectuer.\n\n\n\nAjoutez une section pour l’exploration et le nettoyage des données de surveillance dans votre script.  Maintenant, explorez le data frame et répondez aux questions suivantes :\n\nQuels sont les noms des colonnes ?\nCombien de provinces y a-t-il dans le jeu de données actuel ? Cela correspond-il à ce que vous attendez ?\nCombien de zones de santé y a-t-il dans le jeu de données ? Cela correspond-il à ce que vous attendez ?\nQuel est la plage des semaines ?\nQuelle est la valeur minimale de totalcas ?\nQuel est le maximum de totaldeces ?\nRemarquez-vous des données manquantes pour les colonnes ci-dessus ? Les chaînes de caractère (rappel : le texte) sont-elles propres ?\n\n\n\n\nNettoyer les chaînes de caractères\nMaintenant que nous avons une meilleure idée de l’état des données, nettoyons-les. Nous allons écrire un pipeline de nettoyage (ou chaîne de commandes) comme dans les modules R précédents (voir votre code à la fin du module de nettoyage).\n\n\n\n\n\n\nAstuce\n\n\n\nPour faciliter le débogage de la chaîne de commandes, ajoutez et testez les étapes unes par unes !\n\n\nNous allons améliorer un peu les colonnes de texte afin d’éliminer des problèmes potentiels :\n\npasser tout en minuscules (homogénéise)\nsupprimer les espaces surnuméraires (éventuels)\nremplacer - et les espaces par _.\n\nPeut être que vous n’aurez pas le temps de faire ces étapes pour toutes les colonnes. Pour commencer, choisissez une de ces deux colonnes : zone_sante ou prov pour appliquer les instructions. Vous pourrez faire les autres plus tard.\n\nCommencez un pipeline de nettoyage avec un mutate() pour transformer la colonne de votre choix en minuscules.\n\nNous allons maintenant voir deux petites fonctions très utiles pour le nettoyage du texte. La première est la fonction str_squish() du paquet {stringr} (la page d’aide), qui supprime les espaces au début ou à la fin des chaînes de caractères, et les espaces surnuméraires ou qu’ils soient :\n\nexemples &lt;- c(\" Espaces au début et à la fin     \",\n              \"Espaces     multiples\",\n              \" Tous les     problèmes  \")\n\nstr_squish(exemples)\n\n[1] \"Espaces au début et à la fin\" \"Espaces multiples\"           \n[3] \"Tous les problèmes\"          \n\n\nL’autre fonction, str_replace (également du paquet {stringr}) remplace un bout de texte dans une chaîne de caractères par un autre bout de texte, sans surprise. L’argument pattern accepte le texte à remplacer, et l’argument replacement le texte à utiliser comme remplacement.\n\nstr_replace(\n  \"HAUT-KATANGA\",    # Le texte sur lequel on travaille (peut être une colonne)\n  pattern = \"-\",     # Le bout à remplacer\n  replacement = \"_\"  # Le remplacement\n)\n\n[1] \"HAUT_KATANGA\"\n\n\n\nAjoutez des lignes à votre mutate pour, sur la colonne de votre choix :\n\nNettoyer les espaces\nChanger les - et les espaces en _ (deux étapes)\n\nLe début d’au moins une des colonnes devrait ressembler à :\n\n\n  pays     province     zone_sante  maladie\n1  rdc haut_katanga mufunga_sampwe rougeole\n2  rdc haut_katanga        sakania rougeole\n3  rdc haut_katanga        mitwaba rougeole\n4  rdc haut_katanga kilela_balanda rougeole\n5  rdc haut_katanga         likasi rougeole\n6  rdc haut_katanga         kikula rougeole\n\n\nStockez le résultat dans un data frame df_surv.\n\n\n\nEnregistrer les données nettoyées\n\nUtilisez le paquet {rio} pour exporter df_surv vers un fichier .rds appelé data_ids_2022-20_clean dans le sous dossier data/clean de votre projet.\n\n\n\n\nDonnées labo (Q2)\nNous allons suivre les mêmes étapes pour le jeu de données laboratoire. Nous nous focaliserons sur les colonnes zone_sante, igm_rougeole et igm_rubeole.\n\nInspection rapide\n\nInspectez les colonnes mentionnées, et les dimensions du data frame.\nQuelles sont les catégories des colonnes igm_rougeole et igm_rubeole ? Quel type de nettoyage sera à effectuer dessus ?\n\n\n\nNettoyage et recodage\n\n\nDémarrez un nouveau pipeline de nettoyage pour les données labo. Choisissez une colonne de texte et passez là en minuscules, puis supprimez les espaces surnuméraires. Enfin, remplacez les espaces et les - par _.\nRecodez au moins une des colonnes igm_rougeole ou igm_rubeole pour que les catégories soient negatif, positif et indeterminé.\nStockez la version nettoyée dans un data frame df_labo\n\nL’en-tête des colonnes nettoyées devrait maintenant être :\n\n\n   zone_sante igm_rougeole igm_rubeole\n1     kambove      negatif     negatif\n2     kambove      negatif     negatif\n3     kambove      negatif     positif\n4     kambove      negatif     negatif\n5     kambove      negatif     positif\n6     kambove      negatif     negatif\n7     kambove      negatif     negatif\n8     kambove      negatif     positif\n9      manika      negatif     negatif\n10  kamalondo      negatif     negatif\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\n\n\nVous pouvez utiliser la fonction case_when() pour recoder les colonnes contenant les résultats des tests anticorps.\n\n\n\n\n\nEnregistrer les données nettoyées\n\nExportez le data frame df_labo vers un fichier .rds appelé df_labo_2022-w20_clean dans le sous dossier data/clean de votre projet.\n\n\n\n\nAller plus loin\nVous êtes arrivés au bout de la question 2. Si vous avez terminé en avance, utilisez les fonctions vues pour nettoyer les autres colonnes de texte dans les deux data frames, et recodez les deux colonnes IGM dans les données labo.\nSi vous avez encore du temps, inspectez vos données plus avant :\n\nAffichez la zone de santé pour laquelle les totaux par groupe d’âge sont différents de la colonne total (pour les cas, puis pour les décès)\nEst-ce qu’il y a une ZS où le nombre de décès est plus élevé que le nombre de cas ?\nY a-t-il des lignes dupliquées (entièrement dupliquées, ou plusieurs valeurs pour la zone de santé et la semaine) ?\nY a-t-il des nombres de cas que vous estimez aberrants ?\n\n\n\nDonnées de surveillance complétées (Q3)\nDurant l’inspection des données vous avez du vous rendre compte qu’il y a des semaines manquantes pour certaines ZS dans les données de surveillance. Normalement, vous avez discuté les raisons possibles et des problèmes associés en plénière. Dans ce tutoriel, nous allons fournir le code pour compléter le data frame surveillance pour que toutes les ZS aient toutes les semaines (en faisant l’hypothèse que les semaines manquantes n’ont pas eu de cas ou de décès).\nNous utiliserons la fonction complete() du paquet {tidyr} pour ajouter les lignes manquantes et remplir les colonnes contenant des nombres (totalcas et totaldeces) avec des zéros. A cause des contraintes de temps nous allons vous donner le code, mais quelques exemples et explications seront donnés dans la section Aller plus loin, que vous pourrez lire quand vous aurez le temps.\n\n\nCommencez un nouveau pipeline à partir de df_surv et ne conservez dedans que les colonnes province, zone_sante, semaine et totalcas.\nAjoutez une nouvelle étape à votre pipeline et collez le code ci-dessous pour compléter le data frame :\n\n\ncomplete(\n  # On travaille sur les combinaisons existantes de province et ZS\n  nesting(province, zone_sante),\n  \n  # On voudra toutes les semaines entre le minimum (1) et le maximum (20) de la colonne semaine\n  semaine = seq(min(semaine, na.rm = TRUE), \n                max(semaine, na.rm = TRUE)),\n  \n  # Remplir les nouvelles semaines de zeros pour ces colonnes :\n  fill = list(totalcas   = 0, \n              totaldeces = 0\n  )\n) \n\n\nStockez le résultat dans un data frame appelé df_surv_sem, qui devrait ressembler à :\n\n\n\n# A tibble: 10 × 5\n   province     zone_sante semaine totalcas totaldeces\n   &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1 haut_katanga kafubu           1        0          0\n 2 haut_katanga kafubu           2        0          0\n 3 haut_katanga kafubu           3        0          0\n 4 haut_katanga kafubu           4        0          0\n 5 haut_katanga kafubu           5        0          0\n 6 haut_katanga kafubu           6        0          0\n 7 haut_katanga kafubu           7        0          0\n 8 haut_katanga kafubu           8        0          0\n 9 haut_katanga kafubu           9        0          0\n10 haut_katanga kafubu          10        0          0\n\n\n\nexportez ce data frame dans un fichier .rds appelé data_ids_2022-w20_weeks_clean dans le sous dossier data/clean de votre projet.\n\n\n\n\nAller plus loin\nC’est la fin de la question 3. Si vous terminez en avance, finissez l’inspection des données, listez les problèmes et nettoyez les colonnes que vous savez nettoyer avant de réexporter. Si c’est fait, lisez les eplications sur la fonction complete() et allez explorer sa page d’aide."
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#définir-les-alertes-question-4",
    "href": "sessions_companion/surveillance_companion.html#définir-les-alertes-question-4",
    "title": "Surveillance",
    "section": "Définir les alertes (Question 4)",
    "text": "Définir les alertes (Question 4)\n\nPréparer le jeu de données\nNous allons continuer la préparation de data frames prêts pour l’analyse.\n\n\nSi vous n’avez pas eu le temps de nettoyer la zone de santé et la province dans les deux data frames, et les deux colonnes IGM dans le jeu de données labo, vous pouvez importer les jeux de données nettoyés :\n\n\n\n\n Télécharger données propres\n\n\n\n Dézippez l’archive et importez les données dans le sous dossier data/clean\n\nCréez un script analyse_surveillance.R dans le sous dossier R. Ajoutez les métadonnées, et une section pour importer les paquets {here}, {rio}, {tidyverse}, {lubridate} et {zoo}.\nAjoutez une section d’import des données propres et importez les fichiers .rds dans R en utilisant la fonction import() comme d’habitude (soit les vôtres, soit ceux que vous venez de télécharger). Assignez ces données nettoyées aux data frames df_surv, df_labo and df_surv_sem.\n\n\n\nSélection des ZS\nPour simplifier le travail nous allons nous focaliser sur quatre zones de santé : Dilolo, Kampemba, Kowe, et Lwamba.\n\nCommencez une nouvelle chaîne de commande à partir du data frame df_surv_sem. La première étape est de filtrer les données pour ne conserver que les zones de santé Dilolo, Kampemba, Kowe, et Lwamba.\n\n\n\nIndicateur hebdomadaire\nNotre premier indicateur regarde si une zone de santé a 20 cas suspects ou plus dans une semaine. Cet indicateur est dichotomique et ne prend en compte que les données d’une zone de santé pour une semaine donnée (ça tombe bien, ça correspond aux lignes du data frame).\n\nAjoutez un mutate() à votre chaîne pour créer une colonne cas20 qui contient la valeur 1 si une ZS a 20 cas ou plus cette semaine-là, et 0 sinon.\n Le début du data frame ressemble à ça :\n\n\n# A tibble: 10 × 6\n   province     zone_sante semaine totalcas totaldeces cas20\n   &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1 haut_katanga kampemba         1       75          0     1\n 2 haut_katanga kampemba         2       42          0     1\n 3 haut_katanga kampemba         3       46          0     1\n 4 haut_katanga kampemba         4       50          0     1\n 5 haut_katanga kampemba         5       43          0     1\n 6 haut_katanga kampemba         6       33          0     1\n 7 haut_katanga kampemba         7       45          0     1\n 8 haut_katanga kampemba         8       52          0     1\n 9 haut_katanga kampemba         9       38          0     1\n10 haut_katanga kampemba        10       46          0     1\n\n\n\n\n\nIndicateur cumulé\nNotre second indicateur regarde si une zone de santé compte plus de 35 cas suspects cumulés en trois semaines. C’est un peu plus compliqué à calculer que l’indicateur hebdomadaire : pour chaque zone de santé, il faut calculer la somme des cas par fenêtres de trois semaines, mais les groupes ne sont pas fixes, ils glissent dans le temps. Nous entrons ici dans le domaine des moyennes/sommes/etc. mobiles ou glissantes…\n\nSomme cumulée\nNous allons utiliser la fonction rollapply() du paquet {zoo} pour calculer la somme cumulée car elle est polyvalente et puissante. Comme son nom l’indique, la fonction rollapply() applique une fonction de manière glissante (roll peut être traduit ici en “rouler”) à un vecteur ou à une colonne d’un data frame.\nComme nous sommes contraint par le temps, nous allons vous fournir ici le code pour calculer la somme cumulée, et nous vous donnerons plus de détails sur la fonction dans la section Aller plus loin que vous pourrez lire quand vous aurez le temps.\nVoici comment utiliser la fonction pour une zone de santé :\n\n# Crée un mini data frame pour l'exemple\nexemple_df = data.frame(\n  province   = \"Haut Katanga\",\n  zone_sante = \"Dilolo\",\n  semaine    = 1:10,\n  totalcas   = rep(1, times = 10))\n\nexemple_df \n\n       province zone_sante semaine totalcas\n1  Haut Katanga     Dilolo       1        1\n2  Haut Katanga     Dilolo       2        1\n3  Haut Katanga     Dilolo       3        1\n4  Haut Katanga     Dilolo       4        1\n5  Haut Katanga     Dilolo       5        1\n6  Haut Katanga     Dilolo       6        1\n7  Haut Katanga     Dilolo       7        1\n8  Haut Katanga     Dilolo       8        1\n9  Haut Katanga     Dilolo       9        1\n10 Haut Katanga     Dilolo      10        1\n\nexemple_df |&gt; \n  mutate(cas_cumu = rollapply(\n    data  = totalcas,   # La colonne cible\n    width = 3,          # La taille de la fenêtre  \n    FUN   = sum,        # La fonction à appliquer, ici la somme\n    align = \"right\",    # On cumule les valeurs passées jusqu'à présent\n    partial = TRUE,     # Les somme partielles sont autorisées\n    na.rm = TRUE        # Argument en plus à passer à la fonction sum()\n  )\n  )\n\n       province zone_sante semaine totalcas cas_cumu\n1  Haut Katanga     Dilolo       1        1        1\n2  Haut Katanga     Dilolo       2        1        2\n3  Haut Katanga     Dilolo       3        1        3\n4  Haut Katanga     Dilolo       4        1        3\n5  Haut Katanga     Dilolo       5        1        3\n6  Haut Katanga     Dilolo       6        1        3\n7  Haut Katanga     Dilolo       7        1        3\n8  Haut Katanga     Dilolo       8        1        3\n9  Haut Katanga     Dilolo       9        1        3\n10 Haut Katanga     Dilolo      10        1        3\n\n\nOk, mais nous voudrions utiliser cette fonction dans un data frame qui contient plusieurs zones de santé, et faire la somme cumulée par zone de santé. Ce n’est pas si compliqué : nous allons trier notre jeu de données par zone de santé et semaine, puis utiliser l’argument .by dans le mutate pour effectuer les actions par zone de santé.\n\n\n\n\n\n\nNote\n\n\n\nRappelez-vous, nous avons déjà vu le .by. Nous l’avons utilisé au sein de la fonction summarize() lors de la session sur les tableaux agrégés pour faire des résumés par groupe.\nC’est la même idée aujourd’hui, sauf qu’au lieux d’utiliser une fonction qui ne renvoie qu’une seule valeur par groupe (summarize()) nous allons utiliser une fonction qui retourne une valeur par ligne (mutate()), mais prendra en compte les informations du groupe.\nPour petit rappel de comment summarize() + .by fonctionne, voici comment nous calculons le nombre total de cas suspects et décès par province :\n\ndf_surv_sem |&gt; \n  summarize(\n    .by = province,  # Fait les choses PAR province\n    cas_tot   = sum(totalcas, na.rm = TRUE),\n    deces_tot = sum(totaldeces, na.rm = TRUE)\n  )\n\n# A tibble: 4 × 3\n  province     cas_tot deces_tot\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;\n1 haut_katanga    5948        34\n2 haut_lomami     6928        70\n3 lualaba         1485         3\n4 tanganyika      7836       137\n\n\n\n\n\n\nAjoutez une étape à votre pipeline pour trier les données par province, zone de santé et semaine (dans cet ordre) avec la fonction arrange(), qui est une fonction de tri du package {dplyr}:\n\n\ndf_surv_sem |&gt;\n  arrange(province, zone_sante, semaine)\n\n\nAjoutez ensuite le code pour calculer la somme cumulée :\n\n\nmutate(\n  .by = c(province, zone_sante),\n  cas_cumu = rollapply(\n    data  = totalcas,   # La colonne cible\n    width = 3,          # La taille de la fenêtre  \n    FUN   = sum,        # La fonction à appliquer, ici la somme\n    align = \"right\",    # On cumule les valeurs passées jusqu'à présent\n    partial = TRUE,     # Les somme partielles sont autorisées\n    na.rm = TRUE        # Argument en plus à passer à la fonction sum()\n  )\n)\n\n\nMaintenant que la somme cumulée est calculée, il ne nous reste plus qu’à calculer l’indicateur dichotomique qui résume les données cumulées pour chaque semaine, puis un indicateur combiné qui résume les deux indicateurs précédents.\n\n\nAjoutez une nouvelle étape à votre pipeline pour créer une colonne cas_cumu35 qui contient 1 si la somme cumulée est supérieure ou égale à 35, et 0 sinon.\nDans le même mutate, ajoutez une colonne alerte, qui est 1 si ’l’indicateur cas20 OU l’indicateur cas_cumu35 est 1 et 0 sinon. Pour lest logique vous devrez utiliser l’opérateur | qui représente le OU logique (renverra TRUE si au moins une des conditions est remplie, à fortiori les deux).\nAssignez le résultat à un data frame data_alerte.\n\nCe data frame ressemble à ceci (quelques colonnes sont cachées pour l’affichage) :\n\n\n# A tibble: 10 × 7\n   zone_sante semaine totalcas cas20 cas_cumu cas_cumu35 alerte\n   &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 kampemba         1       75     1       75          1      1\n 2 kampemba         2       42     1      117          1      1\n 3 kampemba         3       46     1      163          1      1\n 4 kampemba         4       50     1      138          1      1\n 5 kampemba         5       43     1      139          1      1\n 6 kampemba         6       33     1      126          1      1\n 7 kampemba         7       45     1      121          1      1\n 8 kampemba         8       52     1      130          1      1\n 9 kampemba         9       38     1      135          1      1\n10 kampemba        10       46     1      136          1      1\n\n\n\n\n\n\n\nZones de santé en alerte\nMaintenant que la préparation est finie, nous pouvons enfin regarder quelles zones de santé sont en alerte dans notre jeu de données, en particulier à la semaine 20 (les données les plus récentes selon l’étude de cas).\n\nAffichez les données filtrées pour ne voir que ce qui se passe à la semaine 20. Quelle zones sont en alerte en ce moment ?\nCréez un vecteur zs_alerte qui contient le nom des zones de santé qui sont en alerte à la semaine 20. Ce vecteur sera utilisé par la suite pour filtrer les données lors de l’analyse."
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#tracer-la-courbe-épidémique-question-4",
    "href": "sessions_companion/surveillance_companion.html#tracer-la-courbe-épidémique-question-4",
    "title": "Surveillance",
    "section": "Tracer la courbe épidémique (Question 4)",
    "text": "Tracer la courbe épidémique (Question 4)\nNous allons à présent tracer la courbe épi pour les zones en alerte à la semaine 20. Nous pouvons réutiliser le code vu lors de la session sur les courbes épidémiques : nous utiliserons le paquet ggplot() et la fonction geom_col() pour créer un diagramme qui montre la distribution des cas par semaine. Petite nouveauté : par le passé nous avions une liste linaire où une ligne correspond à un patient, donc un cas. Aujourd’hui nous avons des données déjà agrégées par semaine et zone de santé : nul besoin de compter le nombre de cas nous même.\n\nTracez la courbe épidémique pour une des zones de santé en alerte.\n Le graphe devrait ressembler à ceci (peut être avez-vous choisi l’autre zone) :\n\n\n\n\n\n\n\n\n\n\nNouvelle fonction utile, la fonction facet_wrap() permet de créer plusieurs graphiques d’un seul coup rassemblés en une seule figure. Consultez le satellite sur le faceting si vous voulez en savoir plus.\n\ndata_alerte |&gt;\n  filter(zone_sante %in% zone_sante_alertee) |&gt;\n  ggplot(aes(x = semaine, \n             y = totalcas)) + \n  geom_col(fill = \"#2E4573\") + \n  theme_bw(base_size = 16) + \n  labs(x = \"Semaine\",\n       y = \"N cas\",\n       title = \"Zone de santé de Kampemba (en alerte)\") +\n  facet_wrap(vars(zone_sante))   # Un graphe par zone de santé"
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#indicateurs-clés-question-6",
    "href": "sessions_companion/surveillance_companion.html#indicateurs-clés-question-6",
    "title": "Surveillance",
    "section": "Indicateurs clés (Question 6)",
    "text": "Indicateurs clés (Question 6)\nNous pouvons calculer plus d’indicateurs sur les zones de santé pour nous aider à décider laquelle devrait faire l’objet d’une enquête (vu que vous n’avez pas le temps ni les ressources pour investiguer les deux).\n\n\n\n\n\n\nAstuce\n\n\n\nCette partie utilise les fonctions d’aggrégation vues quand nous avons appris à faire des tableaux résumés. N’hésitez pas à vous rafraîchir si besoin.\n\n\n\nPremière semaine en alerte\n\nUtilisez la fonction summarize() pour afficher les premières semaines où les ZS sont passées en alerte. Quelle zone de santé a été en alerte en premier ?\n\n\n\nIndicateurs des données de surveillance\nReprenons le jeu de données de surveillance avec toutes les colonnes, df_surv.\n\n\nAjoutez-lui une colonne cas_moins_5ans qui contient le nombre total de cas rapportés ayant moins de cinq ans.\nDérivez, pour chaque zone en alerte, les indicateurs suivants, organisés en un seul tableau :\n\n\nLe nombre de cas\nLe nombre de morts\nLe nombre de moins de cinq ans\nLa mortalité en pourcentage\nLe pourcentage de moins de cinq ans.\n\nLe résultat ressemble à :\n\n\n  zone_sante n_cas n_deces n_moins_5 p_moins_5 mortalite\n1   kampemba   730       0       544  74.52055   0.00000\n2     lwamba   256       2       233  91.01562   0.78125\n\n\n\n\n\nIndicateurs des données labo\nIntéressons-nous à présent aux données de laboratoire pour compléter les indicateurs précédents.\n\nPour chacune des zones en alerte, dérivez les indicateurs suivants :\n\nLe nombre de patients testés pour la rougeole\nLe nombre de positifs pour la rougeole\nLa proportion de positifs pour la rougeole\nLe nombre de patients testés pour la rubéole\nLe nombre de positifs pour la rubéole\nLa proportion de positifs pour la rubéole\n\nLe résultat devrait ressembler à ceci :\n\n\n  zone_sante n_test_roug n_test_roug_pos positivite_roug n_test_rub\n1     lwamba          10               5       0.5000000         10\n2   kampemba          14               4       0.2857143         14\n  n_test_rub_pos positivite_rub\n1              0     0.00000000\n2              1     0.07142857\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nSi vous avez du mal avec cette question, rafraîchissez-vous sur les résumés conditionnels."
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#cest-fini",
    "href": "sessions_companion/surveillance_companion.html#cest-fini",
    "title": "Surveillance",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo, vous êtes venus à bout de ce tutoriel !\n\n\n\n Solutions"
  },
  {
    "objectID": "sessions_companion/surveillance_companion.html#sec-going-further",
    "href": "sessions_companion/surveillance_companion.html#sec-going-further",
    "title": "Surveillance",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExplications sur complete()\nDans le mini exemple ci-dessous la zone de santé de Kitenge n’a pas de ligne pour la semaine 2 :\n\n# Data frame simplifié, avec seulement trois semaines\nexemple_df = data.frame(\n  province   = c(\"haut_katanga\", \"haut_katanga\", \"haut_katanga\", \"haut_lomami\", \"haut_lomami\"),\n  zone_sante = c(\"likasi\", \"likasi\", \"likasi\", \"kitenge\", \"kitenge\"),\n  semaine    = c(1, 2, 3, 1, 3),\n  totalcas  = c(2, 1, 3, 1, 2))\n\nexemple_df\n\n      province zone_sante semaine totalcas\n1 haut_katanga     likasi       1        2\n2 haut_katanga     likasi       2        1\n3 haut_katanga     likasi       3        3\n4  haut_lomami    kitenge       1        1\n5  haut_lomami    kitenge       3        2\n\n\nNous pouvons utiliser le code suivant pour compléter toutes les zones de santé pour qu’elles aient toutes les semaines possible, ici les semaine de un à trois :\n\n# Compléte la semaine manquante à Kitenge\nexemple_df |&gt; \n  complete(\n    nesting(province, zone_sante), \n    semaine = seq(1, 3),            # Vecteur de 1 à 3\n    fill = list(totalcas = 0)       # Remplir avec des zéros (sinon, NA par défaut)\n  ) \n\n# A tibble: 6 × 4\n  province     zone_sante semaine totalcas\n  &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 haut_katanga likasi           1        2\n2 haut_katanga likasi           2        1\n3 haut_katanga likasi           3        3\n4 haut_lomami  kitenge          1        1\n5 haut_lomami  kitenge          2        0\n6 haut_lomami  kitenge          3        2\n\n\nMaintenant les deux zones de santé dans les deux provinces ont toutes les semaines possibles.\nVous vous demandez peut être pourquoi nous avons écrit nesting(province, zone_sante) au lieu de juste zone_sante. La raison est qu’il peut y avoir deux zones de santé avec le même nom dans des provinces différentes. Nous devons donc tenir compte de la colonne province. L’argument nesting() indique à la fonction de n’utiliser que les combinaisons existantes des deux colonnes dans le data frame.\n\n\n\n\n\n\nNote\n\n\n\nPetit encart pour voir ce qui se serait passé si nous avions passé les deux colonnes à la fonction complete() sans utiliser nesting() : la fonction aurait créé toutes les combinaisons possibles entre les catégories des colonnes province et zone_sante, ce qui n’a pas de sens dans notre cas.\n\nexemple_df |&gt; \n  complete(\n    province, zone_sante, \n    semaine = seq(1, 3),  # Vecteur de 1 à 3\n    fill = list(totalcas = 0)\n  ) \n\n# A tibble: 12 × 4\n   province     zone_sante semaine totalcas\n   &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n 1 haut_katanga kitenge          1        0\n 2 haut_katanga kitenge          2        0\n 3 haut_katanga kitenge          3        0\n 4 haut_katanga likasi           1        2\n 5 haut_katanga likasi           2        1\n 6 haut_katanga likasi           3        3\n 7 haut_lomami  kitenge          1        1\n 8 haut_lomami  kitenge          2        0\n 9 haut_lomami  kitenge          3        2\n10 haut_lomami  likasi           1        0\n11 haut_lomami  likasi           2        0\n12 haut_lomami  likasi           3        0\n\n\n\n\nComme la base de données va être mise à jour chaque semaine, il serait pratique de choisir automatiquement la plage des semaines qui doivent être présentes dans les données. Pour ça, il nous suffit de remplacer les valeurs que nous avons codé en dur par la plus petite semaine existante dans les données et la plus grande :\n\nexemple_df |&gt; \n  complete(\n    nesting(province, zone_sante),\n    semaine = seq(min(semaine, na.rm = TRUE),   # Vecteur allant du minimum\n                  max(semaine, na.rm = TRUE)),  # au maximum de la colonne `semaine`\n    fill = list(totalcas = 0)\n  ) \n\n# A tibble: 6 × 4\n  province     zone_sante semaine totalcas\n  &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 haut_katanga likasi           1        2\n2 haut_katanga likasi           2        1\n3 haut_katanga likasi           3        3\n4 haut_lomami  kitenge          1        1\n5 haut_lomami  kitenge          2        0\n6 haut_lomami  kitenge          3        2\n\n\n\n\nExplications sur rollaply()\nPour calculer la somme cumulée des cas sur trois semaine il nous faut appliquer (apply en anglais) la fonction sur des fenêtres glissantes de trois semaines.\n\n# Vecteur pour les exemples\nexemple_vect &lt;- rep(1, time = 10)\nexemple_vect\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\nrollapply(\n  data  = exemple_vect,\n  width = 3,       # Largeur de la fenêtre\n  FUN   = sum,     # Fonction à appliquer (ici, la somme)\n  align = \"right\"  # Calcul dans le passé\n)\n\n[1] 3 3 3 3 3 3 3 3\n\n\nNous avons fourni en entrée un vecteur de 10 valeurs et obtenu en sortie un vecteur contenant les sommes. Manifestement, la fonction a fait des choix sur comment traiter les extrémités, et le résultat est plus court que le vecteur d’entré. Ce dernier point est un problème si l’on veut utiliser la fonction dans un mutate(), qi crée des colonnes dans un data frame, où toutes les colonnes ont la même taille.\nIl est possible de contrôler le comportement de la fonction aux extrémités :\n\nRemplir les valeurs pour lesquelles il n’y a pas assez de valeur dans la fenêtre avec des NA\nAutoriser des calculs partiels (ici, des sommes partielles, en d’autres termes des valeurs ne représentent pas la somme sur trois semaines).\n\nL’argument fill = NA remplit les valeurs manquantes aux extrémités concernées avec des NA (dans notre cas, à gauche, vu que l’on a aligné la fenêtre à droite) :\n\nrollapply(\n  data  = exemple_vect,\n  width = 3,       # Largeur de la fenêtre\n  FUN   = sum,     # Fonction à appliquer (ici, la somme)\n  align = \"right\", # Calcul dans le passé\n  fill  = NA\n)\n\n [1] NA NA  3  3  3  3  3  3  3  3\n\n\nC’est souvent une façon raisonnable de gérer les valeurs aux extrémités où les fenêtres ne sont pas complètes. Néanmoins, dans notre cas, nous pouvons faire mieux. En effet, imaginons qu’il y ait 40 cas lors de la première semaine : même si nous n’avons pas de valeurs pour les deux semaines précédentes, l’alerte devrait être déclenchée ! Nous voudrions donc que la somme cumulée soit calculée dès la première semaine pour pouvoir détecter des alertes précoces ! L’argument partial = TRUE permet cela :\n\nrollapply(\n  data    = exemple_vect,\n  width = 3,        # Largeur de la fenêtre\n  FUN   = sum,      # Fonction à appliquer (ici, la somme)\n  align = \"right\",  # Calcul dans le passé\n  partial = TRUE    # Autorise les sommes partielles aux extrémités\n  )\n\n [1] 1 2 3 3 3 3 3 3 3 3\n\n\nC’est mieux comme ça pour notre cas d’usage.\n\n\n\n\n\n\nImportant\n\n\n\nGardez à l’esprit que les deux premières valeurs du vecteur (ou de la colonne) contiennent donc des sommes partielles. En conséquence, une absence d’alerte dans les deux premières semaines ne veut pas forcement dire grand chose.\n\n\nUn dernier point : rappelez-vous qu’il faut utiliser na.rm = TRUE pour ignorer les valeurs manquantes dans la plupart des opérations arithmétiques dans R.\nSi nous avions un vecteur un peu moins complet, nous aurions des problèmes :\n\nexemple_vect_na &lt;- c(1, 1, 1, NA, 1, 1)\n\nrollapply(\n  data  = exemple_vect_na,\n  width = 3,       # Largeur de la fenêtre\n  FUN   = sum,     # Fonction à appliquer (ici, la somme)\n  align = \"right\", # Calcul dans le passé\n  partial = TRUE   # Autorise les sommes partielles aux extrémités\n)\n\n[1]  1  2  3 NA NA NA\n\n\nOups. Heureusement, nous pouvons passer l’argument na.rm = TRUE à la fonction rollapply() pour qu’elle le passe à la fonction sum().\n\nrollapply(\n  data  = exemple_vect_na,\n  width = 3,       # Largeur de la fenêtre\n  FUN   = sum,     # Fonction à appliquer (ici, la somme)\n  align = \"right\", # Calcul dans le passé\n  partial = TRUE,  # Autorise les sommes partielles aux extrémités\n  na.rm = TRUE     # Argument en plus non nommé à passer à sum()\n)\n\n[1] 1 2 3 2 2 2\n\n\nEnfin, quelues mots sur l’argument align. Il définit la position de la fenêtre glissante par rapport à la valeur en train d’être calculée. Par défaut la fenêtre est centrée autour de la valeur à cacluler : la valeur calculée i est la somme des valeurs i-1 (la valeur précédente) et la valeur i+1 (la valeur suivante).\nExemples des trois alignements (en mettant des valeurs manquantes aux extrémités pour voir plus facilement ce qui se passe) :\n\n# Alignement à gauche : la valeur est la somme des valeurs dans le futur\nrollapply(data  = c(5, 10, 1, 2, 5, 10),\n          width = 3, \n          FUN   = sum,\n          align = \"left\", \n          fill = NA)\n\n[1] 16 13  8 17 NA NA\n\n# Alignement centré : somme des valeurs de chaque côté\nrollapply(data  = c(5, 10, 1, 2, 5, 10),\n          width = 3, \n          FUN   = sum,\n          align = \"center\",\n          fill = NA)  # The default\n\n[1] NA 16 13  8 17 NA\n\n# Alignement à droite : somme des valeurs passées jusqu'à présent\nrollapply(data  = c(5, 10, 1, 2, 5, 10),\n          width = 3, \n          FUN   = sum,\n          align = \"right\",\n          fill = NA)\n\n[1] NA NA 16 13  8 17\n\n\nDans notre cas, nous voulons que la valeur pour une semaine donnée reflète cette semaine et les deux semaines précédentes, donc nous utilisons l’argument align = \"right\", pour calculer dans le passé.\n\n\n\n\n\n\nAstuce\n\n\n\nDans ce tutoriel nous avons appliqué la fonction sum() à des fenêtres de trois semaines pour calculer une somme cumulée. Mais le code peut être facilement modifié pour calculer une moyenne glissante sur une fenêtre de votre choix !\n\n\n\n\nFormatage des pourcentages\nLa fonction percent() du paquet {scales} formate une valeur ou un vecteur de valeurs en pourcentages.\n\nscales::percent(0.8556)\n\nIl y a un argument accuracy pour contrôler le nombre de décimales à afficher :\n\nscales::percent(0.8556,\n                accuracy = 0.1)\n\nVous pouvez fournir un vecteur (ou une colonne !) de proportions à la fonction pour afficher les valeurs en pourcentages, ce qui est plus lisible dans un tableau résumé.\n\n\n\n\n\n\nImportant\n\n\n\nLa colonne ainsi crée n’est plus une colonne numérique : l’ajout du signe % transforme la colonne en texte. Vous ne pourrez donc plus effectuer d’opérations arithmétiques dessus."
  },
  {
    "objectID": "sessions_companion/survey_basic.html",
    "href": "sessions_companion/survey_basic.html",
    "title": "Enquête standard sur la mortalité",
    "section": "",
    "text": "Calculer personne-temps à risque\nUtiliser {srvyr} pour estimer les taux de mortalité"
  },
  {
    "objectID": "sessions_companion/survey_basic.html#objectifs",
    "href": "sessions_companion/survey_basic.html#objectifs",
    "title": "Enquête standard sur la mortalité",
    "section": "",
    "text": "Calculer personne-temps à risque\nUtiliser {srvyr} pour estimer les taux de mortalité"
  },
  {
    "objectID": "sessions_companion/survey_basic.html#introduction",
    "href": "sessions_companion/survey_basic.html#introduction",
    "title": "Enquête standard sur la mortalité",
    "section": "Introduction",
    "text": "Introduction\nCette session se concentre sur les analyses de base pour une enquête rétrospective sur la mortalité à l’aide du protocole standard de MSF. Nous utiliserons une étude de cas dans laquelle une enquête a été menée à la suite d’une épidémie de choléra en Haïti en 2010.\nCette session suppose que vous avez suivi le parcours d’apprentissage de base pour R et que vous êtes capable de :\n\nImporter des données\nEffectuer un nettoyage de base à l’aide de case_when()\nAgrégation des données à l’aide de count() et summarize()\nProduction de tableaux à l’aide de gt()\n\nSi vous avez besoin de revoir ou d’apprendre l’un de ces sujets, veuillez vous reporter aux sessions de base du parcours d’apprentissage."
  },
  {
    "objectID": "sessions_companion/survey_basic.html#configuration",
    "href": "sessions_companion/survey_basic.html#configuration",
    "title": "Enquête standard sur la mortalité",
    "section": "Configuration",
    "text": "Configuration\n\nCette session utilise une étude de cas spécifique. Téléchargez et décompressez le dossier associé, puis ouvrez le script main.R à partir du dossier R :\n\n\n\n Télécharger\n\n\n\n\nLe dossier que vous avez téléchargé contient un script R (presque) vide ainsi que des fichiers Excel pour le formulaire Kobo utilisé dans l’enquête et les données collectées avec celui-ci.\n\nPrenez une minute pour ouvrir et examiner le formulaire Kobo et les données brutes. Que contiennent les différents onglets de l’ensemble de données ?"
  },
  {
    "objectID": "sessions_companion/survey_basic.html#import",
    "href": "sessions_companion/survey_basic.html#import",
    "title": "Enquête standard sur la mortalité",
    "section": "Import",
    "text": "Import\nNotre ensemble de données comporte deux onglets, le premier contenant les données au niveau des ménages et le second les données individuelles. Pour l’instant, nous nous intéressons principalement aux données individuelles, mais nous aurons finalement besoin des deux. Chargeons tout cela dans R (ainsi que les paquets que nous utiliserons dans la session d’aujourd’hui).\n\nDans votre script (main.R), ajoutez un en-tête approprié pour le fichier et créez une section qui charge les paquets suivants :\n\nhere\nrio\ngt\nsrvyr\n\nCréez ensuite une nouvelle section appelée Import et utilisez rio pour importer la deuxième feuille de votre ensemble de données dans un objet appelé df_raw. Nous n’avons pas besoin de toutes les colonnes de ces données, utilisez select() pour sélectionner uniquement les suivantes :\n\nsex\nage\nborn\nborn_date\njoined\njoined_date\nleft\ndied\ndied_date\ndied_cause\n_parent_index renommé hh\n\nCréez ensuite un deuxième objet appelé df_hh contenant la première feuille de votre ensemble de données en conservant uniquement les colonnes suivantes :\n\ninterview_date\nclst_id\n_index renommé hh\npresent\nconsent\n\nAstuce. N’oubliez pas que lorsque vous utilisez select(), vous pouvez rapidement renommer un élément à l’aide d’un =, par exemple : hh = \"_parent_index\"."
  },
  {
    "objectID": "sessions_companion/survey_basic.html#premier-aperçu-et-recodage",
    "href": "sessions_companion/survey_basic.html#premier-aperçu-et-recodage",
    "title": "Enquête standard sur la mortalité",
    "section": "Premier aperçu (et recodage)",
    "text": "Premier aperçu (et recodage)\nSuper ! Maintenant que nous avons chargé nos données, jetons-y un premier coup d’œil. L’une des premières choses que nous pouvons faire est de vérifier la structure de nos données :\n\ndf_raw |&gt;\n  str()\n\nNous pouvons également vérifier rapidement combien de personnes dans l’ensemble de données sont décédées, car notre enquête porte sur la mortalité :\n\ndf_raw |&gt;\n  count(died)\n\n\nUtilisez count() pour déterminer le nombre de participants par sexe.\n\nHum, 1 et 2 pour le sexe sont un peu ambigus. Il pourrait être utile de recoder nos données catégorielles afin d’utiliser des étiquettes plus significatives. Par exemple :\n\ndf &lt;- df_raw |&gt;\n  # recodage\n  mutate(\n    sexe = case_when(\n      sexe == 1 ~ \"Homme\",\n      sexe == 2 ~ 'Femme`,\n      .default = NA\n    )\n  )\n\n\nCréez une nouvelle section dans votre script intitulée Nettoyage. Cette section comprendra un ‘pipeline de nettoyage’ qui prendra df_raw, effectuera plusieurs étapes de nettoyage et stockera le cadre de données résultant dans un objet appelé ‘df’.  À l’aide de ‘case_when()’, créez une nouvelle étape dans votre pipeline de nettoyage qui recode les variables catégorielles de votre ensemble de données. Vous pouvez utiliser le recodage ci-dessus pour ‘sex’. Pour les variables ‘born’, ‘joined’, ‘left’ et ‘died’, utilisez le recodage suivant :\n\n0 = Non\n1 = Oui\n99 = Inconnu\n\nPour ‘died_cause’, utilisez le recodage suivant :\n\n1 = Diarrhée\n2 = Fièvre\n3 = Maladie respiratoire\n4 = Accident\n5 = Pendant l’accouchement\n6 = Autre\n99 = Inconnu\nNA = N’est pas décédé\n\nLa tête de ‘df’ devrait ressembler à ceci :\n\n\n    sex age born_date joined_date left_date died_date born joined left died\n1 Femme  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n2  Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n3 Femme  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n4 Femme   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n5  Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n6 Femme  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n        died_cause hh\n1 N'est pas décédé  1\n2 N'est pas décédé  1\n3 N'est pas décédé  1\n4 N'est pas décédé  1\n5 N'est pas décédé  1\n6 N'est pas décédé  1\n\n\nMaintenant que nous avons des étiquettes plus claires, explorons un peu plus nos données. Par exemple :\n\nCombien de personnes sont décédées pour chaque cause potentielle ?\nObservez les combinaisons de died, left, joined et born. Quelles sont les combinaisons les plus courantes ? Cela vous semble-t-il logique ?\nQui est le plus touché par le décès, les hommes ou les femmes ? Qui était le plus à risque ?\n\n Astuce. N’oubliez pas que vous pouvez attribuer plusieurs noms de colonnes à count() afin de créer des tableaux de contingence."
  },
  {
    "objectID": "sessions_companion/survey_basic.html#nettoyage",
    "href": "sessions_companion/survey_basic.html#nettoyage",
    "title": "Enquête standard sur la mortalité",
    "section": "Nettoyage",
    "text": "Nettoyage\n\nDates en tant que dates (simples)\nTerminons le nettoyage de nos données pour l’analyse. Nous devons notamment nous assurer que toutes nos données sont du bon type. Nous avons déjà recodé toutes les variables catégorielles, mais nous n’avons pas encore examiné les dates.\n\nclass(df_raw$born_date)\n\n[1] \"POSIXct\" \"POSIXt\" \n\n\nIl semble que nos dates soient de type POSITct. Convertissons-les en un format de date plus simple à l’aide de ymd() de {lubridate}.\n\nAjoutez une étape à votre pipeline de nettoyage qui utilise ymd() de {lubridate} pour convertir les dates de born_date, joined_date, left_date et died_date en dates simples. \nLa classe () de df$born_date devrait désormais être Date :\n\nclass(df$born_date)\n\n[1] \"Date\"\n\n\n\n\n\nCorrection des problèmes logiques\nUn formulaire Kobo bien conçu peut grandement contribuer à garantir la collecte de données de bonne qualité dès le départ. Par exemple, nous pouvons rendre certaines questions obligatoires afin d’éviter les données manquantes. Nous pouvons également créer des ‘contraintes’ qui généreront des messages d’erreur lorsque les données saisies enfreignent les règles prédéfinies ; par exemple, nous pouvons créer une contrainte qui empêche l’enquêteur de saisir une date de décès qui ne correspond pas à la période de rappel.\n\nOuvrez le fichier Excel de l’enquête Kobo ‘retrospective-mortality_kobo.xlsx’ et examinez la colonne ‘contrainte’. Quelles sont les contraintes créées dans ce fichier ? Pouvez-vous penser à quelque chose qui n’a pas été pris en compte ?\n\nMalgré toutes les protections que nous avons mises en place dans le processus de collecte, un peu de nettoyage sera toujours nécessaire. Par exemple, bien que nous ayons veillé à ce que toutes les dates se situent dans la période de rappel, nous n’avons pas créé de contrôles pour d’autres relations illogiques entre les dates. Voyons, par exemple, si quelqu’un est né après son décès :\n\ndf_raw |&gt;\nfilter (died_date &lt; born_date)\n\n\nUtilisez filter() pour vérifier s’il y a des cas de personnes qui ont rejoint la famille après leur décès. Combien de fois cela s’est-il produit ?\nLe début de votre sortie devrait ressembler à ceci :\n\nCe n’est pas terrible. Comment pouvons-nous corriger cela ? La meilleure pratique à adopter ici fait l’objet d’un débat, mais nous vous recommandons de conserver la date de décès et de supprimer la date de naissance/d’adhésion (c’est-à-dire la remplacer par ‘NA’). Sinon, si vous constatez cette erreur pendant la collecte des données, vous pouvez interroger l’enquêteur à ce sujet. Il se peut qu’il s’agisse d’une faute de frappe et qu’il se souvienne des dates exactes. Dans la mesure du possible, essayez d’effectuer ce type de contrôle quotidiennement afin de pouvoir corriger les problèmes en temps réel.\nSi nous ne pouvons conserver qu’une seule date, pourquoi privilégier la date de décès ? La date de décès est la variable la plus importante dans le cadre de cette enquête particulière. Il s’agit également d’un événement rare, ce qui signifie que toute date manquante pourrait avoir un impact disproportionné sur les résultats. De plus, on peut supposer que la date de décès est plus fiable que d’autres dates (telles que la date exacte de naissance ou la date d’arrivée/de départ d’une personne dans le foyer).\n\n\n\n\n\n\nImportant\n\n\n\nDans ce cas précis, il n’y avait que quelques cas de ‘naissance ou entrée dans le foyer après le décès’ sur un ensemble de données de plus de 18 000 personnes, donc supprimer leurs dates de naissance/d’entrée dans le foyer n’est pas très grave. Toutefois, si des erreurs de ce type sont plus fréquentes, cela peut indiquer un problème important dans la conception du formulaire et/ou la formation des enquêteurs. Rechercher rapidement ce type de problèmes (même dans Excel) après la phase pilote et pendant la phase de collecte des données peut vous aider à repérer les problèmes tant que vous avez encore le temps de les corriger.\n\n\n\nÀ l’aide de mutate() et case_when(), ajoutez une étape à votre pipeline de nettoyage pour remplacer les dates de naissance/d’adhésion problématiques par NA. Comment pouvez-vous vérifier si cela a fonctionné correctement ?\n\nVoyez-vous d’autres problèmes dans les données ? J’en vois deux :\n\nQuelques personnes sont nées pendant la période de rappel, mais ont un âge supérieur à 0\nUne personne est décédée après avoir quitté le foyer\n\n\nComment traiteriez-vous ces deux problèmes ? Réfléchissez aux types de problèmes qui ont pu les causer et aux conséquences des différentes stratégies de nettoyage sur vos résultats finaux.  Bonus. Pensez-vous que l’un ou l’autre de ces problèmes aurait pu être évité grâce à une meilleure conception du Kobo ?\n\nExaminons d’abord le problème des personnes nées pendant la période de rappel et dont l’âge est supérieur à 0. La manière de traiter les âges inférieurs à 1 peut être délicate et les enquêteurs doivent être formés de manière explicite pour savoir s’ils doivent ‘arrondir’ ou ‘arrondir à la baisse’. Sinon, les enquêtes modernes ont tendance à demander l’âge en mois pour les personnes en dessous d’une certaine limite (généralement 12, 23 ou 59 mois). Il est particulièrement important d’enregistrer l’âge en mois des jeunes enfants dans les enquêtes qui se concentrent sur des questions telles que la vaccination, la malnutrition ou la mortalité, où les problèmes de santé concernés sont (potentiellement) associés aux nourrissons ou aux enfants de moins de 5 ans. Une contrainte aurait également pu être ajoutée au formulaire Kobo pour éviter ce problème.\nDans le cadre de cette enquête, nous ne disposons d’aucune information sur les mois, donc la meilleure chose à faire est d’imposer une règle cohérente selon laquelle tout âge inférieur à 12 mois doit être enregistré comme 0. Cela signifie que si un enfant est né pendant la période de rappel (qui est une période inférieure à 12 mois), son âge doit être 0.\n\nAjoutez une étape à votre pipeline qui garantit que toute personne née pendant la période de rappel a un âge de 0. Si vous avez effectué cette opération correctement, vous devriez pouvoir filtrer df pour ne voir que les personnes nées pendant la période de rappel et vérifier que leur âge est 0 :\n\ndf |&gt;\n  filter(born == 'Oui') |&gt;\n  pull(age) |&gt;\n  unique()\n\n[1] 0\n\n\n\nLe deuxième problème est un peu plus complexe. Examinons les individus concernés :\n\ndf |&gt;\nfilter(left_date &lt; died_date)\n\n     sex age born_date joined_date  left_date  died_date born joined left died\n1   Male  25      &lt;NA&gt;        &lt;NA&gt; 2010-11-02 2011-03-08  Non    Non  Oui  Oui\n2 Female   3      &lt;NA&gt;  2011-01-05 2010-11-20 2011-03-28  Non    Oui  Oui  Oui\n3 Female  60      &lt;NA&gt;  2011-03-08 2011-02-15 2011-03-15  Non    Oui  Oui  Oui\n  died_cause   hh\n1   Diarrhée   88\n2   Diarrhée  236\n3   Diarrhée 2861\n\n\n\nExaminez les trois personnes dans le résultat ci-dessus. Sont-elles toutes problématiques ? Pourquoi ou pourquoi pas ?\n\nLes personnes âgées de 3 et 60 ans ne posent pas de problème, elles ont simplement quitté le foyer puis l’ont réintégré. En revanche, la personne âgée de 25 ans semble avoir quitté le foyer puis être décédée sans jamais y revenir entre-temps. Que devons-nous faire ? Réfléchissons aux raisons pour lesquelles une telle situation pourrait apparaître dans nos données. Il existe deux options principales :\n\nPeut-être que la personne a réintégré le foyer, mais que le participant a oublié de le mentionner\nPeut-être que le participant n’a pas bien compris que l’enquête ne prendrait en compte que les décès survenus alors que la personne était encore membre du foyer au moment de son décès\n\nSi possible, nous pourrions discuter avec l’enquêteur qui a mené cet entretien afin de déterminer quelle option est la plus probable. En l’absence d’informations supplémentaires, nous devrons probablement opter pour la deuxième option. Si nous faisons cela, nous devrons recoder cette personne comme étant vivante plutôt que décédée, car elle était encore en vie au moment où elle a quitté le ménage.\n\nAjoutez une étape supplémentaire à votre pipeline qui recode cette personne comme étant vivante, c’est-à-dire : sa valeur ‘décédé’ doit être réinitialisée à ‘Non’ et sa date de décès doit être supprimée. Si vous vérifiez à nouveau les personnes qui ont quitté le foyer avant leur décès, vous ne devriez voir que deux personnes :\n\n\n    sex age born_date joined_date  left_date  died_date born joined left died\n1 Femme   3      &lt;NA&gt;  2011-01-05 2010-11-20 2011-03-28  Non    Oui  Oui  Oui\n2 Femme  60      &lt;NA&gt;  2011-03-08 2011-02-15 2011-03-15  Non    Oui  Oui  Oui\n  died_cause   hh\n1   Diarrhée  236\n2   Diarrhée 2861\n\n\nRemarque. La décision de supprimer un décès de l’ensemble de données est discutable. N’oubliez pas que les décès étant des événements rares, l’ajout ou la suppression d’un décès peut avoir un impact disproportionné sur les calculs de mortalité. Pour minimiser ce type de problème, veillez à consacrer suffisamment de temps à la formation des enquêteurs afin qu’ils comprennent parfaitement les concepts fondamentaux tels que la période de rappel et la notion de ‘ménage continu’. Donner des exemples spécifiques comme celui-ci pendant la formation peut aider les enquêteurs à gérer ces problèmes de manière appropriée lorsqu’ils se présentent pendant la collecte des données."
  },
  {
    "objectID": "sessions_companion/survey_basic.html#joindre-les-données-des-ménages",
    "href": "sessions_companion/survey_basic.html#joindre-les-données-des-ménages",
    "title": "Enquête standard sur la mortalité",
    "section": "Joindre les données des ménages",
    "text": "Joindre les données des ménages\nNos données individuelles semblent correctes, mais elles sont complètement déconnectées de nos données au niveau des ménages (vous vous souvenez de df_hh au début du tutoriel ?). Par exemple, nous aimerions connaître la date de l’entretien associée à chaque individu ainsi que le groupe auquel il appartenait. Pour ce faire, nous devons effectuer une jointure.\nUne analyse approfondie des jointures dépasse le cadre de cette session, mais en substance, les jointures sont utilisées pour prendre les données d’un dataframe et les ajouter (ligne par ligne) à un autre dataframe sur la base d’une variable commune aux deux ensembles de données (telle qu’un identifiant). Par exemple, nous voulons ici parcourir ligne par ligne nos données individuelles (df) et ajouter des colonnes contenant les informations relatives au niveau des ménages pour chaque personne (à partir de df_hh). Pour ce faire, nous utiliserons la fonction left_join() de {dplyr} :\n\ndf |&gt;\nleft_join(df_hh) |&gt;\nhead()\n\nJoining with `by = join_by(hh)`\n\n\n    sex age born_date joined_date left_date died_date born joined left died\n1 Femme  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n2  Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n3 Femme  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n4 Femme   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n5  Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n6 Femme  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n        died_cause hh interview_date clst_id present consent\n1 N'est pas décédé  1     2011-03-29       1       1       1\n2 N'est pas décédé  1     2011-03-29       1       1       1\n3 N'est pas décédé  1     2011-03-29       1       1       1\n4 N'est pas décédé  1     2011-03-29       1       1       1\n5 N'est pas décédé  1     2011-03-29       1       1       1\n6 N'est pas décédé  1     2011-03-29       1       1       1\n\n\nNotez qu’ici, R a utilisé la colonne hh (identifiant du ménage) comme variable commune entre les ensembles de données ; vous pouvez voir un message indiquant cela juste au-dessus de la sortie de head().\n\n\n\n\n\n\nNote\n\n\n\nQue signifie ‘left’ dans left_join() ? En termes simples, les jointures gauches impliquent un ensemble de données auquel des données sont ajoutées (ensemble de données A) et un autre dont des données sont extraites (ensemble de données B). L’ensemble de données A est l’‘ensemble de données principal’ et le résultat inclura toujours toutes ses lignes. Les lignes de l’ensemble de données B seront conservées si et seulement si left_join() trouve une ligne appropriée dans l’ensemble de données A à laquelle elles peuvent être ajoutées. Dans nos données, par exemple, les lignes de données sur les ménages qui n’avaient aucun membre (et qui n’apparaissent donc pas dans df) ne seront pas incluses dans le résultat de la jointure ci-dessus.  Dans une left_join(), R considérera toujours le premier argument comme l’ensemble de données principal (ensemble de données A) ; c’est-à-dire :\n\n# PSEUDO-CODE\nleft_join(dataset_a, dataset_b)\n\n\n\n\nAjoutez une dernière étape à votre pipeline de nettoyage qui utilise left_join() pour ajouter les données au niveau des ménages à chacune des lignes de df, puis convertit interview_date pour utiliser un format de date de base (comme vous l’avez fait avec born_date, etc.). Votre pipeline final devrait maintenant effectuer les opérations suivantes :\n\nUtiliser df_raw comme entrée\nRecoder les variables catégorielles\nConvertir les dates au format simple a-m-j\nCorriger les problèmes de données illogiques\nJoindre les indicateurs des ménages\n\nSi tout s’est bien passé, l’en-tête de df devrait ressembler à ceci :\n\nhead(df)\n\n     sex age born_date joined_date left_date died_date born joined left died\n1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n        died_cause hh interview_date clst_id present consent\n1 N'est pas décédé  1     2011-03-29       1       1       1\n2 N'est pas décédé  1     2011-03-29       1       1       1\n3 N'est pas décédé  1     2011-03-29       1       1       1\n4 N'est pas décédé  1     2011-03-29       1       1       1\n5 N'est pas décédé  1     2011-03-29       1       1       1\n6 N'est pas décédé  1     2011-03-29       1       1       1"
  },
  {
    "objectID": "sessions_companion/survey_basic.html#calculs-de-mortalité",
    "href": "sessions_companion/survey_basic.html#calculs-de-mortalité",
    "title": "Enquête standard sur la mortalité",
    "section": "Calculs de mortalité",
    "text": "Calculs de mortalité\nUne fois le nettoyage et la jonction terminés, nous pouvons enfin passer à la partie amusante, l’analyse. Nous voulons calculer les éléments suivants :\n\nTaux de mortalité brut\nTaux de mortalité des moins de cinq ans\nTaux de mortalité spécifique à la diarrhée\n\n\n(Sur papier) Écrivez la formule pour chacun de ces indicateurs. Disposons-nous déjà de toutes les variables nécessaires dans notre ensemble de données pour effectuer les calculs ?\n\nCes indicateurs sont des taux, ce qui signifie qu’ils nécessitent un dénominateur en temps-personne à risque. Notre ensemble de données ne comporte pas encore de colonne pour cela. Corrigeons cela.\n\nPersonne-temps à risque\nPour notre enquête, le temps à risque par personne correspond au temps pendant lequel chaque individu était :\n\nEn vie et\nMembre du ménage\n\nLa plupart des personnes étaient en vie et faisaient partie du ménage pendant toute la période de rappel. Pour ces personnes, leur temps à risque correspond à la totalité de la période de rappel. Il existe cependant plusieurs autres options. Par exemple :\n\n\n\n\n\n\nLa plupart de ces cas peuvent être traités de la même manière, à l’exception du dernier. Prenez une minute pour essayer de trouver sur papier une formule que nous pourrions utiliser pour le temps-personne. Vous gagnerez des points supplémentaires si vous parvenez à la convertir en code.\n\nIl n’est pas facile de trouver une bonne formule ici, alors examinons-la ensemble. Imaginons une personne qui a rejoint le ménage fin 2010 et qui est décédée en février 2011. Si nous insérons les données de cette personne dans un cadre de données, nous pourrions obtenir quelque chose comme ceci :\n\nexample &lt;- data.frame(\n  date_interview = as.Date(\"2011-04-07\"),\n  born = \"Non\",\n  date_born = NA,\n  joined = \"Oui\",\n  date_joined = as.Date(\"2010-12-08\"),\n  left = \"Non\",\n  date_left = NA,\n  died = \"Oui\",\n  date_died = as.Date(\"2011-02-13\")\n)\n\nexample\n\n  date_interview born date_born joined date_joined left date_left died\n1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui\n   date_died\n1 2011-02-13\n\n\nPour calculer la durée d’exposition de cette personne, nous devons déterminer ‘quand sa période d’exposition a commencé’ et ‘quand elle s’est terminée’. Nous calculons ensuite la différence entre ces deux dates. Pour déterminer le début de la période d’exposition d’une personne, nous devons extraire la date à laquelle elle est née/a rejoint le foyer ou (si elle était présente pendant toute la période) la date de début de la période de rappel. Nous pouvons le faire à l’aide de case_when() :\n\nrecall_start &lt;- as.Date(\"2010-10-17\")\n\nexample |&gt;\n  mutate(\n    pt_start = case_when(\n      born == \"Oui\" ~ date_born,\n      joined == \"Oui\" ~ date_joined,\n      .default = recall_start\n    )\n  )\n\n  date_interview born date_born joined date_joined left date_left died\n1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui\n   date_died   pt_start\n1 2011-02-13 2010-12-08\n\n\nDe même, leur période à risque prend fin lorsqu’ils décèdent / quittent l’entreprise ou à la fin du rappel (lorsqu’ils ont été interrogés) :\n\nexample |&gt;\n  mutate(pt_end = case_when(left == \"Oui\" ~ date_left,\n  died == \"Oui\" ~ date_died,\n  .default = date_interview))\n\n  date_interview born date_born joined date_joined left date_left died\n1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui\n   date_died     pt_end\n1 2011-02-13 2011-02-13\n\n\nEn rassemblant ces informations, nous pouvons alors calculer le temps total passé à risque par une personne comme étant la différence entre la fin et le début de ce temps :\n\nexample |&gt;\n  mutate(\n  pt_start = case_when(\n    born == \"Oui\" ~ date_born,\n    joined == \"Oui\" ~ date_joined,\n    .default = recall_start),\n  pt_end = case_when(\n    left == \"Oui\" ~ date_left,\n    died == \"Oui\" ~ date_died,\n    .default = date_interview),\n  pt = pt_end - pt_start)\n\n  date_interview born date_born joined date_joined left date_left died\n1     2011-04-07  Non        NA    Oui  2010-12-08  Non        NA  Oui\n   date_died   pt_start     pt_end      pt\n1 2011-02-13 2010-12-08 2011-02-13 67 days\n\n\n\nCréez une nouvelle section dans votre code intitulée ‘Calculer le temps de personne’ et initialisez un objet appelé ‘recall_start’ avec la date 2010-10-17. Ajoutez un bloc de code adaptant ce qui précède pour créer une colonne ‘pt’ dans ‘df’ qui calcule le temps de personne à risque. L’en-tête de ‘df’ devrait maintenant ressembler à ceci :\n\n\n     sex age born_date joined_date left_date died_date born joined left died\n1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n        died_cause hh interview_date clst_id present consent   pt_start\n1 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17\n2 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17\n3 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17\n4 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17\n5 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17\n6 N'est pas décédé  1     2011-03-29       1       1       1 2010-10-17\n      pt_end       pt\n1 2011-03-29 163 days\n2 2011-03-29 163 days\n3 2011-03-29 163 days\n4 2011-03-29 163 days\n5 2011-03-29 163 days\n6 2011-03-29 163 days\n\n\n\nUtilisons range() pour examiner les valeurs maximales et minimales de pt :\n\nrange(df$pt)\n\nTime differences in days\n[1] NA NA\n\n\nIl semble que la valeur du temps de risque par personne soit parfois manquante. Cela se produit lorsque, par exemple, une personne est née / a rejoint / a quitté / est décédée, mais que les informations relatives à la date de cet événement sont manquantes. Comment devons-nous traiter cela ? Une option consiste à laisser la valeur manquante, ce qui signifie que cette personne ne contribue pas au temps de risque par personne dans les calculs ultérieurs de la mortalité. Une autre option consiste à nous pouvons prendre la première valeur disponible pour laquelle nous avons une date. Ainsi, par exemple, si nous ne savons pas quand une personne est née, nous utiliserons le début de la période de rappel comme début de son temps de risque.\n\nQuels sont les avantages et les inconvénients de ces deux options ? Comment ajusteriez-vous votre code ci-dessus pour mettre en œuvre la deuxième option ?\n\nLa première option réduit artificiellement le dénominateur de nos calculs de mortalité, ce qui entraîne une surestimation de la mortalité. La deuxième option aura l’effet inverse. Pour l’analyse d’aujourd’hui, nous choisirons la première option et laisserons notre code tel quel (valeurs manquantes comprises). Examinons à nouveau notre plage, en ignorant cette fois les valeurs manquantes :\n\nrange(df$pt, na.rm = TRUE)\n\nTime differences in days\n[1] -141  172\n\n\nNous obtenons maintenant des chiffres, mais il semble que nous ayons des valeurs négatives. Que se passe-t-il ? Repensez à la figure au début de cette section. Si la plupart des cas peuvent être gérés avec notre calcul actuel, celui-ci ne tient pas compte des personnes qui ont quitté puis rejoint le ménage, car ces personnes auront ‘joined_date &gt; left_date’.\n\nRéfléchissez à ces personnes qui quittent puis rejoignent un ménage, ainsi qu’aux dates concernées. Pouvez-vous imaginer une équation pour leur temps de risque individuel ? Comment pensez-vous que cela pourrait être codé ?\n\nPour ces personnes, au lieu de prendre la différence (entre la fin et le début du temps de risque), nous devons calculer deux tranches de temps (avant leur départ et après leur retour), puis les additionner. Voici comment procéder :\n\ntmp &lt;- df |&gt;\n  mutate(\n    pt = case_when(\n    joined_date &gt; left_date & born == \"Oui\" ~ (left_date - born_date) + (interview_date - joined_date),\n    joined_date &gt; left_date ~ (left_date - recall_start) + (interview_date - joined_date),\n    .default = pt\n    )\n  )\n\nrange(tmp$pt, na.rm = TRUE)\n\nTime differences in days\n[1]   0 172\n\n\n\nAdaptez votre code pipe person-time afin d’inclure cette correction pour les personnes qui ont quitté puis réintégré le foyer. Ajoutez ensuite une ligne pour supprimer les colonnes pt_start et pt_end, car nous ne les utiliserons plus (et elles ne seront pas exactes pour les personnes qui ont quitté puis réintégré le foyer). La tête de df devrait désormais ressembler à ceci :\n\n\n     sex age born_date joined_date left_date died_date born joined left died\n1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n        died_cause hh interview_date clst_id present consent       pt\n1 N'est pas décédé  1     2011-03-29       1       1       1 163 days\n2 N'est pas décédé  1     2011-03-29       1       1       1 163 days\n3 N'est pas décédé  1     2011-03-29       1       1       1 163 days\n4 N'est pas décédé  1     2011-03-29       1       1       1 163 days\n5 N'est pas décédé  1     2011-03-29       1       1       1 163 days\n6 N'est pas décédé  1     2011-03-29       1       1       1 163 days\n\n\nBonus. Pourquoi notre case_when ci-dessus devait-il comporter un cas distinct pour les personnes nées pendant la période de rappel ?\n\nParfait, nous sommes presque prêts à calculer la mortalité ! Notez qu’à l’heure actuelle, nos valeurs pour le temps-personne sont représentées sous forme de différence de temps (classe difftime) en nombre de jours. Pour la suite de nos calculs, il serait préférable que ce soit un type numérique simple.\n\nAjoutez une dernière étape dans votre pipeline de temps-personne qui convertit pt en un type numérique à l’aide de as.numeric().\n\n\n\nCalculs de mortalité\nNous sommes (enfin) prêts à calculer les taux de mortalité. Nous pourrions effectuer un calcul de base directement à partir du nombre total de décès et du temps cumulé passé à risque :\n\nsum(df$died == \"Oui\") / sum(df$pt, na.rm = TRUE) * 10000\n\n[1] 0.5405712\n\n\n\nComment interpréteriez-vous ce taux de mortalité ? Est-il élevé ?  En 2010, le taux de mortalité de référence en Haïti était de 9 décès pour 1 000 personnes-années. Sachant cela, calculez la surmortalité observée pendant cette épidémie (exprimée en décès supplémentaires pour 10 000 personnes-jours).  Indice. Commencez par convertir le taux de référence en décès pour 10 000 jours-personnes.\n\nJusqu’ici tout va bien, mais nous n’avons n’avons pas inclus d’intervalles de confiance dans notre calcul et nous n’avons pas non plus pris en compte la conception de notre enquête. Pour ce faire, nous allons utiliser le package {srvyr}. Ce package a été conçu pour l’analyse complexe des données d’enquête et fournit des méthodes statistiques permettant d’ajuster l’effet de conception et la taille finie de la population. Une discussion approfondie de l’effet de conception et de la manière de l’ajuster dépasse le cadre de cette leçon, mais, en substance, les effets de conception apparaissent lorsque nous utilisons un processus d’échantillonnage qui n’est pas entièrement aléatoire . Par exemple, l’utilisation de l’échantillonnage en grappes dans cette enquête crée un effet de conception, car on peut s’attendre à ce que les personnes d’une même grappe soient plus similaires entre elles qu’elles ne le sont par rapport à d’autres personnes sélectionnées au hasard dans la population. Lorsque nous ajustons l’effet de conception, nous élargissons nos intervalles de confiance (nous réduisons notre précision) afin de tenir compte de cette similitude non aléatoire.\nPour effectuer ces ajustements, {srvyr} a besoin de connaître quelques informations :\n\nL’identifiant des unités d’échantillonnage nécessitant un ajustement (dans ce cas, les identifiants des grappes)\nLa taille de la population (nécessaire pour résoudre à la fois l’effet de conception et tenir compte de la taille finie de la population)\nLe poids de chaque grappe\n\nLe poids de la grappe est le produit de deux fractions :\n\nTaille totale de la population / taille de l’échantillon et\nCluster attendu / taille réelle du cluster donné\n\nEn principe, chacun de nos clusters aurait dû compter 32 ménages. Dans la pratique, la taille réelle des clusters a pu s’écarter dans certains cas. Nous pouvons utiliser la fonction n_distinct() dans summarize() pour ajouter une colonne avec la taille réelle du cluster associé à chaque individu :\n\ndf |&gt;\n  summarize(.by = clst_id,\n  hh_count = n_distinct(hh)) |&gt;\n  head()\n\n  clst_id hh_count\n1       1       32\n2       2       32\n3       3       32\n4       4       32\n5       5       32\n6       6       32\n\n\n\nCréez une nouvelle section de votre code intitulée ‘Calculer la mortalité’. Écrivez un tuyau qui utilise l’instruction summarize ci-dessus pour calculer le nombre de ménages observés par cluster, puis utilisez mutate() pour ajouter les colonnes weight et pop contenant respectivement les poids et la taille totale de la population (en 2010, celle-ci était de 228 425 personnes). Stockez la sortie de ce tuyau dans un objet appelé df_wt. La tête de df_wt devrait ressembler à ceci :\n\n\n  clst_id hh_count   weight    pop\n1       1       32 12.38546 228425\n2       2       32 12.38546 228425\n3       3       32 12.38546 228425\n4       4       32 12.38546 228425\n5       5       32 12.38546 228425\n6       6       32 12.38546 228425\n\n\nAstuce. La formule pour weight est (population_size / sample_size) * (32 / hh_count).  Maintenant, utilisez left_join() pour joindre les données de poids et de population nouvellement créées à df. La tête de df devrait maintenant ressembler à ceci :\n\n\nJoining with `by = join_by(clst_id)`\n\n\n\n\n     sex age born_date joined_date left_date died_date born joined left died\n1 Female  23      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n2   Male  30      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n3 Female  11      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n4 Female   5      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n5   Male   1      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n6 Female  19      &lt;NA&gt;        &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;  Non    Non  Non  Non\n        died_cause hh interview_date clst_id present consent  pt hh_count\n1 N'est pas décédé  1     2011-03-29       1       1       1 163       32\n2 N'est pas décédé  1     2011-03-29       1       1       1 163       32\n3 N'est pas décédé  1     2011-03-29       1       1       1 163       32\n4 N'est pas décédé  1     2011-03-29       1       1       1 163       32\n5 N'est pas décédé  1     2011-03-29       1       1       1 163       32\n6 N'est pas décédé  1     2011-03-29       1       1       1 163       32\n    weight    pop\n1 12.38546 228425\n2 12.38546 228425\n3 12.38546 228425\n4 12.38546 228425\n5 12.38546 228425\n6 12.38546 228425\n\n\n\nPour que {srvyr} utilise nos variables nouvellement ajoutées et effectue des calculs, nous devons créer un ‘objet d’enquête’. Il s’agit d’une classe spéciale de dataframe spécifique à {srvyr} et créée à l’aide de la fonction as_survey_design() :\n\ntmp &lt;- df |&gt;\n  as_survey_design(\n    ids = clst_id,\n    wt = weight,\n    fpc = pop\n  )\n\n\nEssayez d’exécuter le code ci-dessus. Quelle est la classe de tmp ? Cet objet se comporte-t-il comme un cadre de données normal ? Essayez d’effectuer quelques manipulations de base, par exemple :\n\nExtrayez les données de la colonne ‘age’\nFiltrez pour ne voir que les personnes décédées\n\n\nComme vous pouvez le constater, une fois que nous avons appliqué as_survey_design(), nous n’avons plus de dataframe normal. Nous devons donc stocker son résultat dans un objet séparé, par exemple tmp ou df_srvy. Cela garantit que df reste un dataframe standard disponible pour d’autres calculs, visualisations, etc.\n{srvyr} offre un certain nombre de fonctions permettant de calculer des indicateurs à partir des données d’enquête, la plupart du temps utilisées à l’intérieur d’une fonction summarize(). Dans notre cas, nous utiliserons la fonction survey_ratio() pour calculer les taux de mortalité bruts et spécifiques. La syntaxe de base de survey_ratio() est assez simple. Par exemple, nous pouvons utiliser ce qui suit pour calculer le taux de mortalité brut :\n\n\n# A tibble: 1 × 4\n    cmr cmr_low cmr_upp cmr_deff\n  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n1 0.531   0.405   0.656     2.28\n\n\nC’est assez simple, mais analysons les arguments :\n\nnumerator est le numérateur de notre ratio, dans ce cas le nombre de personnes décédées (individus pour lesquels died était \"Oui\") multiplié par 10 000 (pour obtenir un résultat final en 10 000 jours-personnes)\ndenominator est le dénominateur de notre ratio, dans ce cas le nombre de personnes-jours à risque (pt)\nvartype toute variable que nous voulons inclure pour estimer l’erreur, ici nous avons choisi l’intervalle de confiance (\"ci\") mais nous pourrions également demander l’erreur type (\"se\")\ndeff indique si nous voulons inclure une estimation de l’effet de conception\nna.rm indique si {srvyr} doit ignorer les valeurs manquantes lors du calcul\n\nLe résultat de ce code est un nouveau cadre de données avec notre estimation ponctuelle (cmr), l’intervalle de confiance (cmr_low et cmr_upp) et l’effet de conception associé.\n\nDans l’exemple ci-dessus, nous avons calculé la mortalité brute. Comme cette enquête est associée à une épidémie particulière (de choléra), nous pourrions également nous intéresser à la mortalité spécifique à la maladie attribuable à la diarrhée. En utilisant le code de mortalité brute comme modèle, écrivez un code pour calculer le taux de mortalité spécifique à la diarrhée. Vous devriez obtenir les résultats suivants :\n\n\n# A tibble: 1 × 4\n   dsmr dsmr_low dsmr_upp dsmr_deff\n  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 0.369    0.257    0.482      2.64\n\n\nNous souhaitons également calculer le taux de mortalité des moins de 5 ans. Dans ce cas, nous calculons la mortalité brute sur le sous-ensemble de notre population âgé de moins de 5 ans, c’est-à-dire que nous devons filtrer notre cadre de données pour ne conserver que les enfants de moins de 5 ans. Écrivez du code pour calculer la mortalité des moins de 5 ans, en gardant à l’esprit que vous devrez filtrer avant de créer votre objet de conception d’enquête. Vous devriez obtenir le résultat suivant :\n\n\n# A tibble: 1 × 4\n   u5mr u5mr_low u5mr_upp u5mr_deff\n  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 0.677    0.363    0.990      1.14\n\n\nComment interpréteriez-vous tous les taux de mortalité ci-dessus ? Prenez une minute pour décrire comment vous pourriez présenter ces résultats. Y a-t-il d’autres indicateurs que vous aimeriez calculer pour une analyse plus complète ?"
  },
  {
    "objectID": "sessions_companion/survey_basic.html#cest-terminé",
    "href": "sessions_companion/survey_basic.html#cest-terminé",
    "title": "Enquête standard sur la mortalité",
    "section": "C’est terminé !",
    "text": "C’est terminé !\nBravo, vous avez maintenant appris à importer, nettoyer et calculer les taux de mortalité à partir de données d’enquête de base sur la mortalité.\n\n\n\n Solutions"
  },
  {
    "objectID": "sessions_companion/survey_basic.html#aller-plus-loin",
    "href": "sessions_companion/survey_basic.html#aller-plus-loin",
    "title": "Enquête standard sur la mortalité",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires\n\nPrécédemment, nous avons calculé le taux de mortalité excédentaire, c’est-à-dire la différence entre la mortalité observée et la mortalité de référence. Un autre indicateur que nous présentons souvent est le nombre de décès excédentaires observés pendant la période de rappel. Comment le calculeriez-vous ?\nUtilisez {ggplot2} pour créer un graphique à barres représentant les décès au fil du temps.\nConsultez la documentation relative à {srvyr} et voyez si vous pouvez utiliser survey_mean() pour calculer la mortalité proportionnelle par cause de décès.\nUtilisez {gt} pour créer un tableau attrayant présentant les données de mortalité proportionnelle que vous avez générées ci-dessus.\nDans la section consacrée au nettoyage, nous avons corrigé les cas où une personne était née pendant la période de rappel mais avait un âge &gt; 0. Comment cela aurait-il pu être évité avec une contrainte Kobo ?"
  },
  {
    "objectID": "sessions_core/06_epicurves.html",
    "href": "sessions_core/06_epicurves.html",
    "title": "Introduction to data visualization with ggplot2",
    "section": "",
    "text": "Découvrir les bases de la visualisation de données en R avec le package {ggplot2}\nConstruire une courbe épidémique simple"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#objectifs",
    "href": "sessions_core/06_epicurves.html#objectifs",
    "title": "Introduction to data visualization with ggplot2",
    "section": "",
    "text": "Découvrir les bases de la visualisation de données en R avec le package {ggplot2}\nConstruire une courbe épidémique simple"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#introduction",
    "href": "sessions_core/06_epicurves.html#introduction",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Introduction",
    "text": "Introduction\nPour cette dernière session, nous allons vous donner une courte introduction à la visualisation de données à l’aide du package {ggplot2}, un outil populaire. Gardez en tête que la visualisation de données est un énorme sujet, et {ggplot2} un vaste package et il n’est pas réaliste de tout traiter en trois heures. La session d’aujourd’hui est une introduction que nous espérons douce aux concepts de base de la visualisation, en prenant pour objet un graphe fameux en épidémiologie, la courbe épidémique.\nNotre visualisation finale ressemblera à ceci :"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#setup",
    "href": "sessions_core/06_epicurves.html#setup",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Setup",
    "text": "Setup\nDépendances. Cette session suppose que vous savez utiliser RStudio, que vous êtes capable d’importer des données et que vous connaissez les verbes de base de manipulation des données que nous avons vus dans les sessions de base jusqu’à présent. Si vous avez besoin d’un rappel sur l’un de ces sujets, nous vous encourageons à revoir les sessions de base du parcours d’apprentissage.\n\nCette session utilisera la version nettoyée de l’ensemble de données Moissala sur la rougeole.\n\n\n\n  Course Folder\n\n\n\n Ouvrez votre projet Rstudio du cours et créez un nouveau script appelé “courbe_epi.R” avec les métadonnées appropriées. Enregistrez le dans R/. Pour cette session, nous aurons besoin de charger les packages {here}, {rio}, {dplyr}, {lubridate}, et{ggplot2}. Ajoutez une section # IMPORTATION DONNÉES où vous importez les données nettoyées du cours (linelist_moissala_clean_FR.RDS)."
  },
  {
    "objectID": "sessions_core/06_epicurves.html#les-paradigmes-de-la-création-de-graphiques",
    "href": "sessions_core/06_epicurves.html#les-paradigmes-de-la-création-de-graphiques",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Les paradigmes de la création de graphiques",
    "text": "Les paradigmes de la création de graphiques\nIn R, and indeed in everything, there are a loIl y a de nombreuses approches à la visualisation de données, en général et en R en particulier. Les deux plus grands paradigmes sont :\n\nTout en un : cette approche est caractérisée par l’existence d’une fonction (en général complexe) pour gérer tous les aspects de la construction d’un graphique. Base R par exemple, utilise cette approche (et n’est pas le seul).\nGraphiques en couches (ou modulaires) : le graphique est décomposé en éléments (formes, titres, barres d’erreurs, thèmes…) associées à des couches. Différentes fonctions ajoutent ou modifient ces éléments. Ce paradigme est utilisé par les packages {ggplot2}, {highcharter}, ou {echarts4r} et un certain nombre d’outils modernes.\n\nUne discussion approfondie sur les raisons pour lesquelles on peut utiliser une approche plutôt qu’une autre dépasse le cadre de ce cours, mais nous noterons que la plupart des paquets de visualisation modernes ont tendance à utiliser un [modèle en couches] {.hovertip bs-toggle=‘tooltip’ bs-title=“C’est parce que les modèles en couches ont tendance à être plus pratiques lors de la construction de visualisations complexes ou hautement personnalisées.”}. En gardant cela à l’esprit, examinons les types de couches dont nous parlons dans notre approche « en couches ».\n\nDécomposition d’un graphique\nDans ce tutoriel, nous décomposons les graphiques en quatre composantes (couches) :\n\nLe canevas / les données\nLes formes géométriques primaires\nLes titres et labels\nLe thème\n\nOn peut illustrer ces composants avec la courbé épidémique schématique suivante :\n\n\n\n\n\nLa première couche, le caneva (ou la toile) est fondamentale. Comme un artiste prépare sa toile vierge et ses outils avant de se lancer dans une peinture, R doit en premier lieu créer un canevas prêt à accueillir les éléments de représentation graphique. C’est lors de la création du canevas que nous indiquons à R que nous voulons créer un graphique, et avec quelles variables.\nIci, nous allons spécifier à R que nous voulons un graphique où l’axe horizontal représente la date, et l’axe vertical représente le nombre de cas. Une fois le canevas mise en place, nous ajouterons d’autres couches, comme un artiste ajouterait de la peinture, leur signature ou un cadre.\n\n\nOssature d’un ggplot\nLa recette pour construire un ggplot (un graphe produit par le package {ggplot}) est de la forme suivante :\n\nCréation d’un canevas à l’aide de ggplot(aes(...))\nAjout de couches sur le canevas avec +\n\nNotez que {ggplot2} utilise l’opérateur + pour ajouter des couches sur le graphe.\nLa syntaxe générale d’un ggplot est :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;                    # passer les données\n  ggplot(aes(x = ...,    # étape 1 : créer le canevas\n             y = ...)) +\n  couche_1(...) +        # étape 2 : ajout de la première couche\n  couche_2(...) +        # étape 3 : ajout d'une autre couche\n  ...                    # continuer à ajouter des couches...\n\nLe nombre de couches à ajouter dépend de la complexité du graphique que vous souhaitez créer. Dans notre cas, nous ajouterons trois couches en utilisant les fonctions suivantes :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;                    # passer les données\n  ggplot(aes(x = ...,    # étape 1 : créer le canevas\n\n             y = ...)) +\n  geom_col(...) +        # étape 2 : ajout des formes (barres)\n  labs(...) +            # étape 3 : ajouter des titres\n  theme_classic(...)     # étape 4 : amélioration du thème\n\nNous pouvons mettre à jour notre précédent schéma avec ces fonctions :\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDans l’exemple précédent, nous passons le jeu de données à la fonction ggplot() à l’aide de l’opérateur pipe (comme nous l’avons souvent fait avec d’autres fonctions). C’est possible car le premier argument nécessaire de la fonction est le dataframe contenant les variables à représenter. Soyez attentifs, il est facile de se tromper et de chercher à utiliser un + à la place du |&gt;\n\n\nDans la section suivante, nous allons décrire les différentes étapes plus en détail, en utilisant notre jeu de données rougeole à Moissala pour faire notre première courbe épidémique."
  },
  {
    "objectID": "sessions_core/06_epicurves.html#sec-epicurve-steps",
    "href": "sessions_core/06_epicurves.html#sec-epicurve-steps",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Votre premier ggplot",
    "text": "Votre premier ggplot\n\nPréparer vos données : Agrégation par jour\nNous aimerions tracer une courbe des cas quotidiens. Vous l’aurez peut-être remarqué, nos données actuelles sont quotidiennes, mais il est évident que plusieurs cas peuvent se produire certains jours. Donc,il faut agréger les données par jour. Heureusement, vous avez déjà appris à résumer les données lors des sessions précédentes.\n\nEn utilisant count(), créez un nouveau dataframe appelé df_cases qui résume le nombre total de cas observés par jour. L’en-tête de ce cadre de données devrait ressembler à ceci :\n\n\n# A tibble: 6 × 2\n  date_debut     n\n  &lt;date&gt;     &lt;int&gt;\n1 2022-08-13     1\n2 2022-08-17     1\n3 2022-08-18     1\n4 2022-08-22     1\n5 2022-08-30     2\n6 2022-09-01     1\n\n\n\nBien !\nDans les étapes suivantes, vous allez utiliser df_cas pour tracer une courbe épidémique du nombre de cas par semaine. En revanche, les exemples données dans les exercices pour illustrer le fonctionnement des fonctions seront faits sur le nombre de hospitalisations par semaine. Pour cela, j’utiliserai un dataframe df_hopital, qui ressemble à ceci :\n\n\n# A tibble: 6 × 2\n  date_admission patients\n  &lt;date&gt;            &lt;int&gt;\n1 2022-08-14            1\n2 2022-08-25            1\n3 2022-09-02            1\n4 2022-09-06            1\n5 2022-09-09            1\n6 2022-09-10            1\n\n\n\n\nCréer le canevas\nLa première étape est de créer votre “canevas” en spécifiant votre jeu de données et le nom des colonnes que vous voulez représenter sur le graphique. Cela est fait à l’aide de la fonction ggplot(aes()) selon la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_data |&gt;\n  ggplot(aes(x = x_axis_variable_name,\n             y = y_axis_variable_name))\n\nPour l’exemple, je vais placer la date (date_admission) sur l’axe des x et le nombre de patients (patients) sur l’axe des y :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients))\n\n\n\n\n\n\n\n\nDans Rstudio, ce graphique devrait apparaître dans l’onglet “Plots” dans le panneau en bas à droite (par défaut) :\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nJust like with {dplyr}, we write our column names without quotation marks. This is unsurprising as {ggplot2}, like {dplyr}, is a member of the {tidyverse} and therefore uses similar syntax.\n\n\nQu’est ce que cette fonction aes() que nous avons imbriqué dans la fonction ggplot() ?\nLa fonction aes() n’est jamais utilisée seule, elle est toujours passée à ggplot(). Elle sert à faire correspondre les variables du jeu de données aux éléments visuels du graphique (en anglais on parle de “mapping”, qui est occasionnellement traduit par “mappage”). Les plus basiques de ces éléments graphiques sont les axes, mais on peut aussi définir comment la couleur ou la taille d’éléments varie en fonction de variables dans les données (par exemple, statut à la sortie).\n\nCréez une nouvelle section # PLOT COURBE EPI. Ensuite, en vous inspirant de l’exemple précédent, créez la base d’un ggplot avec le dataframe df_cas, et définissez l’axe des x et des x.\n\nPour le moment, le résultat devrait ressembler à ceci :\n\n\n\n\n\n\n\n\n\nTrès bien. Maintenant, ajoutons les barres\n\n\nAjouter les formes\nMaintenant que la toile est prête, commençons à dessiner dessus, et ajoutons des formes. Dans {ggplot2}, les formes géométriques sont surnommées des “géométries” ou “geom” en raccourci, et représentent les données. Les geoms les plus courants sont :\n\nDiagrammes en bâtons (geom_col() or geom_bar())\nHistogrammes (geom_histogram())\nNuages de points(geom_point())\nCourbes(geom_line())\nDiagramme en boîte à moustache (boxplots) (geom_boxplot())\n\nAujourd’hui nous allons nous concentrer sur les diagrammes en bâton, pour créer une courbe épidémique. Nous allons utiliser la fonction geom_col().\nNous allons maintenant rajouter les barres à la courbe des cas hospitalisés. Rappelez-vous que l’on ajoute une nouvelle couche à notre objet ggplot à l’aide de +.\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col()\n\n\n\n\n\n\n\n\nC’est génial, cela ressemble vraiment à une épicurve. Bien qu’elle ait l’air un peu… grise. Si nous voulons mettre à jour la couleur de nos barres (appelée le fill), nous devons simplement ajouter l’argument fill to geom_col().\nFaisons un essai :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\")\n\n\n\n\n\n\n\n\n\nMettez à jour votre graphe pour ajouter les barres avec la couleur #2E4573.\n\nVotre graphe devrait ressembler à ceci :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDans {ggplot2}, les couches doivent être ajoutées à un objet ggplot existant (le canevas définit à l’étape 1). Exécuter la fonction geom_col() toute seule ne produira pas un graphe. Si l’on reprend notre analogie avec la peinture, ce serait comme essayer d’utiliser la peinture sans support (toile).\n\n\nCe graphe s’améliore d’instant en instant ! Maintenant il est temps de le rendre un petit peu plus informatif…\n\n\nAjouter les titres\nUn bon graphique doit avoir des titres et des labels informatifs or pour le moment, ce n’est pas le cas de nos graphiques (n n’est pas très informatif).\nLa fonction lab() permet d’ajouter des titres et labels à plusieurs éléments du graphique :\n\nTitre des axes (x = ety =)\nTitre du graphique (title =)\nCaption\n\nComme avec les autres couches, nous pouvons ajouter la couche contenant les titres et labels à notre graphe avec le signe + :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la région de Madoul (Tchad)\")\n\n\n\n\n\n\n\n\n\nAjoutez des titres raisonnables à votre graphe.  Bonus. Ajoutez une source des données en utilisant caption.\n\nVotre graphe pourrait maintenant ressembler à celle-ci (par exemple) :\n\n\n\n\n\n\n\n\n\n\n\nChanger le thème\nLe thème de base de ggplot n’est pas très attractif, et la taille des polices est trop petite pour être lisible sur la majorité des supports. Si vous voulez utiliser votre graphique dans des rapports ou des présentations, il vaudrait mieux améliorer son apparence.\nPour cela, il suffit d’ajouter une couche “thème” à notre graphe (la dernière couche pour aujourd’hui !). Si le nom des fonctions des geoms commençait toujours par geom_, le nom de toutes les fonctions de thème commence par theme_. Il existe plusieurs thèmes prédéfinis, et vous pouvez aller les regarder sur le site de {ggplot2}.\nAujourd’hui, nous allons utiliser theme_classic(), qui offre une alternative élégante au thème de base :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la région de Madoul (Tchad)\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nC’est déjà plus joli. Maintenant, nous voudrions augmenter la taille de la police. Nous pouvons faire ça en ajustant la taille de la police à l’aide de l’argument base_size:\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la région de Madoul (Tchad)\") +\n  theme_classic(base_size = 17)\n\n\n\n\n\n\n\n\n’est beaucoup mieux !\nRappelez-vous que la taille de la police doit être choisie en fonction de la destination du graphe (présentation, rapport informel, rapport final ?). Il en va de même pour le choix du thème, qui reste un choix partiellement subjectif. Il existe des principes de visualisation qui peuvent guider vos choix lors de la création d’un graphe (ou d’une table), mais la visualisation de données est autant un art qu’une science.\n\nAjoutez une dernière couche à votre graphe pour ajouter un thème de votre choix, avec une taille de police plus appropriée.\n\n\n\nSauvegarder votre graphique\nSi vous souhaitez enregistrer votre graphe, vous pouvez cliquer sur le bouton « Exporter » dans le panneau de tracé de RStudio :"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#la-fin",
    "href": "sessions_core/06_epicurves.html#la-fin",
    "title": "Introduction to data visualization with ggplot2",
    "section": "La Fin !",
    "text": "La Fin !\nBravo! Vous avez créé votre première courbe épidémique en R !\n\n\n\n Solutions file"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#aller-plus-loin",
    "href": "sessions_core/06_epicurves.html#aller-plus-loin",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires\n\nUtilisez le theme_minimal() sur un de vos graphiques, avec une police de taille de base de 18.\nAllez sur ce site, choisissez une couleur et mettez à jour la couleur de vos barres.\n\n\n\nExercices de défi\n\nAu lieu d’agréger par date, comptez le nombre de patients par sous-préfecture. Essayez d’adapter votre code pour créer un diagramme à barres du nombre de patients par sous-préfecture.\n\n\n\nSatellites\n\nCourbes épidémiques hebdomadaires\nGraphiques multiples (facetting)"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#ressources",
    "href": "sessions_core/06_epicurves.html#ressources",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Ressources",
    "text": "Ressources\n\nUn livre complet sur l’utilisation de {ggplot2}.\n\nUn chapitre entier sur les épicurves"
  },
  {
    "objectID": "sessions_core/05_summary_table.html",
    "href": "sessions_core/05_summary_table.html",
    "title": "Tableaux récapitulatifs",
    "section": "",
    "text": "Créer des tableaux de contingence avec count()\nCalculer des statistiques récapitulatives par groupe à l’aide de summarize()\nRéviser comment sélectionner les lignes en utilisant filter() et créer/modifier des variables avec mutate()\nCréer des variables catégorielles ordonnées"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#objectifs",
    "href": "sessions_core/05_summary_table.html#objectifs",
    "title": "Tableaux récapitulatifs",
    "section": "",
    "text": "Créer des tableaux de contingence avec count()\nCalculer des statistiques récapitulatives par groupe à l’aide de summarize()\nRéviser comment sélectionner les lignes en utilisant filter() et créer/modifier des variables avec mutate()\nCréer des variables catégorielles ordonnées"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#setup",
    "href": "sessions_core/05_summary_table.html#setup",
    "title": "Tableaux récapitulatifs",
    "section": "Setup",
    "text": "Setup\nDépendances. Cette session suppose que vous savez utiliser RStudio, que vous êtes capable d’importer des données et que vous connaissez les verbes de base de manipulation des données que nous avons vus dans les sessions de base jusqu’à présent. Si vous avez besoin d’un rappel sur l’un de ces sujets, nous vous encourageons à revoir les sessions de base du parcours d’apprentissage.\n\nCette session utilisera la version nettoyée de l’ensemble de données Moissala sur la rougeole.\n\n\n\n Linelist rougeole nettoyée\n\n\n\n Ouvrez votre projet RStudio et créez un nouveau script dans le sous-dossier R appelé tables.R avec les métadonnées appropriées et une section “Packages” qui importe : {rio}, {here} et {tidyverse}. Ajoutez une section “Import Data” qui charge la version nettoyée de la linelist de la rougeole dans R."
  },
  {
    "objectID": "sessions_core/05_summary_table.html#introduction-agrégation-des-données",
    "href": "sessions_core/05_summary_table.html#introduction-agrégation-des-données",
    "title": "Tableaux récapitulatifs",
    "section": "Introduction : agrégation des données",
    "text": "Introduction : agrégation des données\nRécapitulons. Vous venez d’effectuer l’une des tâches les [plus importantes]{.hovertip bs-toggle=‘tooltip’ bs-title=’Certains considèrent que cela représente 80 % du travail !} d’un épidémiologiste : le nettoyage des données. Maintenant que vous disposez de données propres et normalisées, vous pouvez vous mettre au travail et commencer à les analyser. Les analyses commencent généralement par des tableaux et des résumés qui décrivent nos données :\n\nTableaux de fréquence univariés pour compter les occurrences de différentes valeurs\nStatistiques sommaires des variables numériques (moyenne, médiane, écart-type)\nTableaux croisés pour examiner les relations entre les variables catégorielles\nRésumés par groupe pour comparer les statistiques entre différents sous-ensembles de données"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#compter-plusieurs-colonnes-tableaux-de-contingence",
    "href": "sessions_core/05_summary_table.html#compter-plusieurs-colonnes-tableaux-de-contingence",
    "title": "Tableaux récapitulatifs",
    "section": "Compter plusieurs colonnes (tableaux de contingence)",
    "text": "Compter plusieurs colonnes (tableaux de contingence)\nAu cours de la session d’exploration des données, vous avez appris à créer un tableau de fréquence pour une variable catégorielle unique à l’aide de la fonction count(). C’est bien, mais nous voulons souvent compter le nombre d’observations en fonction de deux variables (ou plus !).\nCes tableaux sont appelés tableaux de contingence. Par exemple, connaître le nombre de patients par sous-préfecture est très utile, mais nous pourrions vouloir stratifier à la fois par sous-préfecture et par groupe d’âge pour voir si certaines zones ont des patients anormalement âgés. Ce type de stratification est un moyen utile d’essayer de trouver des zones qui pourraient être de bons candidats pour des campagnes de rattrapage. C’est facile, il suffit de passer plusieurs noms de colonnes à count() :\n\ndf_linelist |&gt;\n  count(sous_prefecture, age_groupe)\n\n\nCréez un nouveau tableau récapitulatif en comptant le nombre de patients stratifiés par sous_prefecture et hospitalisation. Que se passe-t-il si vous modifiez l’ordre des arguments donnés à count() ?\nMaintenant, en utilisant count(), réponds aux questions suivantes :\n\nCombien de patients étaient des femmes ? Quelle est la proportion ?\nQuelles sont toutes les valeurs possibles de la variable statut_sortie ?\nCombien de patients âgés de 1 à 4 ans se sont rétablis ?"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#filtrer-les-valeurs-na",
    "href": "sessions_core/05_summary_table.html#filtrer-les-valeurs-na",
    "title": "Tableaux récapitulatifs",
    "section": "Filtrer les valeurs NA",
    "text": "Filtrer les valeurs NA\nEn examinant les catégories du statut_sortie, vous devriez avoir remarqué que certaines patientes ont des valeurs manquantes (NA):\n\ndf_linelist |&gt;\n  count(statut_sortie) |&gt;\n  mutate(prop = n / sum(n))\n\n\nObservez le résultat du code ci-dessus. Comment pouvez-vous également calculer la proportion de patients décédés ? Êtes-vous satisfait de ce calcul ?\n\nLa proportion de cas décédés est également appelée taux de létalité. Pour calculer précisément le CFR, nous devons nous assurer que le dénominateur ne comprend que les patients dont nous sommes sûrs du résultat (c’est-à-dire que nous devons supprimer tous les cas avec “NA” ou “contre avis médical”).\nRappelons que nous pouvons le faire en utilisant filter(). Pour garder les valeurs manquantes (NA) dans une variable, nous pouvons utiliser la petite fonction is.na(statut_sortie). L’ajout d’un ! devant fera l’inverse : supprimer les valeurs manquantes de statut_sortie :\n\ndf_linelist |&gt;\n  filter(statut_sortie != \"sortie contre avis medical\", \n         !is.na(statut_sortie)) |&gt;\n  count(statut_sortie)\n\n\nQuelle autre instruction conditionnelle pourriez-vous utiliser dans filter() pour obtenir les mêmes résultats ?\n\nMaintenant que nous avons supprimé les patients dont l’issue est inconnue, nous pouvons ajouter ceci avant de créer notre tableau de fréquence pour obtenir le CFR correct.\n\nÀ l’aide de votre filtre, mettez à jour votre code pour résumer le nombre observé de patients qui ont survécu et sont décédés ainsi que le taux de létalité (proportion de décès). Stockez ce nouveau dataframe dans un objet, cfr_df.\n\n\n\n\n\n\n\nAstuce\n\n\n\nBonus. Une fonction de “raccourci” utile est drop_na() du package {tidyr} qui équivaut à filter(!is.na()).\n\ndf_linelist |&gt;\n  drop_na(statut_sortie) |&gt;\n  count(statut_sortie)\n\ndrop_na() est particulièrement utile car vous pouvez lui donner plusieurs noms de colonnes pour filtrer. Mais attention, cela supprimera toutes les lignes où une ou plusieurs de ces colonnes ont une valeur manquante."
  },
  {
    "objectID": "sessions_core/05_summary_table.html#tableau-récapitulatif-statistiques-par-sous-préfecture",
    "href": "sessions_core/05_summary_table.html#tableau-récapitulatif-statistiques-par-sous-préfecture",
    "title": "Tableaux récapitulatifs",
    "section": "Tableau récapitulatif : statistiques par sous-préfecture",
    "text": "Tableau récapitulatif : statistiques par sous-préfecture\nMaintenant que nous avons produit quelques tableaux de fréquence et de contingence simples, nous pouvons augmenter la complexité. Une tâche courante en épidémiologie consiste à examiner les statistiques résumées dans des sous-ensembles de données.\nPar exemple, on peut nous demander de produire des statistiques sur les patients au niveau des sous-préfectures, c’est-à-dire que pour chaque sous-préfecture dans les données, nous devons répondre aux questions suivantes :\n\nCombien de patients ont été consultés ?\nQuel est leur âge moyen ?\nQuelle a été la date d’admission la plus ancienne ?\nCombien de patients ont été hospitalisés ?\nParmi les enfants de moins de 6 mois, combien sont décédés ?\n\nC’est exactement pour cela que la fonction summarize() a été créée ! Elle nous permet de calculer des statistiques résumées sur un ensemble de données, et la syntaxe est similaire à celle de mutate() :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;\n  mutate(new_col = function_to_create(existing_col))\n\ndf |&gt;\n  summarize(.by = grouping_variable,\n            new_col = summary_function(existing_col))\n\nConsidérons le code suivant, où nous résumons les données pour calculer l’âge moyen de tous les patients.\n\ndf_linelist |&gt;\n  summarize(moy_age = mean(age))\n\n# A tibble: 1 × 1\n  moy_age\n    &lt;dbl&gt;\n1    6.82\n\n\nNotez que ce code donne une seule valeur pour l’âge moyen. Aucune variable de regroupement n’a été fournie, donc summarize() a renvoyé une statistique récapitulative pour l’ensemble du jeu de données. Pour calculer l’âge moyen par strate spécifique, nous devons spécifier une variable de regroupement en utilisant l’argument .by :\n\ndf_linelist |&gt;\n  summarize(.by = sexe, # Faire le résumé (ici, la moyenne) par sexe\n            moy_age = mean(age))\n\n# A tibble: 2 × 2\n  sexe  moy_age\n  &lt;chr&gt;   &lt;dbl&gt;\n1 f        6.77\n2 m        6.87\n\n\n\nJetez un œil aux résultats ci-dessus. Comment les interprétez-vous ?\n\nMaintenant que nous pouvons utiliser summarize(), nous pouvons l’utiliser pour calculer des statistiques récapitulatives appropriées par sous-préfecture. Commençons par appeler un summarize() vide et regrouper les données sur sous_prefecture.\n\nExécutez le code suivant :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture)\n\nQue se passe-t-il lorsque vous exécutez ces lignes ?\n\n\nComptages\nNous voulons d’abord examiner le nombre de cas dans chaque sous_prefecture. Cela peut être fait en utilisant la fonction d’aide n() :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n()  # pour compter\n)\n\n\nOk, maintenant construisons un tableau récapitulatif pour chaque sous-préfecture. Commençons par reproduire les lignes ci-dessus.\n\n\n\nRécapitulatifs des variables continus\nNous pouvons ensuite utiliser les fonctions mean(), median(), min(), max() (et autres) pour produire des récapitulatifs pour les variables continues. Par exemple, l’âge moyen :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n(),\n            mean_age = mean(age))\n\n\nAjoutez la date d’admission minimale à votre tableau pour chacune des sous_prefecture ? Êtes-vous satisfait des résultats ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN’oubliez pas qu’avec les fonctions arithmétiques telles que mean(), median(), min(), max(), vous devez indiquer explicitement à R de supprimer NA.\n\n\n\n\nComptage avec une condition\nNous pouvons également être intéressés par le nombre de patients (lignes) qui répondent à une condition : le nombre de patients de sexe féminin. Le comptage par condition logique peut être effectué avec la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nsummarize(sum_category = sum(LOGIC_TEST, na.rm = TRUE))\n\nCette somme nous permet de compter toutes les lignes où notre condition a été remplie (retourne TRUE). Par exemple :\nCette somme nous permet de compter toutes les lignes où notre condition a été remplie (retourne TRUE). Par exemple :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_female = sum(sexe == \"f\", na.rm = TRUE))\n\n\nAjoutez une variable à votre tableau qui compte le nombre de patients qui ont été hospitalisés. (c’est-à-dire : les lignes qui ont “oui” dans la variable “hospitalisation”)\n\n\n\nAutres statistiques\nParfois, nous voulons produire une statistique plus compliquée, par exemple l’âge moyen de tous les patients hospitalisés. Ici, la syntaxe est un peu différente :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;\n  summarize(mean_category = mean(col_to_use[LOGIC_TEST], na.rm = TRUE))\n\nIci, nous avons : - Indiqué quelle statistique de synthèse nous voulons utiliser (mean()) - Indiqué sur quelle colonne nous voulons calculer cette statistique (col_to_use) - Création d’une condition indiquant les observations de cette colonne à utiliser dans le calcul ([LOGIC_TEST])\nPour donner un exemple concret, si nous voulions calculer la moyenne de la variable age mais uniquement pour les patients hospitalisés (c’est-à-dire dans les lignes où hospitalisation == \"oui\") nous écririons :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n(),\n            moy_age_hosp = mean(age[hospitalisation == \"oui\"], na.rm = TRUE))\n\nL’utilisation d’un test logique dans l’exemple ci-dessus est appelée indexation logique, où une condition est essentiellement utilisée pour filtrer les observations que vous souhaitez prendre en compte lors d’un calcul. L’indexation logique est très puissante, mais elle peut aussi demander un certain temps d’adaptation, alors ne vous inquiétez pas trop si ce n’est pas parfaitement clair à ce stade.\n\nPouvez-vous utiliser cette syntaxe pour calculer l’âge moyen des patientes dans votre tableau ?\n\nC’est très bien ! Nous commençons à obtenir un tableau récapitulatif groupé assez exhaustif avec beaucoup d’informations utiles par “sous-préfecture” ! Un défi supplémentaire pour vous :\n\nDÉFI : Pourriez-vous ajouter une variable à votre tableau qui compte le nombre de patients décédés parmi ceux qui ont &lt; 6 mois.\n Note. Vous voulez compter les lignes (donc utiliser sum()) qui remplissent une condition spécifique pour le résultat (statut_sortie == \"deces\"), mais uniquement lorsque age_group == \"&lt; 6 months\"\n\n\n\nUtiliser la sortie\nEnfin, n’oubliez pas que summarize() renvoie un dataframe que nous pouvons ensuite manipuler davantage (par exemple : avec filter() et mutate()).\n\nAjoutez un mutate() après avoir produit votre tableau récapitulatif pour calculer :\n\nLa proportion de patients hospitalisés par sous-préfecture\nLa proportion de patientes par sous-préfecture\n\n\nL’en-tête de votre tableau final devrait ressembler à ceci :\n\n\n# A tibble: 6 × 11\n  sous_prefecture n_patients moy_age min_admission n_femme n_hosp moy_age_hosp\n  &lt;chr&gt;                &lt;int&gt;   &lt;dbl&gt; &lt;date&gt;          &lt;int&gt;  &lt;int&gt;        &lt;dbl&gt;\n1 Moissala              1808    6.84 2022-08-14        923    612         5.49\n2 Bouna                 1376    6.56 2023-01-11        669    412         5.67\n3 Bedjondo               534    7.07 2023-06-09        251    184         5.21\n4 Bekourou               496    6.84 2023-06-17        251    164         6.04\n5 Bedaya                 435    7.10 2023-07-04        209    147         6.16\n6 Koumra                 253    7.11 2023-08-14        138     84         6.26\n# ℹ 4 more variables: moy_age_femme &lt;dbl&gt;, n_deces_moins_6m &lt;int&gt;,\n#   prop_female &lt;dbl&gt;, prop_hosp &lt;dbl&gt;"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#cest-fait",
    "href": "sessions_core/05_summary_table.html#cest-fait",
    "title": "Tableaux récapitulatifs",
    "section": "C’est fait !",
    "text": "C’est fait !\nVous devriez être fiers de vous, la création de tableaux récapitulatifs est une compétence importante pour un épidémiologiste, et le faire en R est très efficace ! N’oubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#pour-aller-plus-loin",
    "href": "sessions_core/05_summary_table.html#pour-aller-plus-loin",
    "title": "Tableaux récapitulatifs",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices supplémentaires\n\nCréez un tableau récapitulatif qui calcule les statistiques suivantes par groupes d’âge :\n\n\nLe nombre de patients\nLa proportion d’hommes\nLe nombre de décès\nLe CFR\nLe nombre de décès parmi les patients atteints de pneumonie\n\n\nFaites un tableau qui montre la proportion de patients par âge ayant reçu un vaccin contre la rougeole (par rappel oral ou par carte) et ceux qui ont reçu 1 ou 2 doses.\nFaites un tableau comparant la proportion de patients hospitalisés et non hospitalisés présentant un TDR positif pour le paludisme, de la fièvre, une éruption cutanée, une toux, des yeux rouges, une pneumonie, une encéphalite et un MUAC « rouge » ou « jaune » (moins de 125 mm).\nCalculer le nombre moyen de jours entre l’apparition des premiers symptômes et la consultation par sous-préfecture.\nCalculer le temps moyen passé à l’hôpital (i.e. jours entre l’admission et le résultat) par résultat (i.e. chez ceux qui ont guéri et ceux qui sont décédés).\n\n\n\nRessources supplémentaires\n\nLe chapitre du manuel EpiR sur le regroupement des données\nUne fois que vous avez des tableaux, vous pouvez les personnaliser en profondeur pour l’affichage/la publication à l’aide du paquetage {gt} :\n\nSite web de gt\nLivre sur gt"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html",
    "href": "sessions_core/04_data_verbs_conditional.html",
    "title": "Traitement de données, recoder et filtrer",
    "section": "",
    "text": "Dans la session précédente vous avez appris les bases du traitement de données en R avec les fonctions du {tidyverse}, en particulier comment sélectionner et modifier les colonnes d’un data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre à :\n\nÉcrire des conditions logiques basiques, ce qui va nous permettre de :\nSélectionner des lignes d’un data frame avec filter()\nRecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "href": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "title": "Traitement de données, recoder et filtrer",
    "section": "",
    "text": "Dans la session précédente vous avez appris les bases du traitement de données en R avec les fonctions du {tidyverse}, en particulier comment sélectionner et modifier les colonnes d’un data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre à :\n\nÉcrire des conditions logiques basiques, ce qui va nous permettre de :\nSélectionner des lignes d’un data frame avec filter()\nRecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "href": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Mise en place",
    "text": "Mise en place\nPrérequis : cette leçon part du principe que vous connaissez les bases de la manipulation de données avec {dplyr}, et en particulier la fonction mutate(). Aller vous rafraîchir si besoin.\n\nNous utiliserons la liste linéaire avec les données brutes qui peut être téléchargée ici :\n\n\n\n Télécharger les données\n\n\n\n Si ce n’est pas déjà fait, enregistrez la dans le sous-dossier approprié de votre projet RStudio puis créez un nouveau script appelé filtrer_recoder.R dans votre sous-dossier R. Ajoutez un en-tête approprié et chargez les paquets suivants : {here}, {rio} et {tidyverse}.  Enfin, ajoutez une section dédiée à l’import des données, utilisez {here} et {rio} pour importer vos données dans R, et assignez-les à un objet que nous appellerons df_brut"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#filtrer-des-données-avec-des-conditions-logiques",
    "href": "sessions_core/04_data_verbs_conditional.html#filtrer-des-données-avec-des-conditions-logiques",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Filtrer des données avec des conditions logiques",
    "text": "Filtrer des données avec des conditions logiques\nNous avons appris précédemment comment comment sélectionner les colonnes d’un data frame. Nous allons à présent apprendre la tâche complémentaire, qui est la sélection des lignes d’un data frame. C’est une tâche particulièrement courante du travail d’épidémiologiste qui permet de sélectionner des observations qui satisfont à certains critères. Le paquet {dplyr} possède bien évidement une fonction pour ça, la fonction filter().\nAvant de pouvoir l’utiliser nous allons néanmoins devoir apprendre à écrire des conditions logique, qui sont également un prérequis pour recoder des variables. Les conditions logiques sont des questions (ou tests) auxquelles R va répondre par TRUE ou FALSE (ou NA).\n\nEgalité\nLa syntaxe de filter() est assez simple :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition_logique])\n\nCette syntaxe permet de conserver les lignes où condition_logique est vraie. Ici, la condition logique va demander si quelque chose est égale à autre chose. Par exemple, si telle variable est égale à telle valeur (est ce que patient a été hospitalisé ?). En R, nous testons l’égalité avec l’opérateur ==.\nEn pratique, pour créer un filtre qui ne garde que les patients hospitalisés nous écrivons :\n\ndf_brut |&gt;\n  filter(hospitalisation == \"oui\")\n\nIci, filter() parcourt chaque ligne de notre data frame et teste si la valeur d’hospitalisation dans cette ligne est égale à \"oui\". La fonction ne renvoie alors que les lignes où la réponse à la question est TRUE [vrai].\n\nFiltrez vos données pour ne conserver que les patients qui avaient de la fièvre (c’est à dire les patients contenant la valeur \"Yes\" dans la colonne fievre. Le début de la colonne fievre dans la sortie filtrée est :\n\n\n  fievre\n1    Yes\n2    Yes\n3    Yes\n4    Yes\n5    Yes\n6    Yes\n\n\nInspectez la sortie et df_brut. Pourquoi df_brut contient-il encore les patients qui n’avaient pas de fièvre ?\n\n\n\nInégalité\nParfois, nous préférons tester l’inégalité plutôt que l’égalité ; pour examiner les patients qui ne se sont pas rétablis, par exemple, qu’ils soient décédés ou sorti contre avis médical. Dans ce cas nous utiliserons l’opérateur !=, ce qui donne ce code :\n\ndf_brut |&gt;\n  filter(issue != 'gueri') # Garde les lignes avec patients NON guéris\n\n\nFiltrez votre data frame pour ne montrer que les patients qui n’ont pas de carte confirmant leur statut vaccinal. Le début de la colonne filtrée ressemble à :\n\n\n  statut_vaccinal\n1             Non\n2             Non\n3             Non\n4             Non\n5             Non\n6             Non\n\n\nAstuce : Rappelez-vous que vous pouvez utiliser count() pour vérifier les modalités de statut_vaccinal.\n\n\n\nSupérieur à / Inférieur à\nDans le cas des variables numériques, on sera souvent intéressé par savoir si une valeur est supérieure ou inférieure à un seuil. Par exemple, quels sont les patients de moins de 5 ans. Ici, nous utiliserons les opérateurs &lt; et &gt; pour évaluer si une variable est inférieure à ou supérieure à une valeur donnée, respectivement.\nNous pouvons par exemple filtrer les patients de moins de 60 mois :\n\ndf_brut |&gt;\n  filter(age &lt; 60)\n\n\nAffichez un data frame ne contenant que les patients souffrant de malnutrition aiguë sévère. Le début de la colonne concernée est :\n\n\n    pb\n1  244\n2  232\n3  123\n4  210\n5   80\n6  220\n7  152\n8  155\n9  232\n10 135\n\n\nEcrivez un autre filtre qui sélectionne les patients âgés de plus de 15 ans. L’en-tête de votre colonne d’âge doit ressembler à ceci :\n\n\n  age\n1 348\n2 348\n3 312\n4 432\n5 444\n6 324\n\n\n\nSi nous ne voulons pas l’égalité stricte nous pouvons ajouter un signe égal aux opérateurs précédents, ce qui donne &lt;= pour “inférieur ou égal à” et &gt;= pour “supérieur ou égal à”. Attention, le = doit venir après les opérateurs &lt; et &gt;, pas avant.\nPour filtrer les patients avec 10 ans ou moins :\n\ndf_brut |&gt;\n  filter(age &lt;= 120)\n\n\nSélectionnez tous les patients avec un état nutritionnel normal, c’est-à-dire les patients dont le PB est supérieur ou égal à 125mm. L’en-tête du pb devrait ressembler à ceci :\n\n\n    pb\n1  244\n2  232\n3  210\n4  220\n5  152\n6  155\n7  232\n8  135\n9  146\n10 202\n\n\n\n\n\nConditions multiples\nIl est possible de combiner plusieurs conditions logiques dans un même filtre ! Il suffit de séparer plusieurs conditions logiques par une virgule.\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition 1],\n         [condition 2],\n         [condition 3])\n\nPar exemple, nous pourrions sélectionner tous les patients hospitalisés de moins de cinq ans :\n\ndf_brut |&gt;\n  filter(age &lt; 5,\n         hospitalisation == \"oui\")\n\n\nCréez un filtre qui sélectionne tous les patients de la sous-préfecture de Koumra hospitalisés et sévèrement malnutris Cela donne :\n\n\n    id sous_prefecture hospitalisation  pb\n1 8624          KOUMRA             oui 103\n2 8939          KOUMRA             oui  67\n3 9957          KOUMRA             oui  71\n\n\nIndice :  if faut une condition sur le statut d’hospitalisation, une sur la sous-préfecture et une sur le PB.\n\n\n\nRésumé des conditions logiques\nNous avons fait le tour des conditions logiques les plus basiques en R. Les voici rassemblées dans un tableau pour références futures :\n\n\n\nCondition\nR\n\n\n\n\nA identique à B ?\nA == B\n\n\nA pas identique à B ?\nA != B\n\n\nA supérieur à B ?\nA &gt; B\n\n\nA supérieur ou égal à B ?\nA &gt;= B\n\n\nA inférieur à B ?\nA &lt; B\n\n\nA inférieur ou égal à B ?\nA &lt;= B"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "href": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Recoder des variables avec case_when()",
    "text": "Recoder des variables avec case_when()\nL’utilité des conditions logiques dans le traitement de données va bien plus loin que la sélection de lignes ! Elles sont par exemple très utiles quand nous voulons recoder des variables. Nous utiliserons les conditions logiques à l’intérieur de la fonction case_when() (également du paquet {dplyr}) pour recoder les variables.\nLa fonction case_when() est un peu plus complexe que ce que l’on a vu jusqu’à présent, mais très puissante (et va donc vous être très utile). Nous allons décomposer sa syntaxe pas à pas.\nVous utiliserez presque toujours case_when() dans un mutate() pour recoder une variable existante ou en créer une nouvelle, avec cette syntaxe :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  mutate(nouvelle_colonne = case_when(\n    [condition_1] ~ [valeur_si_condition_1_est TRUE],\n    [condition_2] ~ [valeur_si_condition_2_est TRUE],\n    .défaut = [valeur_par_défaut]))\n\nDécomposons-la commande.\nA l’exception de la dernière ligne, chaque ligne à l’intérieur de la fonction case_when() a le format suivant :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n[condition] ~ [valeur si condition est VRAIE]  # Les crochets sont là pour la lisibilité\n\nAinsi, pour recoder les patients avec un PB inférieur à 110mm comme \"MAS\", nous écrivons la commande suivante dans notre case_when() :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n# [condition] ~ [valeur si VRAIE]\n   pb &lt; 110   ~ \"MAS\"\n\nIl y a en général plus d’une condition ! Dans notre exemple, une autre condition logique testerait si le patient est modérément malnutri avec l’instruction pb &lt; 125 ~ \"MAM\".\nLa dernière ligne de notre pseudo code contient l’argument .default et sert à fournir la valeur à utiliser lorsqu’aucune des conditions n’est remplie. Dans notre exemple, ça pourrait être \"Normal\".\nPour résumer, pour résumer, pour créer une variable contenant le statut nutritionnel à partir du PB :\n\ndf_brut |&gt;\n  mutate(malnut = case_when(\n    pb &lt; 110 ~ \"MAS\",\n    pb &lt; 125 ~ \"MAM\",\n    .default = \"Normal\"))\n\n\nExécutez le code ci-dessus pour créer une variable malnut contenant le statut nutritionnel des patients. Le haut des deux colonnes concernées renvoie :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAS\n6 220 Normal\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nL’ordre des conditions logiques est important ! case_when() teste les conditions dans l’ordre que vous lui donnez et attribue une valeur dès qu’une condition est TRUE.\nAinsi, dans l’exemple ci-dessus, case_when() pose ces questions suivantes dans l’ordre :\n\nEst-ce que pb &lt; 110 pour ce patient ? Si oui, attribuer la valeur \"MAS\"\nSi le patient n’est pas MAS, est-ce que pb &lt; 125 ? Si oui, attribuer la valeur \"MAM\"\nSi aucune des conditions précédentes n’est vraie, attribuer la valeur \"Normal\"\n\n\n\n\nIntervertissez l’ordre des deux premières conditions dans le case_when()précédent (pb &lt; 125 testé en premier). Le haut des deux colonnes concernées est maintenant :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAM\n6 220 Normal\n\n\nVous pouvez enregistrer le data frame crée dans un objet temporaire temp pour l’inspecter plus facilement. Où sont les patients MAS ? Comprenez-vous ce qui s’est passé ?\n\n\n\n\n\n\n\nNote\n\n\n\nL’argument .default dans case_when() n’est pas obligatoire. Si vous ne l’incluez pas, case_when() utilisera la valeur NA par défaut.\n\n\nDans notre exemple, nous avons utilisé case_when() pour créer une variable catégorique (le statut nutritionnel) à partir d’une variable continue (le PB). Un autre exemple typique et similaire est de créer une colonne contenant les classes d’âge.\n\nUtilisez case_when() pour créer une variable groupe_age avec les catégories suivantes :\n\n\"&lt; 5 Ans\"\n\"5 - 15 Ans\"\n\"&gt; 15 Ans\".\nsi l’âge est manquant, attribuer la valeur \"Inconnu\".\n\nFaites attention à l’ordre ! L’en-tête des colonnes concernées doit ressembler à ceci :\n\n\n   age  age_group\n1   36    &lt; 5 Ans\n2    5    &lt; 5 Ans\n3  156 5 - 15 Ans\n4    8    &lt; 5 Ans\n5    7    &lt; 5 Ans\n6    4    &lt; 5 Ans\n7    2    &lt; 5 Ans\n8   48    &lt; 5 Ans\n9  156 5 - 15 Ans\n10 348   &gt; 15 Ans\n\n\n\n\nL’opérateur %in%\nNous savons maintenant recoder les variables en catégories, ce qui vous arrivera très souvent en épidémiologie. Un autre cas d’usage majeur est d’utiliser case_when() pour standardiser les valeurs d’une variable.\n\nUtilisez count() pour inspecter les variables catégorielles de votre jeu de données. Lesquelles devraient être standardisées ?\n\nVous avez dû voir que la variable sexe présente quelques problèmes d’encodage. Par exemple, les patientes sont codées comme f, female et femme. Utilisons case_when() pour recoder cette variable. Ici, nous ne créerons pas une nouvelle variable, mais remplacerons la variable existante :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(sexe == \"f\"      ~ \"Femme\",\n                          sexe == \"female\" ~ \"Femme\",\n                          sexe == \"femme\"  ~ \"Femme\",\n                          sexe == \"h\"      ~ \"Homme\",\n                          sexe == \"male\"   ~ \"Homme\",\n                          sexe == \"homme\"  ~ \"Homme\",\n                          .default = \"Inconnu\"))\n\nCe code fonctionne correctement mais est terriblement répétitif et verbeux. Heureusement il y a un raccourci pour lister toutes les options à réaffecter à “Femme” (et celles à “Homme”), l’opérateur %in% ! L’opérateur %in% permet de tester la condition “est ce que la valeur existe dans ce vecteur ?”.\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n[valeur] %in% [vector_des_options]\n\nAinsi, par exemple, nous pourrions vérifier si la valeur “f” est dans les options “f” et “femme” :\n\n\"f\" %in% c(\"f\", \"femme\")\n\n\nExécutez l’instruction ci-dessus. Quel est le type de données de votre résultat ?\n\nLa commande renvoie un bolléen, c’est-à-dire un résultat logique. C’est donc une condition logique valide à utiliser dans un case_when() (ou un filter()) ! On peut donc simplifier notre code :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(\n    sexe %in% c(\"f\", \"female\", \"femme\") ~ \"Femme\",\n    sexe %in% c(\"h\", \"male\", \"homme\") ~ \"Homme\",\n    .default = \"Inconnu\"))\n\nC’est plus court comme ça…\n\nUtilisez case_when() et l’opérateur %in% pour créer une nouvelle colonne vacc_status_strict qui a la valeur :\n\n\"Oui\" si le statut vaccinal est confirmé\n\"Non\" pour les cas non vaccinés\n\n\"Non vérifié\" sinon.\n\nLa tête de la nouvelle colonne ressemble à ceci :\n\n\n  statut_vaccinal statut_vaccinal_strict\n1            &lt;NA&gt;            Non vérifié\n2             Non                    Non\n3      Oui - oral            Non vérifié\n4             Non                    Non\n5             Non                    Non\n6             Non                    Non"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-données",
    "href": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-données",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Pipeline de nettoyage des données",
    "text": "Pipeline de nettoyage des données\nMaintenant que vous savez utiliser les conditions logiques pour recoder colonnes avec case_when(), nous pouvons reprendre le pipeline de nettoyage que nous avions commencé dans la session précédente.\n\nReprenez, le code de la session précédente, amendez-le et complétez le pour créer un gros pipeline de nettoyage des données, qui crée un data frame df_linelist en effectuant les opérations suivantes :\n\nSupprimer les variables nom_complet et unite_age\nRenommer les variables suivantes :\n\nage devient age_ans\nsous_prefecture devient prefecture\nvillage_commune devient village\nnom_structure_sante devient structure\n\nAjouter une variable age_ans avec l’âge du patient en années\nMettre à jour region et prefecture pour utiliser la casse de titre\nMettre à jour toutes les colonnes contenant des dates pour utiliser le type Date\nCréer une nouvelle variable groupe_age avec les groupes &lt; 6 mois, 6 - 11 mois, 12 - 59 mois, 5 - 15 ans et &gt; 15 ans (les patients dont l’âge est inconnu sont Inconnu)\nRecoder le sexe pour n’avoir que les valeurs : Femme, Homme et Inconnu\n\nSupprimer toutes les lignes en double\n\nLe début de vos données finales devrait ressembler à ceci :\n\n\n  id  sexe age_mois  region prefecture        village date_debut\n1  1 Femme       36 Mandoul   Moissala Sangana Koïtan 2022-08-13\n2  2 Femme        5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3 Femme      156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 Homme        8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7 Homme        7 Mandoul   Moissala      Tétindaya 2022-08-30\n6 10 Homme        4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             oui     2022-08-14\n2        2022-08-25             oui     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25             non           &lt;NA&gt;\n5        2022-09-02             non           &lt;NA&gt;\n6        2022-09-02             oui     2022-09-02\n                        structure tdr_paludisme fievre eruption toux\n1 Hôpital du District de Moissala       negatif     No     &lt;NA&gt;  Yes\n2 Hôpital du District de Moissala       negatif     No       No  Yes\n3                      CS Silambi       negatif    Yes     &lt;NA&gt;   No\n4 Hôpital du District de Moissala       negatif     No       No   No\n5                      CS Silambi       negatif   &lt;NA&gt;       No  Yes\n6                    Moissala Est       negatif    Yes       No   No\n  yeux_rouges pneumonie encephalite  pb statut_vaccinal doses_vaccin issue\n1          No        No          No 244            &lt;NA&gt;         &lt;NA&gt; gueri\n2          No      &lt;NA&gt;          No 232             Non         &lt;NA&gt;  &lt;NA&gt;\n3          No        No        &lt;NA&gt; 123      Oui - oral         &lt;NA&gt; gueri\n4        &lt;NA&gt;        No          No 210             Non         &lt;NA&gt; gueri\n5         Yes        No          No  80             Non         &lt;NA&gt; gueri\n6        &lt;NA&gt;        No          No 220             Non         &lt;NA&gt; gueri\n  date_issue    age_ans   groupe_age\n1 2022-08-18  3.0000000 12 - 59 mois\n2 2022-08-28  0.4166667     &lt; 6 mois\n3       &lt;NA&gt; 13.0000000   5 - 15 ans\n4       &lt;NA&gt;  0.6666667  6 - 11 mois\n5       &lt;NA&gt;  0.5833333  6 - 11 mois\n6 2022-09-03  0.3333333     &lt; 6 mois\n\n\n\nTop ! Nous pouvons maintenant exporter ce data frame (presque) propre hors de R. Pour cela nous utiliserons la fonction export() de {rio} (et notre fidèle compagnon, la fonction here() de {here} pour gérer les chemins d’accès) :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.xlsx'))\n\nNotez ici que nous plaçons nos données dans le sous-dossier clean dans data.\n\n\n\n\n\n\nAstuce\n\n\n\nEnregistrer les données au format .xlsx est utile pour pouvoir les ouvrir dans Excel pour les inspecter ou les partager. Cependant, nous préférerons souvent utiliser un fichier avec l’extension .rds. Ce type de fichier est spécifique à R et est plus robuste aux problèmes liés à l’encodage ou au formatage des dates que les fichiers de type .xlsx ou .csv.\nPour exporter votre data frame vers un fichier .rds, il suffit de modifier l’extension :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.rds')) # TADAM !"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "href": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "title": "Traitement de données, recoder et filtrer",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo. Lors des deux dernières sessions vous avez appris à utiliser les fonctions qui forment le socle du traitement de données, mais aussi les conditions logiques et comment organiser votre code en un pipeline de nettoyage !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "href": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires"
  },
  {
    "objectID": "about.html#salut",
    "href": "about.html#salut",
    "title": "À Propos",
    "section": "Salut",
    "text": "Salut\nBienvenue sur {repicentre}, un site open source développé par Epicentre pour vous aider à apprendre R pour les contextes humanitaires. Le site est composé de tutoriels autodidactes et propose deux options principales d’apprentissage :\n\nLinéaire. Conçu pour les personnes n’ayant aucune expérience préalable de R, le cours linéaire vous guidera à travers les concepts de base de R en utilisant une étude de cas sur la rougeole au Tchad. Le cours couvre les concepts suivants :\n\nStructures de données et l’interface RStudio\nImportation de données\nManipulation de données\nNettoyage des données\nAgrégation de données\nVisualisation des données\n\nExploration. Si vous avez un peu plus d’expérience ou si vous recherchez un sujet particulier, n’hésitez pas à explorer la gamme complète des tutoriels. Les tutoriels sont classés par catégories et sont conçus pour être autonomes."
  },
  {
    "objectID": "about.html#recommandations-et-demandes",
    "href": "about.html#recommandations-et-demandes",
    "title": "À Propos",
    "section": "Recommandations et demandes",
    "text": "Recommandations et demandes\nY a-t-il un sujet sur lequel vous aimeriez voir un tutoriel qui n’est pas encore disponible ? C’est très bien ! N’hésitez pas à nous le faire savoir en ouvrant un “issue” sur le repo GitHub associé à ce site web. Si vous ne savez pas comment ouvrir un issue, veuillez contacter Cat Eisenhauer."
  },
  {
    "objectID": "about.html#contribuer",
    "href": "about.html#contribuer",
    "title": "À Propos",
    "section": "Contribuer",
    "text": "Contribuer\nVous souhaitez contribuer à la rédaction ou à la maintenance de tutoriels ? Incroyable ! Veuillez contacter Cat."
  },
  {
    "objectID": "pathway.html",
    "href": "pathway.html",
    "title": "Cours",
    "section": "",
    "text": "Ces sessions peuvent être suivies afin d’obtenir un niveau de base dans R. La série suppose aucune expérience préalable dans R et convient bien aux débutants.\nVous en voulez plus ? Vous voulez plus de flexibilité ? Consultez le catalogue complet des sessions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportation des données\n\n\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et importez des données pour travailler dans R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, les bases\n\n\n\n\n\nUne introduction à la manipulation et au nettoyage des données à l’aide du paquet {dplyr}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, recoder et filtrer\n\n\n\n\n\nApprenez à recoder vos variables avec {dplyr} et comment sélectionner les lignes d’un data frame suivant certains critères\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTableaux récapitulatifs\n\n\n\n\n\nCréer des tableaux récapitulatifs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to data visualization with ggplot2\n\n\n\n\n\nApprenez les bases de la visualisation avec ggplot2, et créez votre première épicurve\n\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "sessions_extra/faceting.html",
    "href": "sessions_extra/faceting.html",
    "title": "Graphiques multiples (facetting)",
    "section": "",
    "text": "Dans cette session, le but est d’apprendre à :\n\ncréer des graphiques multiples très rapidement avec {ggplot2}\nmodifier les paramètres les plus courants pour améliorer l’apparence de ces graphiques"
  },
  {
    "objectID": "sessions_extra/faceting.html#objectifs",
    "href": "sessions_extra/faceting.html#objectifs",
    "title": "Graphiques multiples (facetting)",
    "section": "",
    "text": "Dans cette session, le but est d’apprendre à :\n\ncréer des graphiques multiples très rapidement avec {ggplot2}\nmodifier les paramètres les plus courants pour améliorer l’apparence de ces graphiques"
  },
  {
    "objectID": "sessions_extra/faceting.html#introduction",
    "href": "sessions_extra/faceting.html#introduction",
    "title": "Graphiques multiples (facetting)",
    "section": "Introduction",
    "text": "Introduction\nPrérequis : ce satellite s’appuie sur la session sur les courbes épidémiques, durant laquelle nous avons appris à visualiser la distribution quotidienne des cas de rougeoles au cours du temps à l’aide de {ggplot2} :\n\n\n\n\n\n\n\n\n\nCe graphique est très utile, mais ce qui serait encore plus utile serait de pouvoir le décliner rapidement selon les modalités d’une autre variable. Par exemple, nous pourrions vouloir insérer un graphique similaire mais par groupe d’âge dans un rapport de situation [sitrep en anglais]. Il y a plusieurs manières d’arriver à ce résultat. Vous pourriez :\n\nfiltrer un jeu de données pour chacune des classes d’âge, copier-coller le code du graphe et l’adapter pour créer un graphique par classe d’âge\napprendre à utiliser les boucles for ou les fonctions des familles apply() ou map() qui servent répéter des actions sans copier-coller\nfaire confiance à {ggplot2} pour avoir une solution rapide…\n\nLa première option est fastidieuse et source d’erreurs, et nous la déconseillons. La seconde option n’est pas mauvaise en soi : les outils mentionnés sont extrêmement puissants et de bonnes cibles d’apprentissage pour quand vous serez plus à l’aise avec le langage. Mais ils sont trop avancés pour ce petit tutoriel, et une options simple existe déjà dans {ggplot2}."
  },
  {
    "objectID": "sessions_extra/faceting.html#mise-en-place",
    "href": "sessions_extra/faceting.html#mise-en-place",
    "title": "Graphiques multiples (facetting)",
    "section": "Mise en place",
    "text": "Mise en place\n\nNous utiliserons la même liste linéaire nettoyée que précédemment et qui peut être téléchargée ici :\n\n\n\n Télécharger les données\n\n\n\n Si ce n’est pas déjà fait, enregistrez le jeu de données dans data/clean puis créez un nouveau script appelé faceting.R dans votre sous-dossier R (alternativement, vous pouvez rajouter une section au script sur les courbes épis).\n Si vous créez un nouveau script, ajoutez un en-tête approprié et chargez les paquets suivants : {here}, {rio} et {tidyverse}. Importez ensuite les données propres dans R et enregistrez-les dans un objet df_linelist."
  },
  {
    "objectID": "sessions_extra/faceting.html#un-graphe-par-modalité-faceting",
    "href": "sessions_extra/faceting.html#un-graphe-par-modalité-faceting",
    "title": "Graphiques multiples (facetting)",
    "section": "Un graphe par modalité (faceting)",
    "text": "Un graphe par modalité (faceting)\nDans ggplot, “faceting” est est l’action de créer des graphiques en plusieurs parties. La fonction facet_wrap() trace automatiquement un graphique pour chacune des modalités d’une variable. Par exemple, vous pouvez créer une courbe épi par sexe, ou par site. Comme les autres couches d’un ggplot, on l’ajoute à un graphique avec un +. Cela crée une figure avec plusieurs petits graphiques, les fameuses facettes.\n\nPréparer les données\nDans cette leçon, nous expliquerons le code en traçant la courbe par sous-préfecture, et vous tracerez la courbe par groupe d’âge.\nSi l’on veut tracer la courbe épidémique par sous-préfecture, il faut que cette variable soit dans le data frame que nous passons à ggplot(). Nous allons donc créer un nouveau jeu de données agrégées qui contient le nombre de patients par jour et par sous-préfecture.\n\ndf_pref &lt;- df_linelist %&gt;%\n  count(date_debut, sous_prefecture,\n        name = 'patients')\n\nhead(df_pref)\n\n# A tibble: 6 × 3\n  date_debut sous_prefecture patients\n  &lt;date&gt;     &lt;chr&gt;              &lt;int&gt;\n1 2022-08-13 Moissala               1\n2 2022-08-17 Moissala               1\n3 2022-08-18 Moissala               1\n4 2022-08-22 Moissala               1\n5 2022-08-30 Moissala               2\n6 2022-09-01 Moissala               1\n\n\n\nVous devez tracer le nombre de patients par groupe d’âge, donc il vous faut un data frame agrégé par jour et groupe d’âge. Créez-le et enregistrez-le comme df_age. Il a le format suivant :\n\n\n# A tibble: 6 × 3\n  date_debut age_groupe     n\n  &lt;date&gt;     &lt;fct&gt;      &lt;int&gt;\n1 2022-08-13 1 - 4 ans      1\n2 2022-08-17 5 - 14 ans     1\n3 2022-08-18 &lt; 6 mois       1\n4 2022-08-22 6 - 8 mois     1\n5 2022-08-30 &lt; 6 mois       1\n6 2022-08-30 6 - 8 mois     1\n\n\n\n\n\nTracer le graphique\nMaintenant que les données sont prêtes, il ne nous reste plus qu’à tracer le graphique. Examinez le code ci-dessous, il est presque identique à ce que nous avons fait précédemment, à part la dernière ligue qui crée les facettes :\n\ndf_pref %&gt;%\n  ggplot(aes(x = date_debut,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date d'apparition des symptomes\",\n       y = \"Cas de rougeole\",\n       title = \"Measles cases in Mandoul (Chad)\") +\n  theme_classic(base_size = 15) +\n  facet_wrap(vars(sous_prefecture))   # Graphique par sous-pref !\n\n\n\n\n\n\n\n\nJ’espère que vous êtes soufflés ! D’un point de vue syntaxe, la fonction facer_wrap() prend en argument le nom de la variable catégorique qui nous intéresse, enrobé dans la fonction vars().\n\nA votre tour. Tracez le graphe par classe d’âge. Il devrait ressembler à ça :"
  },
  {
    "objectID": "sessions_extra/faceting.html#modifier-laspect-des-facettes",
    "href": "sessions_extra/faceting.html#modifier-laspect-des-facettes",
    "title": "Graphiques multiples (facetting)",
    "section": "Modifier l’aspect des facettes",
    "text": "Modifier l’aspect des facettes\nOuvrez la page d’aide de la fonction sur le site du paquet pour avoir la liste des arguments acceptés. Nous allons aborder certains d’entre eux à présent.\n\nNombre de lignes ou de colonnes\nLes arguments nrow et ncol vous permettent de décider combien de facettes il doit y avoir sur une ligne, ou sur une colonne.\nSi nous voulions avoir toutes les facettes sur deux lignes :\n\ndf_pref %&gt;%\n  ggplot(aes(x = date_debut,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date d'apparition des symptomes\",\n       y = \"Cas de rougeole\",\n       title = \"Cas de rougeole dans la région de Mandoul (Tchad)\") + \n  theme_classic(base_size = 15) +\n  \n  facet_wrap(vars(sous_prefecture),\n             nrow = 2)  \n\n\n\n\n\n\n\n\nOu au contraire nous pouvons forcer le nombre de lignes à 4 pour avoir une figure tout en hauteur :\n\ndf_pref %&gt;%\n  ggplot(aes(x = date_debut,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date d'apparition des symptomes\",\n       y = \"Cas de rougeole\",\n       title = \"Cas de rougeole dans la région de Mandoul (Tchad)\") + \n  theme_classic(base_size = 15) +\n  \n  facet_wrap(vars(sous_prefecture),\n             nrow = 4)  \n\n\n\n\n\n\n\n\n\nUtilisez un des deux arguments présentés ci-dessus pour créer un graphe avec trois colonnes.\n\n\n\nPlages des axes\nAvez-vous remarqué que les valeurs minimales et maximales en x et en y étaient les mêmes pour toutes les facettes ? C’est que par défaut facet_wrap() fixe les plages pour les deux axes. Ce comportement est raisonnable pour pouvoir comparer les facettes et éviter d’induire le lecteur en erreur.\nCeci étant dit, si vous êtes plus intéressé par la forme de la courbe à l’intérieur de chaque facette que par la comparaison des catégories entre elles, il peut être approprié de zoomer sur les données disponibles en autorisant des axes indépendants (“libres” de varier). Prévenez alors le lecteur que les facettes ne sont pas toutes à la même échelle.\nL’argument scales [échelles] accepte les valeurs suivantes :\n\n\"fixed\" : la valeur par défaut, x et y à la même échelle pour toutes les facettes\n\"free_x\" : l’échelle de x peut varier entre facettes\n\"free_y\" : l’échelle de y peut varier entre facettes\n\"free\" : les deux axes peuvent varier entre facettes\n\nContrastez le graphe précédent avec celui-ci :\n\n\n\n\n\n\n\n\n\nNous avons autorisé à avoir des échelles indépendantes sur toutes les facettes en x et en y, pour zoomer sur les cas dans chaque sous-préfecture.\n\nTracez la courbe par groupe d’âge, avec l’axe des abscisses fixe et l’axe des ordonnées libre."
  },
  {
    "objectID": "sessions_extra/faceting.html#cest-fini",
    "href": "sessions_extra/faceting.html#cest-fini",
    "title": "Graphiques multiples (facetting)",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo, vous avez créé vos premiers graphiques en fonctions d’une variable catégorique. Cela devrait vous être très utile. Sachez que la fonction fonctionne aussi avec d’autres types de graphes créés par {ggplot2}.\nSi le graphique est très large, il est possible que les étiquettes des dates ne soient pas très lisibles en x, et c’est le cas pour certains des exemples. Cela peut être contrôlé, et le sujet est abordé dans un autre satellite !\n\n\n\n Solutions des exercices"
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html",
    "href": "sessions_extra/weekly_epicurves.html",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "",
    "text": "Dans la session principale sur les grapiques, vous avez appris à tracer une courbe épidémique du nombre de cas journaliers :\n\n\n\n\n\n\n\n\n\nIci les données sont agrégées par jour, ce qui raisonnable si l’épidémie est de courte durée ou si vous souhaitez zoomer sur une période spécifique. Il nous arrivera néanmoins de souvent vouloir tracer des courbes hebdomadaires.\nDans cette tutoriel, nous apprendrons à agréger les données par semaine, à tracer le graphique et à améliorer les étiquettes de l’axe des abscisses.\nPrérequis : la session sur les courbes épidémiques."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#objectifs",
    "href": "sessions_extra/weekly_epicurves.html#objectifs",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "",
    "text": "Dans la session principale sur les grapiques, vous avez appris à tracer une courbe épidémique du nombre de cas journaliers :\n\n\n\n\n\n\n\n\n\nIci les données sont agrégées par jour, ce qui raisonnable si l’épidémie est de courte durée ou si vous souhaitez zoomer sur une période spécifique. Il nous arrivera néanmoins de souvent vouloir tracer des courbes hebdomadaires.\nDans cette tutoriel, nous apprendrons à agréger les données par semaine, à tracer le graphique et à améliorer les étiquettes de l’axe des abscisses.\nPrérequis : la session sur les courbes épidémiques."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#mise-en-place",
    "href": "sessions_extra/weekly_epicurves.html#mise-en-place",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "Mise en place",
    "text": "Mise en place\n\nNous utiliserons la même liste linéaire nettoyée que précédemment et qui peut être téléchargée ici :\n\n\n\n Télécharger les données\n\n\n\n Si ce n’est pas déjà fait, enregistrez le jeu de données dans data/clean puis créez un nouveau script appelé courbe_hebdo.R dans votre sous-dossier R (alternativement, vous pouvez rajouter une section au script sur les courbes épidémiques journalières).\n Si vous créez un nouveau script, ajoutez un en-tête approprié et chargez les paquets suivants : {here}, {rio}, {tidyverse} et {scales}. Importez ensuite les données propres (moissala_linelist_clean_FR.rds) dans R et enregistrez-les dans un objet df_linelist.\n\nAu cours du tutoriel, les exemples porteront sur les sorties et vous tracerez la courbe épidémique à partir de la date de début des symptômes."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#données-hebdomadaires",
    "href": "sessions_extra/weekly_epicurves.html#données-hebdomadaires",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "Données hebdomadaires",
    "text": "Données hebdomadaires\nNous allons aborder deux façons d’agréger les données par semaine. Le concept de la première vous sera sans doute familier (semaines identifiées par leur numéros), mais nous nous concentrerons sur une méthode plus robuste (semaine identifiées par la date du premier jour de la semaine).\n\nNuméros de semaine\nLa manière la plus intuitive de d’agréger par semaine est d’utiliser des numéros de semaines, car les données du MSP sont souvent dans ce format. Vous avez sans doute créé de nombreuses courbes épidémiques dans ce format vous-mêmes.\nLa fonction isoweek() du paquet {lubridate} accepte une date (ou un vecteur de dates) et renvoie le numéro de semaine ISO.\n\nexemple_date &lt;- as.Date('2025-02-24')\n\nexemple_date\n\n[1] \"2025-02-24\"\n\nisoweek(exemple_date)\n\n[1] 9\n\n\nNous pouvons utiliser cette fonction pour créer une colonne sem_sortie_num dans nos données :\n\ndf_linelist &lt;- df_linelist |&gt; \n  mutate(sem_sortie_num = isoweek(date_sortie))\n\nLe début des colonnes date_sortie et sem_sortie_num ressemble à ceci (sans les NA) :\n\ndf_linelist |&gt; \n  tidyr::drop_na(date_sortie) |&gt; \n  select(date_sortie, sem_sortie_num) |&gt; \n  head()\n\n# A tibble: 6 × 2\n  date_sortie sem_sortie_num\n  &lt;date&gt;               &lt;dbl&gt;\n1 2022-08-18              33\n2 2022-08-28              34\n3 2022-09-03              35\n4 2022-09-12              37\n5 2022-09-10              36\n6 2022-09-18              37\n\n\n\nA vous de jouer. Utilisez les fonctions mutate() et isoweek() pour créer une nouvelle colonne dans votre data frame appelée sem_symptomes_num qui contient la semaine ISO associée à chaque date de début des symptômes. L’en-tête des colonnes date_debut et sem_symptomes_num devrait ressembler à ceci :\n\n\n# A tibble: 6 × 2\n  date_debut sem_symptomes_num\n  &lt;date&gt;                 &lt;dbl&gt;\n1 2022-08-13                32\n2 2022-08-18                33\n3 2022-08-17                33\n4 2022-08-22                34\n5 2022-08-30                35\n6 2022-08-30                35\n\n\n\nNous pourrions maintenant utiliser count() sur cette colonne pour agréger les données par semaine, puis tracer le graphique avec {ggplot2} avec un code très similaire à la session principale.\nMalheureusement il y a un problème. Avec le numéro de semaine il y a une première semaine en 2022… mais aussi en 2023, 2024 etc. Dans le cas d’une épidémie courte qui n’aurait lieu qu’en 2022, cela ne poserait pas problème. Cependant, notre data frame contient des données de la région entière, et les dates s’étendent de 2022 à 2023. Donc si nous comptions le nombre de patient par numéro de semaine, le tableau suivant serait erroné :\n\n# FAUX\ndf_linelist |&gt; \n  count(sem_symptomes_num) |&gt; \n  head(10)\n\n# A tibble: 10 × 2\n   sem_symptomes_num     n\n               &lt;dbl&gt; &lt;int&gt;\n 1                 1    36\n 2                 2    35\n 3                 3    42\n 4                 4    56\n 5                 5    70\n 6                 6    78\n 7                 7    85\n 8                 8    49\n 9                 9    62\n10                10    81\n\n\nPour résoudre le problème nous pouvons stratifier par année :\n\ndf_linelist |&gt; \n  mutate(annee_symptomes = isoyear(date_debut)) |&gt; \n  count(annee_symptomes, sem_symptomes_num) |&gt; \n  head(10)\n\n# A tibble: 10 × 3\n   annee_symptomes sem_symptomes_num     n\n             &lt;dbl&gt;             &lt;dbl&gt; &lt;int&gt;\n 1            2022                32     1\n 2            2022                33     2\n 3            2022                34     1\n 4            2022                35     8\n 5            2022                36     8\n 6            2022                37    10\n 7            2022                38    17\n 8            2022                39    17\n 9            2022                40    19\n10            2022                41    16\n\n\nCes chiffres sont désormais corrects. Vous pourriez les représenter avec plusieurs mini graphes par année sur une même figure, ou simplement filtrer une année donnée et tracer la courbe avec les numéros de semaines sur l’axe des x. Dans le premier cas, cela donnerait ceci :\n\ndf_linelist |&gt; \n  mutate(annee_symptomes = isoyear(date_debut)) |&gt; \n  count(annee_symptomes, sem_symptomes_num) |&gt; \n  ggplot(aes(x = sem_symptomes_num,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  theme_classic(base_size = 16) +\n  facet_wrap(vars(annee_symptomes),  # Magie pour faire le graphe par année !\n             ncol = 1)\n\n\n\n\n\n\n\n\nSi vous n’avez pas lu le satellite sur facet_wrap(), ce n’est pas grave, voyez ce graphe comme une page de publicité pour la capacité de ggplot à faire des graphes multiples rapidement. Les explications sortent du cadre de ce tutoriel et nous allons vous montrer une autre façon d’agréger les données par semaine, qui est robuste aux données pluriannuelles.\n\n\nPremier jour de la semaine\nUne autre manière d’agréger par semaine est d’utiliser la fonction floor_date() (également du package {lubridate}), qui renvoie la première date d’une période donnée. Vous pouvez la considérer comme une sorte d’arrondi à la plus petite valeur, mais pour les dates.\nLa fonction a un argument unit pour choisir l’échelle de la période (semaine, mois…) et un argument week_start pour définir le premier jour de la semaine (les lundis sont 1).\n\ndf_linelist &lt;- df_linelist |&gt; \n  mutate(\n    sem_sortie_lundi = floor_date(date_sortie,\n                                  unit = \"week\",\n                                  week_start = 1)\n  )\n\nRegardons les différentes colonnes de plus près pour bien comprendre :\n\ndf_linelist |&gt; \n  select(date_sortie, sem_sortie_num, sem_sortie_lundi) |&gt;\n  arrange(date_sortie) |&gt;     # Trie par date\n  head(n = 10)\n\n# A tibble: 10 × 3\n   date_sortie sem_sortie_num sem_sortie_lundi\n   &lt;date&gt;               &lt;dbl&gt; &lt;date&gt;          \n 1 2022-08-18              33 2022-08-15      \n 2 2022-08-28              34 2022-08-22      \n 3 2022-09-03              35 2022-08-29      \n 4 2022-09-10              36 2022-09-05      \n 5 2022-09-12              37 2022-09-12      \n 6 2022-09-12              37 2022-09-12      \n 7 2022-09-16              37 2022-09-12      \n 8 2022-09-17              37 2022-09-12      \n 9 2022-09-18              37 2022-09-12      \n10 2022-09-19              38 2022-09-19      \n\n\nPour aider à comprendre on peut calculer le jour de la semaine associé à chaque date en utilisant la fonction wday() (qui appartient aussi à {lubridate}, y a comme un thème 😉) [wday est une abréviation pour week day] :\n\ndf_linelist |&gt; \n  # Calcule le premier jour de la semaine\n  mutate(\n    jour_sortie = wday(date_sortie, \n                       label = TRUE, \n                       abbr = FALSE),\n    cest_bien_un_lundi  = wday(sem_sortie_lundi, \n                               label = TRUE, \n                               abbr = FALSE)) |&gt; \n  arrange(date_sortie) |&gt;      # Trie par date\n  select(date_sortie,\n         jour_sortie,\n         sem_sortie_num,\n         sem_sortie_lundi,\n         cest_bien_un_lundi) |&gt; \n  head(n = 10)\n\n# A tibble: 10 × 5\n   date_sortie jour_sortie sem_sortie_num sem_sortie_lundi cest_bien_un_lundi\n   &lt;date&gt;      &lt;ord&gt;                &lt;dbl&gt; &lt;date&gt;           &lt;ord&gt;             \n 1 2022-08-18  Thursday                33 2022-08-15       Monday            \n 2 2022-08-28  Sunday                  34 2022-08-22       Monday            \n 3 2022-09-03  Saturday                35 2022-08-29       Monday            \n 4 2022-09-10  Saturday                36 2022-09-05       Monday            \n 5 2022-09-12  Monday                  37 2022-09-12       Monday            \n 6 2022-09-12  Monday                  37 2022-09-12       Monday            \n 7 2022-09-16  Friday                  37 2022-09-12       Monday            \n 8 2022-09-17  Saturday                37 2022-09-12       Monday            \n 9 2022-09-18  Sunday                  37 2022-09-12       Monday            \n10 2022-09-19  Monday                  38 2022-09-19       Monday            \n\n\nCeci illustre comment sem_sortie_num et sem_sortie_lundi sont deux façons de représenter une semaine donnée. Mais si les numéros de semaine ne sont pas uniques, les dates, elles, le sont !\n\nAjoutez une nouvelle instruction à votre mutate() pour créer la variable sem_symptomes_lundi qui contient le premier jour de la semaine pour la date d’apparition des symptômes. Le premier jour de la semaine est un lundi au Tchad.\n\n\n\n\n\n\n\nAstuce\n\n\n\nLisez la page d’aide de floor_date() pour connaître la liste des unités possibles.\n\n\n\n\nAgréger\nMaintenant que nous avons une variables qui identifie la semaine, nous pouvons enfin agréger nos données !\n\nComptez le nombre de patients par semaine de début des symptômes, en utilisant le début de la semaine pour identifier les semaines (sem_symptomes_lundi).\nVoici les dix premières lignes de ce à quoi il devrait ressembler :\n\n\n# A tibble: 10 × 2\n   sem_symptomes_lundi     n\n   &lt;date&gt;              &lt;int&gt;\n 1 2022-08-08              1\n 2 2022-08-15              2\n 3 2022-08-22              1\n 4 2022-08-29              8\n 5 2022-09-05              8\n 6 2022-09-12             10\n 7 2022-09-19             17\n 8 2022-09-26             17\n 9 2022-10-03             19\n10 2022-10-10             16"
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#tracer-le-graphique",
    "href": "sessions_extra/weekly_epicurves.html#tracer-le-graphique",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "Tracer le graphique",
    "text": "Tracer le graphique\nParfait. Nous pouvons maintenant passer nos données agrégées à la commande pour créer le graphique, en faisant quelques ajustements pour que le code précédent fonctionne.\n\nCréez un ggplot avec le même aspect que la courbé épidémique de la session principale, mais avec le premier jour de la semaine sur l’axe des abscisses. N’oubliez pas de mettre à jour les noms des axes !\nIl devrait ressembler à ceci :\n\n\n\n\n\n\n\n\n\n\nNotez que même si les étiquettes sur l’axe des abscisses sont des dates, une barre représente les données d’une semaine (sept jours à compter du lundi)."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#améliorer-laxe",
    "href": "sessions_extra/weekly_epicurves.html#améliorer-laxe",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "Améliorer l’axe",
    "text": "Améliorer l’axe\nIl est maintenant temps d’améliorer cet axe des abscisses.\n{ggplot2} crée automatiquement des étiquettes pour l’axe des x, en essayant de s’adapter à l’étendue des données. Ces valeurs par défaut ne nous conviennent pas toujours, et nous voulons pouvoir manuellement changer les étiquettes (plus fréquentes ou plus espacées, améliorer le format etc.).\nPour modifier l’apparence de l’axe, nous allons utiliser une fonction de la famille scale de {ggplot2} : scale_x_date() [scale ici est l’échelle].\n\nModifier la fréquence des tirets\nDans {ggplot2}, les breaks [cassures] contrôlent la fréquence des tirets sur l’axe.\nLa fonction scale_x_date() a un argument date_breaks qui accepte l’intervalle entre deux étiquettes dans une chaîne de caractères aux formats suivants : \"1 week\", \"2 weeks\", \"4 months\", \"2 years\", etc.\n\ndf_linelist |&gt; \n  count(sem_sortie_lundi) |&gt; \n  ggplot(aes(x = sem_sortie_lundi,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date de sortie\",\n       y = \"Patients\",\n       title = \"Sorties rougeole dans la région de Mandoul (Tchad)\") +\n  scale_x_date(date_breaks = \"4 months\") +  # Définit l'intervalle entre étiquettes\n  theme_classic(base_size = 16)\n\nWarning: Removed 1 rows containing missing values (`position_stack()`).\n\n\n\n\n\n\n\n\n\n\nModifiez votre code pour que la fréquence des tirets les rendent lisibles sur votre moniteur.\n\n\n\nAméliorer les étiquettes\nMaintenant que nous avons géré l’intervalle entre les tirets, nous pouvons modifier les étiquettes elles-mêmes (la façon dont les dates sont affichées sur l’axe, labels en anglais). Par défaut, elles sont sous la forme année-mois-jour. Nous allons voir deux manières de changer ça\n\nAvec le paquet {scales}Avec la syntaxe strptime\n\n\nLa fonction scale_x_date() a un argument label qui accepte plusieurs types d’entrées, telles qu’un vecteur contenant les dates ou une fonction qui génère des labels. Le paquet {scales} fournit une telle fonction, label_date_short(), qui tente de créer des étiquettes de dates efficaces et courtes.\n\ndf_linelist |&gt; \n  count(sem_sortie_lundi) |&gt; \n  ggplot(aes(x = sem_sortie_lundi,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date de sortie\",\n       y = \"Patients\",\n       title = \"Sorties rougeole dans la région de Mandoul (Tchad)\") +\n  scale_x_date(date_breaks = \"2 months\",\n               labels = scales::label_date_short()) + # Etiquettes courtes\n  theme_classic(base_size = 15)\n\nWarning: Removed 1 rows containing missing values (`position_stack()`).\n\n\n\n\n\n\n\n\n\n\nModifiez votre code et usez label_date_short() pour créer des étiquettes courtes.\n\n\n\nL’automatisation c’est sympa, mais si vous préférez avoir le contrôle total, R dispose d’une syntaxe pour décrire les formats de date et d’heure. Il existe une longue page d’aide (accessibles avec la commande help(strptime)) avec tous les éléments de syntaxe, mais voici un résumé des éléments les plus utiles pour décrire le format d’une date :\nNuméro du jour :\n\n%d: de 01 à 31\n%e: de 1 à 31\n\nMois :\n\n%b : nom du mois, forme abréviée (la langue dépend de la locale de votre ordinateur)\n%B : nom du mois, complet (la langue dépend de la locale de votre ordinateur)\n%m : Numéro du mois\n\nAnnée :\n\n%y : année à deux chiffres (sans le siècle)\n%Y : année à quatre chiffres\n\nSéparateurs spéciaux :\n\n%n : nouvelle ligne\n%t : tab\n\nVous pouvez assembler ces éléments dans une chaîne de caractères, que vous passez à différentes fonctions qui acceptent un format comme argument.\nNous allons d’abord utiliser la fonction format() pour voir rapidement l’affichage qu’elle crée à partir d’une syntaxe strptime, puis nous illustrerons l’usage dans un graphe.\n\n# Crée un vecteur de dates pour explorer des formats différents\nquelques_dates &lt;- as.Date(c(\"2024-10-06\", \"2024-12-15\", \"2025-01-20\"))\n\n# Exemples de syntaxes possibles\nformat(quelques_dates, \"%Y-%b-%d\")\n\n[1] \"2024-Oct-06\" \"2024-Dec-15\" \"2025-Jan-20\"\n\nformat(quelques_dates, \"%Y-%b\")\n\n[1] \"2024-Oct\" \"2024-Dec\" \"2025-Jan\"\n\nformat(quelques_dates, \"%Y %B %d\")\n\n[1] \"2024 October 06\"  \"2024 December 15\" \"2025 January 20\" \n\nformat(quelques_dates, \"%y/%m/%d\")\n\n[1] \"24/10/06\" \"24/12/15\" \"25/01/20\"\n\nformat(quelques_dates, \"%d/%m/%Y\")\n\n[1] \"06/10/2024\" \"15/12/2024\" \"20/01/2025\"\n\n\nRevenons à notre graphe. La fonction scale_x_date() a un argument date_labels qui accepte une chaîne de caractère dans le format strptime pour formater les étiquettes de dates.\n\ndf_linelist |&gt; \n  count(sem_sortie_lundi) |&gt; \n  ggplot(aes(x = sem_sortie_lundi,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date de sortie\",\n       y = \"Patients\",\n       title = \"Sorties rougeole dans la région de Mandoul (Tchad)\") +\n  scale_x_date(\n    date_breaks = \"2 months\",      # Définit l'intervalle entre étiquettes\n    date_labels = \"%Y%n%b%n%d\") +  # Definit le format des étiquettes\n  theme_classic(base_size = 16)\n\nWarning: Removed 1 rows containing missing values (`position_stack()`).\n\n\n\n\n\n\n\n\n\n\nModifiez votre graphe pour que les étiquettes soient comme ceci :\n\n\n\n\n\n\n\n\n\n\n\nC’est fini !\nBravo ! Les dates dans R sont un sujet compliqué, et leur format est souvent un peu effrayant. Nous espérons que cette petite introduction vous aura donné quelques astuces pour que vos courbes épidémiques soient lisibles.\n\n\n\n Solutions\n\n\n\n\n\nAller plus loin\n\nExercices supplémentaires\n\nUtilisez ce format dans cotre graphe : “2024-oct.”, “2024-dec.”\nCréez une courbe épidémique avec la date de consultation, avec le premier jour de la semaine sur l’axe des x (vous êtes libres du format de la date).\nCréez une courbe épidémique pour l’année 2023 qui montre le nombre d’admissions hospitalières hebdomadaires, avec le numéro ISO de la semaine en abscisse.\n\n\n\nDéfi\n\nTracez une courbe épidémique de la date d’apparition des symptômes par mois. Utilisez un format d’étiquette qui vous semble approprié et lisible.\n\n\n\n\nRessources\n\nLe chapitre (en anglais) “Elegant graphics for data analyses’ book on date scales\nLa page d’aide de lubridate"
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#cest-fini",
    "href": "sessions_extra/weekly_epicurves.html#cest-fini",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo ! Les dates dans R sont un sujet compliqué, et leur format est souvent un peu effrayant. Nous espérons que cette petite introduction vous aura donné quelques astuces pour que vos courbes épidémiques soient lisibles.\n\n\n\n Solutions"
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#aller-plus-loin",
    "href": "sessions_extra/weekly_epicurves.html#aller-plus-loin",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires\n\nUtilisez ce format dans cotre graphe : “2024-oct.”, “2024-dec.”\nCréez une courbe épidémique avec la date de consultation, avec le premier jour de la semaine sur l’axe des x (vous êtes libres du format de la date).\nCréez une courbe épidémique pour l’année 2023 qui montre le nombre d’admissions hospitalières hebdomadaires, avec le numéro ISO de la semaine en abscisse.\n\n\n\nDéfi\n\nTracez une courbe épidémique de la date d’apparition des symptômes par mois. Utilisez un format d’étiquette qui vous semble approprié et lisible."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#ressources",
    "href": "sessions_extra/weekly_epicurves.html#ressources",
    "title": "Courbes épidémiques hebdomadaires",
    "section": "Ressources",
    "text": "Ressources\n\nLe chapitre (en anglais) “Elegant graphics for data analyses’ book on date scales\nLa page d’aide de lubridate"
  }
]