[
  {
    "objectID": "sessions_core/02_import_data.html",
    "href": "sessions_core/02_import_data.html",
    "title": "Importer des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets\nÉcrire des chemins d’accès robustes pour les fichiers\nImporter et inspecter des données\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes que vous avez appris dans l’ Introduction à R s’appliquent également ici : nous devons faire de notre mieux pour nous assurer que nos projets ne fonctionneront pas seulement aujourd’hui, mais qu’ils pourront également être réutilisés et partagés à l’avenir. Bien que cela ne soit pas toujours facile, il existe plusieurs bonnes pratiques qui peuvent nous aider, et l’une des plus importantes est de commencer avec une bonne base de code organisée."
  },
  {
    "objectID": "sessions_core/02_import_data.html#objectifs",
    "href": "sessions_core/02_import_data.html#objectifs",
    "title": "Importer des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets\nÉcrire des chemins d’accès robustes pour les fichiers\nImporter et inspecter des données\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes que vous avez appris dans l’ Introduction à R s’appliquent également ici : nous devons faire de notre mieux pour nous assurer que nos projets ne fonctionneront pas seulement aujourd’hui, mais qu’ils pourront également être réutilisés et partagés à l’avenir. Bien que cela ne soit pas toujours facile, il existe plusieurs bonnes pratiques qui peuvent nous aider, et l’une des plus importantes est de commencer avec une bonne base de code organisée."
  },
  {
    "objectID": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "href": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "title": "Importer des données",
    "section": "Mise en place du projet",
    "text": "Mise en place du projet\n\nStructure des dossiers\n\nSi ce n’est pas déjà fait, téléchargez le dossier du cours, sauvegardez-le à un endroit [non connecté à OneDrive]{.hovertip bs-toggle=‘tooltip’ bs-title=“OneDrive ne fonctionne pas bien avec R car il va constamment synchroniser certains dossiers de projets, ce qui peut entraîner des erreurs ou des problèmes de mémoire”}. Décompressez l’archive et ouvrez le dossier non compressé.\n\nCe dossier donne un exemple de structure typique (et fortement recommandée) pour vos projets de code :\n\ndonnées\npropres\nbrut\nR\nrésultats\nLISEZ-MOI\n\nCe dossier sera votre répertoire de travail pour toutes les sessions de ce cours. Vous y créerez un projet Rstudio (explications ci-dessous), et y enregistrerez tous vos scripts. /R. Les données du cours se trouvent déjà dans data/raw.\n\n\nDéfinitions\nPour travailler dans le cadre de cette session, vous devez comprendre les deux concepts suivants :\nRépertoire de travail. Le répertoire de travail est l’emplacement (dossier) où se trouve votre session R en cours. Si vous enregistrez un fichier, par exemple, il sera enregistré dans ce dossier par défaut. De même, lorsque vous souhaitez ouvrir un fichier, ce dossier sera affiché par défaut. Tous les chemins relatifs seront relatifs à ce répertoire de travail. Par défaut, R choisit généralement le dossier “Documents” comme répertoire de travail sur les machines Windows.\nRacine. La racine fait référence au niveau de dossier le plus élevé du répertoire de travail. Si le dossier de votre cours s’appelle FETCHR la racine se trouverait directement à l’intérieur de celui-ci (et non dans l’un de ses sous-dossiers comme R ou Data).\n\n\nProjets RStudio\nUn projet RStudio peut être utilisé pour vous faciliter la vie et vous aider à orienter [RStudio autour des différents fichiers utilisés dans votre code.]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Techniquement, un projet RStudio n’est qu’un fichier contenant des métadonnées qui indiquent à RStudio quels fichiers ouvrir et où placer votre répertoire de travail. Cela vous évitera d’avoir à gérer vous-même votre répertoire de travail’}\nPour rappel, votre interface doit ressembler à ceci :\n\n\n\n\n\n\nFigure 1: Capture d’écran d’une interface Rstudio typique\n\n\n\n\nOuvrez RStudio et créez un nouveau projet en cliquant sur File &gt; New Project &gt; Existing Directory &gt; Browse, en naviguant dans le dossier du cours (en l’ouvrant) et en cliquant sur Create Project.\n\n\nDans l’explorateur Windows, regardez le dossier du cours. Vous devriez maintenant voir un nouveau fichier avec l’extension .Rproj qui a une petite icône bleue avec un R.\n\n\n\n\nIcône associée aux projets RStudio\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi vous ne voyez pas ce fichier, c’est probablement parce qu’il est caché par défaut sur votre ordinateur. Pour modifier ce paramètre dans l’explorateur Windows, allez dans le menu Afficher et sélectionnez Filename Extensions.\n\n\nLorsque vous ouvrez un projet RStudio, RStudio démarre une nouvelle session R, ouvre les fichiers de projet associés et définit votre répertoire de travail à la racine du dossier du cours. À ce moment-là, RStudio affiche également les sous-dossiers de ce répertoire dans le panneau en bas à droite.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est fortement recommandé de mettre en place un projet RStudio distinct pour chacune de vos analyses afin de garantir que les fichiers de votre projet restent organisés et gérables.\n\n\nIl existe plusieurs façons d’ouvrir un projet RStudio :\n\nUtilisez le menu RStudio File &gt; Open Project puis sélectionnez le projet que vous souhaitez ouvrir .Rproj\nCliquez sur [le bouton Project: (none)]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Vous pouvez cliquer sur ce bouton à tout moment pour savoir dans quel projet vous travaillez actuellement.’} en haut à droite de l’interface RStudio\nNaviguez dans l’explorateur de fichiers jusqu’au dossier d’analyse et double-cliquez sur le fichier avec une extension .Rproj\n\n\n\nLes options de RStudio\nAvant de poursuivre, mettons à jour certains paramètres par défaut de RStudio qui posent problème :\n\nOuvrir les options globales (Tools &gt; Global Options) et ouvrez l’onglet General (menu de gauche). Assurez-vous qu’aucune des cases des sections R Sessions, Workspace ou History sont cochées.\n\n\n\n\nCapture d’écran des options de Rstudio\n\n\nLorsqu’elles sont cochées, ces options amènent RStudio à enregistrer les objets de votre environnement et ils seront chargés de nouveau, chaque fois que vous ouvrirez une nouvelle session R. Bien que ces options par défaut puissent sembler une bonne idée, il est préférable de toujours commencer votre travail à partir d’une [session R vide]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Une session vide signifie que l’environnement est vide, mais que vous avez toujours vos scripts !’} afin d’éviter les bugs.\n\n\n\n\n\n\nImportant\n\n\n\nN’oubliez pas que toute commande ou sortie nécessaire au nettoyage et à l’analyse doit être enregistrée explicitement dans un script, dans un ordre donné, et fonctionnel."
  },
  {
    "objectID": "sessions_core/02_import_data.html#création-dun-nouveau-script",
    "href": "sessions_core/02_import_data.html#création-dun-nouveau-script",
    "title": "Importer des données",
    "section": "Création d’un nouveau script",
    "text": "Création d’un nouveau script\n\nOuvrez un nouveau script et enregistrez-le dans le répertoire R de votre projet sous le nom import_data.R.\nAjoutez quelques métadonnées au début du script, comme indiqué dans la première session, en utilisant la fonction commentaires. Veillez à inclure :\n\nLe titre\nL’auteur de l’article\nLa date de création\nLa description du projet\n\n\nVous êtes maintenant prêt à commencer à coder !"
  },
  {
    "objectID": "sessions_core/02_import_data.html#sec-packages",
    "href": "sessions_core/02_import_data.html#sec-packages",
    "title": "Importer des données",
    "section": "Paquets",
    "text": "Paquets\nLes paquets sont un ensemble de fonctions qui qui permettent d’aller plus loin qu’avec les fonctionnalités basiques de R. Vous les utiliserez beaucoup dans ce cours et dans votre vie quotidienne. Heureusement, en tant que langage open source, les paquets R peuvent être téléchargés et installés gratuitement sur internet.\n\n\n\n\n\n\nNote\n\n\n\nDans R, les paquets sont référencés à l’aide de {}. Par exemple {ggplot2} est le nom du paquet ggplot2 qui contient de nouvelles fonctions de traçage telles que ggplot(), geom_point() etc…\n\n\n\nInstallation\nNous pouvons installer un nouveau paquet à l’aide de la fonction install.packages() qui le télécharge et l’installe dans la bibliothèque de paquets de votre ordinateur. Cette opération n’est effectuée qu’une seule fois par ordinateur.\n\ninstall.packages(\"here\") # installe le paquet {here} \n\nN’oubliez pas de mettre le nom du paquet entre guillemets lorsque vous utilisez la commande install.packages(). Que se passe-t-il si vous ne le faites pas ?\n\n\n\n\n\n\nNote\n\n\n\nSi vous suivez cette session dans le cadre d’un cours, pour éviter tout problème potentiel de connectivité internet pendant la formation, nous vous avons déjà fait installer la plupart des paquets du cours.\nSi vous suivez ce tutoriel seul ou si vous n’avez pas encore installé les paquets, vous devrez installer manuellement chaque nouveau paquet que nous rencontrerons.\n\n\n\n\nUtilisation\nUne fois qu’un paquet est installé, nous pouvons l’utiliser mais nous devons spécifier à R que nous allons l’utiliser à chaque session. Ce processus s’appelle le chargement du paquet et s’effectue à l’aide de la fonction library().\n\nlibrary(here) # télécharge le paquet \"here\"\n\n\nUtilisez le library() pour charger les paquets here et rio qui seront utilisés dans la section suivante.\n\nEn fonction de la configuration de votre ordinateur et du paquet que vous essayez de charger, il se peut que vous obteniez un [message d’avertissement]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Contrairement aux messages d’erreur, les avertissements n’interrompent pas la commande en cours. Ils sont utilisés pour signaler des problèmes potentiels, mais non graves, et n’ont pas toujours besoin d’être corrigés.’} signalant que certaines fonctions ont été [masquées] {.hovertip bs-toggle=‘tooltip’ bs-title=‘Le masquage se produit lorsque R essaie de charger plus d’une fonction portant le même nom en même temps. Ce problème est courant. Par exemple, il existe un grand nombre de paquets qui ont une fonction appeléefilter() ou select(). Lorsque ces conflits se produisent, R choisira la version qui a été chargée en dernier et les autres versions seront ignorées (masquées).’} ou que la version actuelle du paquet a été construite pour une version différente de R. Ces messages ne posent généralement pas de problème, mais il est tout de même important de les noter.\n\nEssayez d’exécuter le code suivant. Pouvez-vous trouver la signification de du message d’erreur ?\n\nlibrary(ggplot)\n\n\nLe code ci-dessus génère une erreur car vous avez demandé une bibliothèque qui n’existe pas. Rappelez-vous que R est sensible à de nombreux éléments, y compris aux majuscules et minuscules et beaucoup de vos erreurs viendront de petites fautes de frappe dans les noms de fonctions ou d’objets. Ici, par exemple, nous voulions charger le paquet ggplot2 mais nous avons écrit ggplot à la place.\n\n\n\n\n\n\nAstuce\n\n\n\nLa plupart du temps, vous aurez besoin de charger un certain nombre de paquets pour votre script et il est recommandé d’avoir une section au début de votre code qui charge tout ce dont vous aurez besoin en un seul endroit :\n\n# Packages ----------------------------\nlibrary(tidyverse)   # manipulation de données\nlibrary(lubridate)   # manipulation des dates\n\nCette pratique permet de savoir facilement quels paquets doivent être installés pour exécuter un script.\n\n\n\nUtilisation commentaires pour créer une section “Paquets” dans votre script.\n\n\n\nMettre à jour les paquets\nR dispose d’une communauté de développeurs très active et il est assez courant que les paquets soient mis à jour régulièrement, car leurs propriétaires ajoutent de nouvelles fonctions et corrigent les bugs. Pour mettre à jour les paquets de votre bibliothèque, vous pouvez vous rendre dans [l’onglet Packages]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Pour rappel, cet onglet affiche la liste de tous les paquets que vous avez installés sur votre ordinateur, avec leur numéro de version.’} du panneau inférieur droit et cliquer sur Update. N’oubliez pas que vous devez être connecté à internet pendant ce processus.\n\n\n\n\n\n\nImportant\n\n\n\nParfois, lorsque les paquets sont mis à jour, il est possible que certaines fonctions que vous avez utilisées dans vos scripts soient supprimées ou modifiées, ce qui fait que votre code ne fonctionnera plus. Pas de panique si cela se produit. La meilleure pratique consiste à adapter votre code bien que, dans le pire des cas, vous puissiez [installer de force une ancienne version d’un paquet]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Il est déconseillé de faire cela car cela rendra votre code difficile à utiliser par d’autres.’}. Ceci ne sera pas abordé dans le cadre de cette session."
  },
  {
    "objectID": "sessions_core/02_import_data.html#importation-de-données",
    "href": "sessions_core/02_import_data.html#importation-de-données",
    "title": "Importer des données",
    "section": "Importation de données",
    "text": "Importation de données\n\nComprendre les chemins d’accès aux fichiers\nPour ouvrir un fichier dans R, vous devez fournir un chemin d’accès au fichier. Un chemin d’accès est simplement un nom plus long pour un fichier, qui inclut non seulement son nom mais aussi son emplacement sur votre ordinateur. Il existe plusieurs façons de définir ces chemins, notamment des chemins absolus et relatifs.\n\nChemins d’accès absolus\nLes chemins d’accès absolus sont spécifiques à votre ordinateur et vont jusqu’au niveau de votre disque dur. Par exemple, un chemin d’accès absolu peut ressembler à ceci : D:/OneDrive - MSF/Documents/monitoring/cholera/fancy_project/data/raw/example_linelist.xlsx. Il est clair que ce chemin ne fonctionnera que sur un seul ordinateur.\nL’utilisation de chemins absolus [codés en dur]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Le codage en dur correspond au fait l’écrire le chemin d’accès en entier, comme dans l’exemple ci-dessus, au lieu de construire des chemins par morceaux comme nous allons le montrer ci-dessous’} est fortement déconseillé car cela rend votre code rigide et susceptible de buguer : en effet, les chemins devront être mis à jour chaque fois que votre code est partagé ou que le dossier du projet est déplacé sur votre ordinateur.\n\n\nChemins relatifs\nLes chemins relatifs sont définis par rapport à votre répertoire de travail. Par exemple, le fichier .Rproj a défini notre répertoire de travail à la racine du dossier de notre projet, par conséquent, nous pourrions créer un chemin relatif qui ressemblerait à data/raw/example_linelist.xlsx. Cela signifie que tant que nous conservons la structure interne  de notre dossier de projet et avons un fichier .Rproj notre code devrait théoriquement fonctionner sur plusieurs ordinateurs.\n\n\nChemins d’accès robustes avec la fonction here() fonction\nLe paquet {here} dispose d’une fonction here() qui facilite grandement la définition des chemins. Elle présente deux avantages :\n\nLorsqu’elle est utilisée avec des projets RStudio, vous pouvez ne lui donner que la partie du chemin à l’intérieur du projet, (le chemin relatif), et la fonction l’utilise pour créer le chemin absolu.\nIl utilise pour cela le séparateur adapté à votre système d’exploitation qu’il s’agisse de /, \\ ou //.\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"C:/Users/c-fortas/AppData/Local/Temp/RtmpCEzFW9/file376c4f64499c/data/raw/example_linelist.xlsx\"\n\n\nIci, nous n’avons défini que le chemin relatif et la fonction a créé un chemin absolu. Cette façon de définir le chemin fonctionnera sur l’ordinateur de vos collègues, même s’ils utilisent un autre système d’exploitation, à condition que vous respectiez tous deux la structure interne du répertoire de travail.\nNous vous encourageons fortement à utiliser here() chaque fois que vous devez créer un chemin d’accès à un fichier.\n\nExécutez le code ci-dessus dans la console. Quel le chemin d’accès here(\"data\", \"raw\") vous donne-t-il ?\n\n\nUtiliser here() permet de créer un chemin d’accès complet au fichier msf_linelist_moissala_2023-09-24.xlsx. Conservez ce chemin, nous l’utiliserons bientôt.\n\n\n\n\n\n\n\nImportant\n\n\n\nhere() crée simplement un chemin de fichier, elle ne vérifie pas réellement si un fichier existe sur votre ordinateur : si le fichier est absent ou s’il y a une faute de frappe dans votre code, la commande affichera une erreur lorsque le chemin sera utilisé. Si vous souhaitez utiliser une fonction pour vérifier l’existence d’un fichier, essayez la fonction file.exists().\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nNous voudrons souvent sourcer plusieurs fichiers de données dans un seul projet. Pour faciliter ce processus, il peut être utile de créer une section au début du script, après le chargement des paquets pour définir les chemins et les stocker dans des variables.\n\n\n\n\n\nFonction d’importation\nDans R, les différents formats de fichiers sont souvent importés à l’aide de différentes fonctions, souvent spécialisées. Cela peut s’avérer fastidieux, car vous devez mémoriser et charger un grand nombre de fonctions pour importer vos données. Pour éviter ce problème, nous vous recommandons d’utiliser la fonction import() du paquet {rio} . Cette fonction est capable d’ouvrir de nombreux types de fichiers (y compris Excel, csv, Stata, et bien d’autres) en reconnaissant l’extension de fichier de vos données et [en appelant une fonction spécialisée pertinente d’un autre paquet.]{.hovertip bs-toggle=‘tooltip’ bs-title=‘Ce type de fonction, qui fournit une interface unifiée à d’autres fonctions spécifiques, est connu sous le nom de « wrapper ».’} afin que vous n’ayez pas à le faire.\nComme import() ne fait qu’appeler d’autres fonctions en arrière-plan, il est possible qu’il ait besoin dautres arguments selon le type de fichier que vous voulez charger.\n\n\n\n\n\n\nAstuce\n\n\n\nPour voir la liste complète de tous les types de fichiers que vous pouvez charger (et enregistrer !) avec rio consultez la liste des formats pris en charge sur leur site web. Dans la suite de la leçon, nous nous concentrerons sur l’importation de données à partir de fichiers Excel .xlsx.\n\n\n\nImportation à partir de la première feuille\nEn général, l’utilisation de import() est assez simple, au minimum vous devez indiquer le chemin du fichier dans l’argument file.\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"))\n\nRemarquez que nous avons imbriqué la commande here() à l’intérieur de la commande import(). L’imbrication de fonctions est absolument autorisée dans R et c’est quelque chose que vous ferez tout le temps. Lorsque des fonctions sont imbriquées, R les évalue dans l’ordre de la fonction la plus proche (dans le cas présent here()) à la plus externe (dans ce cas import()). De cette manière, sortie de here() est utilisée comme valeur d’entrée de import().\n\nImportez le fichier msf_linelist_moissala_2023-09-24.xlsx qui se trouve dans votre sous-dossier de données brutes dans R en utilisant here() et import().\n\nSi votre importation a fonctionné correctement, R affichera les données dans la console mais ne les enregistrera pas dans l’environnement car nous ne les avons pas assignées à un objet.\n\n\n\n\n\n\nAstuce\n\n\n\nIl se peut que vous ne souhaitiez pas que R affiche de très grandes bases de données dans la console et les assigne directement à un objet.\n\n\n\nRéimportez vos données, mais cette fois-ci, sauvegardez-les dans un objet appelé df_linelist.\n\n\n\nImporter des données à partir de n’importe quelle feuille\nComme vous venez de le voir, R sélectionne la première feuille par défaut. Il est cependant possible de spécifier le numéro (ou le nom) de la feuille de calcul que vous souhaitez dans votre ficher Excel à partir de la fonction import() en utilisant l’argument which:\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"),\n       which = 2)  # importe la deuxième feuille\n\nNotez que l’argument which est spécifique aux types de fichiers comportant plusieurs feuilles, tels que les fichiers Excel ou .Rdata. Si vous essayez de l’utiliser sur un fichier .csv l’argument sera ignoré."
  },
  {
    "objectID": "sessions_core/02_import_data.html#un-premier-aperçu-de-vos-données",
    "href": "sessions_core/02_import_data.html#un-premier-aperçu-de-vos-données",
    "title": "Importer des données",
    "section": "Un premier aperçu de vos données",
    "text": "Un premier aperçu de vos données\nNous avons maintenant importé un ensemble de données dans R et l’avons assigné à un dataframe (df_linelist). Dans l’étape suivante, nous pouvons inspecter cet ensemble de données, vérifier que l’importation s’est bien déroulée, le connaître un peu mieux et évaluer s’il doit être nettoyé avant d’être analysé.\nNous pouvons commencer par jeter un coup d’œil rapide aux premières lignes du dataframe à l’aide de la fonction head(). Cette fonction prend un dataframe comme premier argument et accepte un second argument n en option, indiquant le nombre de lignes que nous souhaitons voir.\n\nhead(df_linelist, n = 10) # Inspecte les 10 premières lignes\n\n\nUtilisez head() pour examiner les 12 premières lignes de df_linelist.\n\nNous pouvons également vérifier nos données en regardant l’onglet Environnement dans le panneau supérieur droit. Ici, nous pouvons voir notre dataframe dans l’environnement, examiner sa structure ou l’ouvrir dans le visualiseur de données (“data viewer”) de RStudio.\n\nCliquez sur le bouton rond bleu à côté de df_linelist dans votre environnement pour voir sa structure. Cliquez ensuite sur le nom de la base de données pour le visualiser.\n\nLa visualiseur de données affiche les dataframe sous forme de tableaux et constitue un moyen pratique d’examiner rapidement vos données. Vous pouvez même trier et filtrer vos données dans “View”, mais sachez que ces actions n’apporteront aucune modification à l’objet réel. df_linelist. La “View” peut également être ouverte en utilisant directement la fonction View()."
  },
  {
    "objectID": "sessions_core/02_import_data.html#fini",
    "href": "sessions_core/02_import_data.html#fini",
    "title": "Importer des données",
    "section": "Fini !",
    "text": "Fini !\nBravo et n’oubliez pas de sauvegarder votre code.\n\n\n\n Solution File"
  },
  {
    "objectID": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "href": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "title": "Importer des données",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices supplémentaires\n\nUtilisez dim() pour examiner les dimensions de votre base de données.\nUtilisez str() pour vérifier le type de données de chaque colonne. Voyez-vous quelque chose d’étrange ? N’oubliez pas que vous pouvez également utiliser des fonctions telles que is.character() et is.numeric() si vous souhaitez tester le type d’une colonne particulière.\nEn utilisant une fonction apprise lors de la première session, pouvez-vous extraire les noms des colonnes de l’ensemble de données ? Ces résultats correspondent-ils à ce que vous voyez lorsque vous ouvrez les données dans Excel ?\nEssayez de mettre votre dataframe dans la fonction summary(). Que vous dit cette fonction ?\n\n\n\nRessources complémentaires\n\nLe site web rio\nPlus d’exemples sur l’importation de données de différents types de fichiers"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Ressources",
    "section": "",
    "text": "Cette page contiendra (éventuellement) des ressources externes pour poursuivre votre parcours d’apprentissage du R."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{repicentre}",
    "section": "",
    "text": "Welcome to {repicentre}\nUne plateforme open source pour apprendre R dans les contextes humanitaires. Qu’aimeriez-vous faire ?\n\n\n\n\n\nApprendre Parcours linéaire en commençant par les bases  Start\n\n\n\n\n\nExplorer Catalogue complet de cours d’autoformation  Start\n\n\n\n\n\nÉlargir Ressources externes pour aller plus loin  Start"
  },
  {
    "objectID": "about.html#salut",
    "href": "about.html#salut",
    "title": "About",
    "section": "Salut",
    "text": "Salut\nBienvenue sur {repicentre}, un site open source développé par Epicentre pour vous aider à apprendre R pour les contextes humanitaires. Le site est composé de tutoriels autodidactes et propose deux options principales d’apprentissage :\n\nLinéaire. Conçu pour les personnes n’ayant aucune expérience préalable de R, le cours linéaire vous guidera à travers les concepts de base de R en utilisant une étude de cas sur la rougeole au Tchad. Le cours couvre les concepts suivants :\n\nStructures de données et l’interface RStudio\nImportation de données\nManipulation de données\nNettoyage des données\nAgrégation de données\nVisualisation des données\n\nExploration. Si vous avez un peu plus d’expérience ou si vous recherchez un sujet particulier, n’hésitez pas à explorer la gamme complète des tutoriels. Les tutoriels sont classés par catégories et sont conçus pour être autonomes."
  },
  {
    "objectID": "about.html#recommandations-et-demandes",
    "href": "about.html#recommandations-et-demandes",
    "title": "About",
    "section": "Recommandations et demandes",
    "text": "Recommandations et demandes\nY a-t-il un sujet sur lequel vous aimeriez voir un tutoriel qui n’est pas encore disponible ? C’est très bien ! N’hésitez pas à nous le faire savoir en ouvrant un “issue” sur le repo GitHub associé à ce site web. Si vous ne savez pas comment ouvrir un issue, veuillez contacter Cat Eisenhauer."
  },
  {
    "objectID": "about.html#contribuer",
    "href": "about.html#contribuer",
    "title": "About",
    "section": "Contribuer",
    "text": "Contribuer\nVous souhaitez contribuer à la rédaction ou à la maintenance de tutoriels ? Incroyable ! Veuillez contacter Cat."
  },
  {
    "objectID": "explore.html",
    "href": "explore.html",
    "title": "Explorer",
    "section": "",
    "text": "Choisissez votre propre aventure en parcourant toutes les sessions disponibles.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des données\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et commencez à importer des données pour travailler dans R.\n\n\n\n\n\n\n22 janv. 2025\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nVos premiers pas dans R. Apprenez à vous familiariser avec Rstudio et avec des objets R courants.\n\n\n\n\n\n\n28 janv. 2025\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "pathway.html",
    "href": "pathway.html",
    "title": "Chemin",
    "section": "",
    "text": "Ces sessions peuvent être suivies afin d’obtenir un niveau de base dans R. La série suppose aucune expérience préalable dans R et convient aux débutants.\nVous en voulez plus ? Vous voulez plus de flexibilité ? Consultez le catalogue complet des sessions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\n\n\nVos premiers pas dans R. Apprenez à vous familiariser avec Rstudio et avec des objets R courants.\n\n\n\n\n\n28 janv. 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des données\n\n\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et commencez à importer des données pour travailler dans R.\n\n\n\n\n\n22 janv. 2025\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "sessions_core/01_introduction.html",
    "href": "sessions_core/01_introduction.html",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre à travailler avec la console\nCréer et exécuter un script\nCréer des objets R de base, tels que des vecteurs et des dataframes"
  },
  {
    "objectID": "sessions_core/01_introduction.html#objectifs",
    "href": "sessions_core/01_introduction.html#objectifs",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre à travailler avec la console\nCréer et exécuter un script\nCréer des objets R de base, tels que des vecteurs et des dataframes"
  },
  {
    "objectID": "sessions_core/01_introduction.html#format-de-lexercice",
    "href": "sessions_core/01_introduction.html#format-de-lexercice",
    "title": "Introduction à R",
    "section": "Format de l’exercice",
    "text": "Format de l’exercice\nCes exercices se présentent sous la forme d’un tutoriel à rythme libre contenant de brèves explications sur des concepts clés, des exemples et des exercices à suivre. Le cours utilise une approche d’apprentissage par la pratique, et bien que cette première session commence par une exploration de l’interface de RStudio, les sessions suivantes se concentreront sur comment écrire votre propre code.\nLes instructions pour les exercices seront données dans les formats suivants :\n\nCeci est un encadré concernant une action générale. Vous le verrez généralement au début d’une session avec des instructions pour cette leçon.\n Exemple: Ouvrez un nouveau script vierge et nommez-le mon_premier_script.R.\n\n\nCeci est un encadré concernant du code, et indique un exercice de codage dans lequel vous écrirez votre propre code.\n Exemple: Créez un objet appelé region qui contient la valeur \"Mandoul\".\n\n\nCeci est un encadré concernant un point d’observation Il contient des instructions sur quelque chose que vous devez observer ou étudier.\n Exemple: Inspecter l’interface de RStudio.\n\nAu cours de ces exercices, vous rencontrerez peut-être des erreurs, qui se produisent lorsque R n’est pas en mesure d’exécuter une commande. Cela peut se produire pour de nombreuses raisons : vous avez peut-être mal orthographié le nom d’un objet, demandé à R de rechercher un fichier qui n’existe pas, ou fourni le mauvais type de données à une fonction. Lorsqu’une erreur se produit, R arrête les calculs en cours et vous donne un message expliquant ce qu’il s’est passé. Il est tout à fait normal d’avoir des erreurs et cela arrive à tous les programmeurs qu’ils soient novices ou experts. À l’instar d’un langage naturel, vous vous améliorerez dans l’utilisation de R au fur et à mesure que vous vous entraînerez et que vous travaillerez sur vos erreurs."
  },
  {
    "objectID": "sessions_core/01_introduction.html#rstudio-et-r",
    "href": "sessions_core/01_introduction.html#rstudio-et-r",
    "title": "Introduction à R",
    "section": "RStudio et R",
    "text": "RStudio et R\nR est un langage de programmation fonctionnel qui peut être utilisé pour nettoyer et manipuler des données, effectuer des analyses (en particulier des analyses statistiques), visualiser des résultats, et bien plus encore.\nRStudio est un logiciel qui fournit une interface facile à utiliser pour R (également appelé IDE, pour “Integrated Development Environment”). Bien que l’utilisation d’une interface graphique ne soit pas obligatoire, elle est fortement recommandée pour les débutants.\n\nPremiers pas avec RStudio\nCommençons par le commencement !\n\nOuvrez RStudio en utilisant le menu de démarrage ou le raccourci du bureau ; si RStudio est déjà ouvert, veuillez le fermer et l’ouvrir à nouveau.\n\nVous devriez voir une interface qui ressemble à ceci :\n\n\n\nVue de l’interface de l’IDE Rstudio à l’ouverture\n\n\n\nInspectez l’interface RStudio.\n\nVous disposerez de trois ou quatre panneaux, dont :\n\nPanneau supérieur droit\nEn haut à droite se trouve un panneau avec plusieurs onglets. La plupart d’entre eux dépassent le cadre de ce cours, mais nous utiliserons les deux onglets suivants dans le cadre de ce cours :\n\nEnvironment. Liste des objets enregistrés par l’utilisateur dans la session en cours. Comme vous venez de démarrer une nouvelle session, votre environnement doit être vide.\nHistory. correspond à l’historique de toutes les commandes que vous avez exécutées au cours de la session actuelle.\n\n\n\n\n\n\n\nNote\n\n\n\nVous pouvez considérer une session R comme le démarrage d’un ordinateur. Lorsqu’une session démarre, tout est vierge et prêt pour le calcul, de la même manière qu’il n’y a aucun programme ouvert lorsque vous allumez votre ordinateur pour la première fois. De manière générale, nous vous encourageons à arrêter et à démarrer vos sessions R régulièrement. Eteindre et rallumer R permet de corriger certains de vos bugs.\n\n\n\n\nPanneau inférieur droit\nEn bas à droite se trouve un autre panneau à onglets multiples, comprenant les éléments suivants\n\nFiles. Un explorateur de fichiers pour le répertoire de travail, qui est l’emplacement du dossier dans lequel R travaille actuellement.\nPlots. Un emplacement où RStudio affichera des graphiques statiques Cet onglet doit être vide pour le moment.\nPackages. Liste de tous les paquets R installés sur votre ordinateur. Les paquets sont des collections de fonctions qui permettent d’étendre les fonctionnalités de R. Nous les aborderons plus en détail dans la section prochaine leçon.\nHelp. Un endroit pour lire les pages d’aide et la [documentation]{.hovertip bs-toggle=‘tooltip’ bs-title=‘La documentation fait référence à un texte supplémentaire, soit dans un fichier de code, soit dans un document externe, qui est écrit pour aider les gens à comprendre ce que fait un morceau de code, une fonction ou un paquet et comment il devrait être utilisé. La documentation du code est un peu analogue à la création d’un dictionnaire de données pour une base de données d’enquête et constitue une partie indispensable permettant de rendre son code robuste et réutilisable’} pour les fonctions et les paquets.\nViewer. Un emplacement où RStudio affichera des sorties html telles que des tableaux, des widgets interactifs ou même des tableaux de bord.\n\n\n\nPartie gauche\n\nA gauche (ou en bas à gauche si vous avez quatre panneaux), vous devriez voir le bouton console où le code R est exécuté.\nEn haut à gauche (si vous avez quatre panneaux) se trouve les scripts R ouverts.\n\nDans les deux sections suivantes, nous parlerons plus en détail de la console et des scripts.\n\n\n\nLa console\nLa console est l’endroit où R est exécuté.\nChaque fois que vous ouvrez une nouvelle session, R commence par afficher quelques informations sur votre configuration, telles que le numéro de version de R. En dessous de ces informations, vous trouverez une ligne contenant le numéro de version de R. En dessous de ces informations, il devrait y avoir une ligne avec le symbole &gt; et un curseur clignotant. Pour exécuter une commande dans R, il vous suffit de la taper après ceci &gt; et d’appuyer sur Enter. R traitera alors votre code et affichera le résultat (s’il y en a un). Un nouveau &gt; s’affichera alors, prête pour la commande suivante.\n\n\n\n\n\n\nImportant\n\n\n\nSi la dernière ligne affichée dans la console commence par un + au lieu d’un &gt; cela signifie que la console n’est pas prête à recevoir une nouvelle commande, soit parce qu’elle est encore en train de traiter une commande précédente, soit parce qu’elle a reçu un bout de code incomplet. A tout moment, vous pouvez annuler une commande en cours ou incomplète, en appuyant sur la touche Echap.\n\n\n\nExécutez les commandes suivantes dans la console, une ligne à la fois, et observez les résultats.\n\n5 + 90\n\n6 * 171\n\n189 / 36.6\n\n92^3\n\n(12 + 9)^4 / 1000\n\nExécutez maintenant la commande suivante. Notez que la dernière ligne de commande ) est manquante, ce qui rend la commande incomplète. Que se passe-t-il lorsque vous faites cela ?\n\n3 / (2 + 97\n\n\nVous avez peut-être remarqué dans les exemples ci-dessus que notre code comporte beaucoup d’espaces entre les caractères. Ce n’est pas un hasard. C’est une bonne pratique d’inclure des espaces autour de la plupart des opérateurs, tels que +, -, *, /, &lt;, &gt;, = et &lt;-. Non seulement ces espaces facilitent la lecture et la compréhension de votre code, mais dans certains (rares) cas, ils peuvent même être nécessaires pour éviter des erreurs. Cela dit, il faut savoir qu’il y a un petit nombre d’opérateurs qui ne doivent pas être entourés d’espaces, tels que ^, . et :.\n\n1+29+4.8/3*3           # Pas bien\n1 + 29 + 4.8 / 3 * 3   # Bien\n\n1 ^ 2 # Pas bien\n1^2   # Bien\n\nNous pouvons également faire tourner des fonctions dans la console. Nous aborderons les fonctions plus en détail plus loin dans cette leçon mais en attendant, sachez que l’idée des fonctions dans R est très similaire à celle d’Excel, où vous êtes sans doute familier avec des fonctions telles que SOMME ou MOYENNE.\n\nExécutez les commandes suivantes dans la console (une ligne à la fois).\n\n# Trouvez la value minimum\nmin(5, 10)\nmin(1, 8, 56, 0.3)\n\n# Trouvez la valeur maximale\nmax(568, 258, 314)\n\n\n\n\nScripts\nLes scripts sont des fichiers texte qui contiennent une série de commandes pour un langage de programmation particulier. L’extension du fichier indique le langage dans lequel les commandes ont été écrites, et nous utiliserons .R. Les scripts nous permettent de créer du code qui peut être réutilisé, partagé et même automatisé.\n\nÉcrire son premier script\n\n\n\nEtapes pour créer un nouveau script dans l’IDE RStudio\n\n\nPour créer un nouveau script, allez dans File &gt; New File &gt; R Script. Vous pouvez également cliquer sur la petite icône verte + avec une page blanche juste en dessous de File ou utiliser le raccourci clavier CTRL+SHIFT+N. Ce nouveau script non sauvegardé apparaîtra sous la forme d’un document vierge dans le panneau supérieur gauche.\nPour enregistrer votre script, utilisez le menu File &gt; Save As ou le raccourci clavier CTRL+S.\n\nCréez et enregistrez un nouveau script appelé discovery.R. N’oubliez pas d’inclure l’extension .R. Pour l’instant, vous pouvez l’enregistrer sur votre bureau ou à tout autre endroit approprié, mais nous parlerons plus en détail de l’organisation de vos scripts dans la section prochaine session.\n\n\n\nExécuter du code à partir d’un script\nPour exécuter du code à partir d’un script, placez simplement votre curseur sur la ligne que vous souhaitez exécuter (ou sélectionnez plusieurs lignes) et effectuez l’une des opérations suivantes :\n\nCliquez sur le bouton Run en haut à droite de la fenêtre de script\nUtilisez le raccourci CTRL+Enter (le curseur passera ensuite à la ligne suivante)\nUtiliser le raccourci ALT+Enter (le curseur reste ensuite sur la ligne en cours)\n\n\nCopiez le code que vous avez exécuté dans les exercices précédents dans votre script et exécutez-le en utilisant chacune des méthodes ci-dessus.\nA partir de maintenant, vous écrirez votre code dans votre script et l’exécuterez à partir de là, sauf indication contraire dans les instructions.\n\n\n\nCommentaires\nEn R, tout texte précédé d’un # (jusqu’à la fin d’une ligne) est un commentaire. R ne considère pas les commentaires comme du code et les ignore lorsque vous exécutez vos scripts. Les commentaires sont donc un excellent moyen de documenter votre code.\n\n# Ceci est un commentaire\n\n2 + 3  # Ceci est aussi un commentaire\n\nIl est utile pour l’avenir, pour vous et pour les autres, de commencer vos scripts par quelques lignes commentées fournissant des informations sur le fichier.\n\n#### IMPORTATION & PREPARATION DES DONNEES ####\n# Auteure :  Mathilde Mousset\n# Date de création : 23/11/2024\n# Dernière mise à jour : 30/11/2024\n# Description : Importation et nettoyage des données de surveillance rougeole de Moissala\n\n\nAjoutez quelques commentaires au début de votre script pour le décrire.\n\nLes commentaires sont également un moyen pratique de diviser les scripts plus longs en sections thématiques, telles que “Importation de données”, “Analyse”, “Visualisation”, etc. Par exemple :\n\n# NOM DE LA SECTION 1 -----------------------------------------------             \n\n# NOM DE LA SECTION 2 -----------------------------------------------             \n\n\nUtilisez les commentaires pour créer des sections dans votre script qui correspondent aux sections principales de ce tutoriel.\n\nEnfin, les commentaires nous permettent d’écrire des notes utiles pour nos collègues (et nos futurs collègues) qui peuvent les aider à comprendre le code et la raison pour laquelle nous l’avons écrit de cette manière. En règle générale, on se concentrer sur les commentaires qui expliquent le “pourquoi” plutôt que le “quoi”. En effet, le “quoi” d’un code bien écrit devrait être relativement explicite.\nCe commentaire, par exemple, est tout à fait superflu :\n\n1 + 3  # Code pour additionner un et trois\n\nEn comparaison, voici quelques cas d’utilisation qui mériteraient d’être commentés :\n\nVous définissez une constante, par exemple une valeur seuil de séroprévalence. Vous pouvez ajouter un commentaire indiquant la référence d’où provient la valeur.\nVotre code contient une valeur ou un nom de fichier qui doit être mis à jour chaque semaine. Vous devez l’indiquer dans un commentaire afin que toute personne utilisant le code en soit informée.\nVous utilisez une commande ou un paquet rare que votre collègue ne connaît peut-être pas ou qu’il peut trouver contre-intuitif. Vous pouvez utiliser un commentaire pour expliquer le raisonnement qui sous-tend cette décision.\n\nCeci étant dit, vous apprenez, et les scripts que vous écrivez pendant ce cours sont vos notes, alors n’hésitez pas à utiliser autant de commentaires (du type “quoi” et “pourquoi”) que vous le souhaitez. Vous écrirez naturellement moins de commentaires à l’avenir, lorsque certaines choses qui vous semblent étrangères aujourd’hui deviendront naturelles.\n\n\n\n\n\n\nAstuce\n\n\n\nVous pouvez commenter une ligne sélectionnée avec le raccourci CTRL+SHIFT+C.\nVous pouvez ajouter une section de premier niveau avec CTRL+SHIFT+R.\n\n\n\nAjoutez quelques commentaires pour décrire le code que vous avez écrit jusqu’à présent dans votre script."
  },
  {
    "objectID": "sessions_core/01_introduction.html#types-de-données",
    "href": "sessions_core/01_introduction.html#types-de-données",
    "title": "Introduction à R",
    "section": "Types de données",
    "text": "Types de données\nR dispose de plusieurs types de données. Ceux que nous verrons le plus souvent dans ce cours sont les suivants :\n\nnumérique [en anglais, numeric]\nchaîne de caractères (texte) [string]\nbooléen (VRAI / FAUX) [boolean]\ndate [date]\nfacteur [factor]\n\n\nNumérique\nLe type numérique comprend à la fois les entiers [en anglais integers] et les doubles (nombres comprenant une décimale) et peuvent être créés en écrivant simplement la valeur “brut” dans votre script ou votre console.\n\n\nChaînes de caractères [string]\nLes strings sont la version R du texte et peuvent être créées en entourant le texte de guillemets simples ou doubles, par exemple \"district\" ou 'cases' (les guillemets doubles sont généralement considérés comme la meilleure pratique).\n\nComparez la sortie dans la console pour les commandes suivantes :\n\n28         # numérique\n\"28\"       # texte\n28 + \"28\"  # donne une erreur\n\n\nLa dernière commande ci-dessus donnera lieu à une erreur car nous ne pouvons pas effectuer d’opérations arithmétiques combinant du texte et des nombres.\n\n\n\n\n\n\nImportant\n\n\n\nR est sensible aux majuscules, ce qui signifie que la chaîne \"ABC\" n’est pas équivalente à \"abc\".\n\n\n\nSi vous souhaitez créer une chaîne de caractères contenant des guillemets, la meilleure pratique consiste à s’échapper du caractère en le faisant précéder d’un \\, par exemple : \"Elle dit \\\"Bonjour\\\" et s'en alla\" ou 'C\\'est une belle journée'. Si vous avez utilisé une double citation pour créer la chaîne de caractères, vous pouvez utiliser des guillemets simples à l’intérieur de celle-ci (par exemple : \"C'est une belle journée\") et vice versa (par exemple : 'Elle dit \"Bonjour\" et s'en alla').\n\n\n\nBooléen (logique)\nLe type booléen (ou “logique”) stocke des valeurs vrai/faux et est créé en écrivant soit TRUE ou FALSE sans guillemets.\nEn interne, R transfome TRUE et FALSE comme une version spéciale de 1 et 0 respectivement, et les valeurs booléennes peuvent être facilement traduites en ces équivalents numériques pour les opérations arithmétiques.\n\n\n\n\n\n\nNote\n\n\n\nVous trouverez peut-être des personnes qui utilisent T ou F mais cela est déconseillé car T et F peuvent également être utilisés comme noms d’objets ou de variables. TRUE et FALSE sont cependant protégés dans R, ce qui signifie qu’ils ne peuvent pas être réaffectés à une autre valeur.\n\n\n\n\nDéterminer le type d’un objet\nIl existe plusieurs fonctions permettant de déterminer le type d’un objet (souvent appelé le classe de l’objet en R [en anglais, class]).\n\nTapez les commandes suivantes dans votre script et exécutez-les :\n\n# Get the Type of an Object\nclass(28)  \nclass(\"Mandoul\")\n\n# Test the Type of an Object\nis.numeric(28)\nis.numeric(\"Mandoul\")\nis.character(\"Mandoul\")\n\nis.numeric(TRUE)\nis.character(TRUE)\nis.logical(FALSE)"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-assignement-operator",
    "href": "sessions_core/01_introduction.html#sec-assignement-operator",
    "title": "Introduction à R",
    "section": "Création d’un objet",
    "text": "Création d’un objet\nEn R, presque tout est un objet y compris les fonctions, les valeurs scalaires et d’autres structures de données plus complexes. Avant de présenter ces structures, faisons un détour important pour discuter de la manière dont les objets sont enregistrés dans votre environnement.\nSouvent, nous souhaitons réutiliser les mêmes valeurs ou données tout au long d’un script et il est donc très utile de les stocker sous forme d’objets dans notre environnement. Pour ce faire, nous utilisons un opérateur d’affectation, &lt;-.\n\nRegardez le panneau d’environnement en haut à droite, vérifiez qu’il est vide, puis tapez la commande suivante dans votre script et exécutez-la pour enregistrer une variable appelée cases dans votre environnement.\n\ncases &lt;- 28\n\nRegardez à nouveau l’environnement. Est-il toujours vide ?\n\nSi vous souhaitez accéder à la valeur de votre nouvel objet, cases il vous suffit de exécuter son nom.\n\ncases\n\n[1] 28\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa raison pour laquelle nous devons mettre les chaînes de caractères entre guillemets est en fait pour permettre à R de différencier les chaînes de caractères (\"cases\" et les noms d’objets cases).\n\n\nUne fois créés, les objets peuvent être utilisés dans d’autres commandes :\n\ncases + 5\n\n[1] 33\n\n\n\nDans votre script, créez un objet appelé region qui contient la valeur \"Mandoul\". Le voyez-vous dans votre environnement ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN’oubliez pas que nous devons toujours entourer &lt;- par des espaces afin d’améliorer la lisibilité et d’éviter les erreurs.\n\nx&lt;-3     # BAD\nx &lt;- 3   # GOOD\n\n\n\n\nMise à jour d’un objet\nNous souhaitons souvent mettre à jour la valeur stockée dans un objet. Pour ce faire, il suffit d’assigner une nouvelle valeur avec la même syntaxe que celle utilisée lors de la création de l’objet :\n\ncases &lt;- 32\n\n\nMettre à jour la valeur de region en \"Moyen Chari\".\n\n\n\nNoms d’objets\nPour nommer vos objets, il existe quelques règles (relativement) strictes :\n\nNe pas commencer par un chiffre\nNe pas utiliser d’espaces (utiliser un _ à la place)\nN’utilisez pas de valeurs protégées (comme TRUE et FALSE) ou des noms de fonctions (comme mean)\nN’utilisez pas de majuscules\n\nAu-delà de ces règles strictes, il existe également des bonnes pratiques plus subjectives et des styles personnels. En règle générale, les noms doivent être courts et descriptifs :\n\na &lt;- 19                             # BAD (not informative)\nage_du_patient_a_l_admission &lt;- 19  # BAD (too long)\nage &lt;- 19                           # GOOD\n\nDonner à vos objets des noms clairs et informatifs contribue à rendre votre code lisible, ce qui permet aux autres de le comprendre facilement sans avoir à consulter le dictionnaire de données toutes les deux secondes."
  },
  {
    "objectID": "sessions_core/01_introduction.html#structures-de-données",
    "href": "sessions_core/01_introduction.html#structures-de-données",
    "title": "Introduction à R",
    "section": "Structures de données",
    "text": "Structures de données\nJusqu’à présent, nous nous sommes contentés d’étudier des objets simples qui stockent des valeurs individuelles. Nous allons maintenant nous intéresser à des structures plus complexes qui peuvent stocker des ensembles entiers de données.\n\nVecteurs\nIl est possible de rassembler plusieurs valeurs (telles que des valeurs numériques ou des chaînes de caractères) en un seul objet, appelé vecteur.\nTechniquement, il existe plusieurs types de vecteurs, par exemple :\n\nVecteurs simples (ou vecteurs atomiques) ne peuvent contenir qu’un seul type de valeurs. Par exemple, un tableau numérique 2, 4, 6 ou un tableau de chaînes de caractères \"Mandoul\", \"Moyen Chari\".\nVecteurs récursifs (généralement appelés listes) sont beaucoup plus complexes et peuvent contenir plusieurs dimensions et types de données. Nous ne les aborderons pas dans cette leçon.\n\nCe cours n’entrera pas dans les détails des concepts plus abstraits qui sous-tendent ces structures et se concentrera uniquement sur celles que vous rencontrerez le plus souvent dans votre travail quotidien.\n\nVecteurs simples\nLes vecteurs simples peuvent contenir une ou plusieurs valeurs d’un seul type de données Ils ont donc deux propriétés essentielles : la longueur et type. Dans le cadre de ce cours, nous utiliserons indifféremment les termes “vecteur simple” et “vecteur” (comme c’est généralement le cas dans la communauté R).\nTechniquement, vous avez déjà créé votre premier vecteur simple lorsque vous avez construit cases et region. Il s’agissait simplement de vecteurs avec un longueur d’un. Pour créer un vecteur avec plus d’une valeur, nous utiliserons la fonction c() ( [mnémonique]{.hovertip bs-toggle=‘tooltip’ bs-title=’ is the first letter of “concatenate”’}) :c\n\ncases &lt;- c(2, 5, 8, 0, 4)\n\n\nMise à jour cases avec les valeurs ci-dessus et mettre à jour region pour créer un vecteur de chaînes de caractères contenant les valeurs suivantes : Mandoul, Moyen-Chari, Logone Oriental, Tibesti et Logone Occidental : Mandoul, Moyen-Chari, Logone Oriental, Tibesti et Logone Occidental.\n\nNous pouvons maintenant utiliser des fonctions sur les objets que nous avons créés :\n\nmean(cases)      # calculate the mean value of the cases vector\n\n[1] 3.8\n\ntoupper(region)  # convert all the values in region to upper case\n\n[1] \"MANDOUL\"           \"MOYEN-CHARI\"       \"LOGONE ORIENTAL\"  \n[4] \"TIBESTI\"           \"LOGONE OCCIDENTAL\"\n\n\n\nUtilisons quelques fonctions ! Essayez d’écrire un code qui fait ce qui suit :\n\nCalculer la somme de cases en utilisant la fonction sum()\nConvertir le texte en region en minuscules à l’aide de la fonction tolower()\n:::\n\n\nAccès aux valeurs d’un vecteur\nIl est possible d’accéder à la valeur d’un vecteur en utilisant des crochets contenant l’indice (position) de la valeur souhaitée, c’est-à-dire : [3] ou [189].\n\ncases[2]   # 2nd value of cases\n\n[1] 5\n\ncases[10]  # 10th value of cases\n\n[1] NA\n\n\nOups il n’existe pas ! Nous reviendrons sur ce que cette NA signifie dans le Valeurs manquantes.\nNous pouvons également accéder à un gamme de valeurs, comme nous pourrions le faire dans Excel. Pour créer une plage, nous utilisons la fonction : pour séparer les indices minimum et maximum souhaités :\n\ncases[2:4]  # 2nd to 4th values of cases\n\n[1] 5 8 0\n\n\n\nObtenir la 3ème valeur de region.\nEcrire du code pour accéder aux valeurs “Mandoul” et “Moyen-Chari” dans le vecteur region.\n\n\n\nTrames de données\nTrames de données sont des str uctures structures / tableaux en 2D avec des lignes et des colonnes. Il s’agit d’une structure très similaire à celle d’un “tableau” dans Excel. En tant qu’épidémiologistes, ce type de structure de données est peut-être le plus utile et vous l’utiliserez probablement au quotidien, pour stocker les données de la liste de diffusion par exemple.\n\nCréation d’un cadre de données\nNous pouvons créer un cadre de données à l’aide de la fonction data.frame():\n\ndata.frame(col1 = c(1, 4, 2, 9),\n           col2 = c(\"a bit of text\", \"some more text\", \"hello\", \"epidemiologists!\"))\n\n  col1             col2\n1    1    a bit of text\n2    4   some more text\n3    2            hello\n4    9 epidemiologists!\n\n\nVoir comment col1 a été créé à partir d’un tableau numérique, et col2 à partir d’un tableau de chaînes de caractères. Ici, nous avons choisi les noms des colonnes (col1 et col2), ce qui est normal, mais vous pouvez exécuter le code sans pour voir comment R gère les noms par défaut.\n\nDans votre script, créez un cadre de données appelé data_cases qui contient cases dans une colonne et region dans l’autre.\n\n\n\nExploration d’un cadre de données\ndata_cases devrait maintenant apparaître dans votre environnement. Vous pouvez cliquer sur le cercle bleu avec un triangle blanc pour obtenir des informations supplémentaires, ou cliquer sur son nom pour ouvrir l’objet dans le même volet que les scripts pour le visualiser.\n\n\n\nLe cadre de données data_case apparaît désormais dans le volet Environnement.\n\n\nIl existe plusieurs fonctions pratiques permettant d’explorer une base de données :\n\nExécutez les commandes suivantes et essayez de déterminer le type d’informations qu’elles renvoient.\n\nstr(data_cases)     # STRucture of the object\ndim(data_cases)     # DIMension of the object\nnrow(data_cases)    # Number of ROWs\nncol(data_cases)    # Number of COLumns\nnames(data_cases)   # column NAMES\n\n\nPratiquons un peu plus ! R est livré avec plusieurs ensembles de données intégrés auxquels il est possible d’accéder directement, dont un appelé iris. C’est pratique aujourd’hui car nous n’avons pas encore appris à importer des données dans R (ne vous inquiétez pas, nous travaillerons sur les données de listes de lignes à partir de la deuxième session).\nNous pouvons voir les premières lignes de cette base de données à l’aide de la fonction head():\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nCombien de lignes et de colonnes y a-t-il dans iris? Quels sont les noms de ses colonnes ?\n\n\n\nAccéder aux données d’un cadre de données\nEn R, il existe plusieurs méthodes pour accéder aux lignes et/ou aux colonnes d’un cadre de données. Dans cette session d’introduction, nous nous concentrerons sur la méthode [ ] syntaxe.\nNous utilisons les crochets pour accéder à des valeurs individuelles ou à des plages de valeurs dans notre cadre de données. Pour ce faire, nous devons donner à R un numéro de ligne (ou un intervalle de lignes) et un numéro/nom de colonne (ou un intervalle de colonnes), en utilisant la syntaxe suivante [row, column].\n\ndata_cases[1, 2]          # the value of row one, column 2\n\n[1] \"Mandoul\"\n\ndata_cases[1, \"region\"]   # first value in the region column\n\n[1] \"Mandoul\"\n\n\nSi nous voulons accéder à toutes les lignes (ou colonnes), nous pouvons simplement laisser un espace à la place du numéro/nom :\n\ndata_cases[1, ]           # values of all columns in row one\n\n  cases  region\n1     2 Mandoul\n\ndata_cases[2:4, ]         # values of all columns for rows 2 through 4\n\n  cases         region\n2     5       Sud Kivu\n3     8 Kasai oriental\n4     0          Kasai\n\ndata_cases[ , \"region\"]   # values of all rows for the region column\n\n[1] \"Mandoul\"        \"Sud Kivu\"       \"Kasai oriental\" \"Kasai\"         \n[5] \"Haut Katanga\"  \n\n\nNous pouvons même sélectionner plusieurs indices non consécutifs en utilisant un tableau numérique :\n\ndata_cases[c(1, 3), ]  # lines 1 and 3 (all columns)\n\n  cases         region\n1     2        Mandoul\n3     8 Kasai oriental\n\n\nSoyez prudent, car l’option type de sortie renvoyé lors de l’extraction de données d’un cadre de données peut parfois dépendre du style d’indexation utilisé :\n\nstr(data_cases[1 , ])   # returns a data frame\n\n'data.frame':   1 obs. of  2 variables:\n $ cases : num 2\n $ region: chr \"Mandoul\"\n\nstr(data_cases[ , 1])   # returns a simple vector\n\n num [1:5] 2 5 8 0 4\n\n\nAutre syntaxe pour extraire les différentes colonnes d’une base de données :\n\ndata_cases[2]           # returns the second column (as a data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\ndata_cases[\"region\"]    # returns the region column (as a data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\n\nNotez que ces commandes renvoient des cadres de données à une seule colonne.\n\nÉcrire du code pour :\n\nextraire la troisième valeur de la region de votre cadre de données\nextraire les deuxième et troisième valeurs de la colonne cases colonne\ncalculer la somme des cases colonne de votre cadre de données\n:::\n\n\nValeurs manquantes\nEn tant qu’épidémiologistes, nous travaillons constamment avec des données manquantes. Dans R, les valeurs manquantes sont codées à l’aide d’une valeur spéciale : NA (signifiant Not Available). NA est quelque peu unique dans R, car il n’a pas en soi d’objectif fixe. type il prend plutôt le type des valeurs qui l’entourent. Par exemple, un NA dans une colonne numérique prendra alors le type numérique. Nous aborderons la notion de données manquantes de manière plus approfondie dans les sessions ultérieures du cours.\n\n\nLes fonctions\nLes fonctions sont des objets qui contiennent des commandes (au lieu de valeurs) qui sont exécutées chaque fois que la fonction est appelée. Vous connaissez sans doute les fonctions d’Excel telles que SUM ou MEAN et l’idée des fonctions dans R est exactement la même.\nLa plupart des fonctions nécessitent une certaine forme d’entrée, comme un ensemble de données ou un paramètre. Ces entrées sont appelées arguments et sont normalement nommés. Par exemple, lorsque nous avons exécuté sum(cases) nous avons fourni le vecteur cases comme premier (et seul) argument de la fonction sum().\nSouvent, une fonction combinera les deux éléments suivants nécessaire et facultatif facultatifs. Le premier argument d’une fonction est presque toujours obligatoire et est généralement un ensemble de données. En tant qu’argument obligatoire et plutôt évident, la plupart des gens omettent son nom lorsqu’ils appellent une fonction, c’est-à-dire qu’ils écrivent mean(cases) au lieu de mean(x = cases). Les arguments facultatifs, en revanche, sont généralement ajoutés en utilisant leur nom, c’est-à-dire : : mean(x = cases, na.rm = TRUE).\nLes arguments facultatifs ont généralement des valeurs par défaut et nous ne les incluons que lorsque nous voulons modifier leurs valeurs par défaut (et donc modifier le comportement par défaut de la fonction). Par exemple, la fonction na.rm de la fonction mean() détermine si R ignorera les valeurs manquantes lors du calcul d’une moyenne. L’état par défaut de la fonction na.rm est FALSE Ainsi, par défaut, la moyenne calculée sur des données avec des valeurs manquantes renverra toujours NA comme résultat :\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nCeci est vrai pour de nombreuses opérations arithmétiques dans R. Si nous voulons que R calcule la moyenne sur n’importe quelles données est disponibles (et ignorer les valeurs manquantes), nous devons explicitement paramétrer na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nNotez que les arguments sont séparés par des virgules. Ces virgules doivent toujours être suivies d’un espace et chaque fois qu’un argument nommé est utilisé, l’attribut = doit être entouré d’espaces :\n\nmean(cases,na.rm=TRUE)     # BAD\nmean(cases, na.rm = TRUE)  # GOOD\n\nAu fur et à mesure que vous travaillez avec des fonctions de plus en plus complexes, il se peut que vous commenciez à avoir des beaucoup d’arguments. Pour des raisons de lisibilité, il est généralement recommandé de séparer chaque argument sur sa propre ligne :\n\nmean(cases, \n     na.rm = TRUE) \n\n\n\nQue se passe-t-il si nous plaçons les arguments dans le mauvais ordre ? Si vous avez indiqué le nom des arguments dans votre commande, la fonction fonctionnera toujours exactement comme prévu. Ceci étant dit, cela rendrait votre code plus difficile à lire et nous vous encourageons à vous en tenir à un ordre standard en plaçant les arguments obligatoires comme les données en premier.\n\n# technically functional but hard to read:\nmean(na.rm = TRUE,  \n     x = cases) \n\n# better:\nmean(cases,         \n     na.rm = TRUE)\n\nBien entendu, si vous ne respectez pas l’ordre des arguments et des n’a pas n’a pas inclus leurs noms, votre code ne fonctionnera pas comme prévu, voire produira une erreur :\n\nmean(TRUE, cases)   # not what you expect\n\n\n\nTerminé !\nC’est tout pour cette session, félicitations pour vos premiers pas avec R et RStudio !\n\n\n\n Solution File"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-missing-values",
    "href": "sessions_core/01_introduction.html#sec-missing-values",
    "title": "Introduction à R",
    "section": "Valeurs manquantes",
    "text": "Valeurs manquantes\nEn tant qu’épidémiologistes, nous travaillons constamment avec des données manquantes. Dans R, les valeurs manquantes sont codées à l’aide d’une valeur spéciale : NA (signifiant Not Available). NA est quelque peu unique dans R, car il n’a pas en soi d’objectif fixe. type il prend plutôt le type des valeurs qui l’entourent. Par exemple, un NA dans une colonne numérique prendra alors le type numérique. Nous aborderons la notion de données manquantes de manière plus approfondie dans les sessions ultérieures du cours."
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-functions",
    "href": "sessions_core/01_introduction.html#sec-functions",
    "title": "Introduction à R",
    "section": "Les fonctions",
    "text": "Les fonctions\nLes fonctions sont des objets qui contiennent des commandes (au lieu de valeurs) qui sont exécutées chaque fois que la fonction est appelée. Vous connaissez sans doute les fonctions d’Excel telles que SUM ou MEAN et l’idée des fonctions dans R est exactement la même.\nLa plupart des fonctions nécessitent une certaine forme d’entrée, comme un ensemble de données ou un paramètre. Ces entrées sont appelées arguments et sont normalement nommés. Par exemple, lorsque nous avons exécuté sum(cases) nous avons fourni le vecteur cases comme premier (et seul) argument de la fonction sum().\nSouvent, une fonction combinera les deux éléments suivants nécessaire et facultatif facultatifs. Le premier argument d’une fonction est presque toujours obligatoire et est généralement un ensemble de données. En tant qu’argument obligatoire et plutôt évident, la plupart des gens omettent son nom lorsqu’ils appellent une fonction, c’est-à-dire qu’ils écrivent mean(cases) au lieu de mean(x = cases). Les arguments facultatifs, en revanche, sont généralement ajoutés en utilisant leur nom, c’est-à-dire : : mean(x = cases, na.rm = TRUE).\nLes arguments facultatifs ont généralement des valeurs par défaut et nous ne les incluons que lorsque nous voulons modifier leurs valeurs par défaut (et donc modifier le comportement par défaut de la fonction). Par exemple, la fonction na.rm de la fonction mean() détermine si R ignorera les valeurs manquantes lors du calcul d’une moyenne. L’état par défaut de la fonction na.rm est FALSE Ainsi, par défaut, la moyenne calculée sur des données avec des valeurs manquantes renverra toujours NA comme résultat :\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nCeci est vrai pour de nombreuses opérations arithmétiques dans R. Si nous voulons que R calcule la moyenne sur n’importe quelles données est disponibles (et ignorer les valeurs manquantes), nous devons explicitement paramétrer na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nNotez que les arguments sont séparés par des virgules. Ces virgules doivent toujours être suivies d’un espace et chaque fois qu’un argument nommé est utilisé, l’attribut = doit être entouré d’espaces :\n\nmean(cases,na.rm=TRUE)     # BAD\nmean(cases, na.rm = TRUE)  # GOOD\n\nAu fur et à mesure que vous travaillez avec des fonctions de plus en plus complexes, il se peut que vous commenciez à avoir des beaucoup d’arguments. Pour des raisons de lisibilité, il est généralement recommandé de séparer chaque argument sur sa propre ligne :\n\nmean(cases, \n     na.rm = TRUE) \n\n\n\nQue se passe-t-il si nous plaçons les arguments dans le mauvais ordre ? Si vous avez indiqué le nom des arguments dans votre commande, la fonction fonctionnera toujours exactement comme prévu. Ceci étant dit, cela rendrait votre code plus difficile à lire et nous vous encourageons à vous en tenir à un ordre standard en plaçant les arguments obligatoires comme les données en premier.\n\n# technically functional but hard to read:\nmean(na.rm = TRUE,  \n     x = cases) \n\n# better:\nmean(cases,         \n     na.rm = TRUE)\n\nBien entendu, si vous ne respectez pas l’ordre des arguments et des n’a pas n’a pas inclus leurs noms, votre code ne fonctionnera pas comme prévu, voire produira une erreur :\n\nmean(TRUE, cases)   # not what you expect"
  },
  {
    "objectID": "sessions_core/01_introduction.html#terminé",
    "href": "sessions_core/01_introduction.html#terminé",
    "title": "Introduction à R",
    "section": "Terminé !",
    "text": "Terminé !\nC’est tout pour cette session, félicitations pour vos premiers pas avec R et RStudio !\n\n\n\n Solution File"
  }
]