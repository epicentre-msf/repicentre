[
  {
    "objectID": "sessions_core/06_epicurves.html",
    "href": "sessions_core/06_epicurves.html",
    "title": "Introduction to data visualization with ggplot2",
    "section": "",
    "text": "Découvrir les bases de la visualisation de données en R avec le package {ggplot2}\nConstruire une courbe épidémique simple"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#objectifs",
    "href": "sessions_core/06_epicurves.html#objectifs",
    "title": "Introduction to data visualization with ggplot2",
    "section": "",
    "text": "Découvrir les bases de la visualisation de données en R avec le package {ggplot2}\nConstruire une courbe épidémique simple"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#introduction",
    "href": "sessions_core/06_epicurves.html#introduction",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Introduction",
    "text": "Introduction\nPour cette dernière session, nous allons vous donner une courte introduction à la visualisation de données à l’aide du package {ggplot2}, un outil populaire. Gardez en tête que la visualisation de données est un énorme sujet, et {ggplot2} un vaste package et il n’est pas réaliste de tout traiter en trois heures. La session d’aujourd’hui est une introduction que nous espérons douce aux concepts de base de la visualisation, en prenant pour objet un graphe fameux en épidémiologie, la courbe épidémique.\nOur final plot will look like this:"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#setup",
    "href": "sessions_core/06_epicurves.html#setup",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Setup",
    "text": "Setup\nBefore we get into the theory, let’s get your data and script ready.\n\nOuvrez votre projet Rstudio du cours et créez un nouveau script appelé “courbe_epi.R” avec les métadonnées appropriées. Enregistrez le dans R/. Pour cette session, nous aurons besoin de charger les packages {here}, {rio}, {dplyr}, {lubridate}, et{ggplot2}.  Ajoutez une section # IMPORTATION DONNÉES où vous importez les données nettoyées du cours (linelist_moissala_clean_FR.RDS)."
  },
  {
    "objectID": "sessions_core/06_epicurves.html#les-paradigmes-de-la-création-de-graphiques",
    "href": "sessions_core/06_epicurves.html#les-paradigmes-de-la-création-de-graphiques",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Les paradigmes de la création de graphiques",
    "text": "Les paradigmes de la création de graphiques\nIn R, and indeed in everything, there are a loIl y a de nombreuses approches à la visualisation de données, en général et en R en particulier. Les deux plus grands paradigmes sont :\n\nTout en un : cette approche est caractérisée par l’existence d’une fonction (en général complexe) pour gérer tous les aspects de la construction d’un graphique. Base R par exemple, utilise cette approche (et n’est pas le seul).\nGraphiques en couches (ou modulaires) : le graphique est décomposé en éléments (formes, titres, barres d’erreurs, thèmes…) associées à des couches. Différentes fonctions ajoutent ou modifient ces éléments. Ce paradigme est utilisé par les packages {ggplot2}, {highcharter}, ou {echarts4r} et un certain nombre d’outils modernes.\n\nUne discussion approfondie sur les raisons pour lesquelles on peut utiliser une approche plutôt qu’une autre dépasse le cadre de ce cours, mais nous noterons que la plupart des paquets de visualisation modernes ont tendance à utiliser un [modèle en couches] {.hovertip bs-toggle=‘tooltip’ bs-title=“C’est parce que les modèles en couches ont tendance à être plus pratiques lors de la construction de visualisations complexes ou hautement personnalisées.”}. En gardant cela à l’esprit, examinons les types de couches dont nous parlons dans notre approche « en couches ».\n\nDécomposition d’un graphique\nDans ce tutoriel, nous décomposons les graphiques en quatre composantes (couches) :\n\nLe canevas / les données\nLes formes géométriques primaires\nLes titres et labels\nLe thème\n\nOn peut illustrer ces composants avec la courbé épidémique schématique suivante :\n\n\n\nThe main components of a plot\n\n\nLa première couche, le caneva (ou la toile) est fondamentale. Comme un artiste prépare sa toile vierge et ses outils avant de se lancer dans une peinture, R doit en premier lieu créer un canevas prêt à accueillir les éléments de représentation graphique. C’est lors de la création du canevas que nous indiquons à R que nous voulons créer un graphique, et avec quelles variables.\nIci, nous allons spécifier à R que nous voulons un graphique où l’axe horizontal représente la date, et l’axe vertical représente le nombre de cas. Une fois le canevas mise en place, nous ajouterons d’autres couches, comme un artiste ajouterait de la peinture, leur signature ou un cadre.\n\n\nOssature d’un ggplot\nLa recette pour construire un ggplot (un graphe produit par le package {ggplot}) est de la forme suivante :\n\nCréation d’un canevas à l’aide de ggplot(aes(...))\nAjout de couches sur le canevas avec +\n\nNotez que {ggplot2} utilise l’opérateur + pour ajouter des couches sur le graphe.\nLa syntaxe générale d’un ggplot est :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;                    # passer les données\n  ggplot(aes(x = ...,    # étape 1 : créer le canevas\n             y = ...)) +\n  couche_1(...) +        # étape 2 : ajout de la première couche\n  couche_2(...) +        # étape 3 : ajout d'une autre couche\n  ...                    # continuer à ajouter des couches...\n\nLe nombre de couches à ajouter dépend de la complexité du graphique que vous souhaitez créer. Dans notre cas, nous ajouterons trois couches en utilisant les fonctions suivantes :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;                    # passer les données\n  ggplot(aes(x = ...,    # étape 1 : créer le canevas\n\n             y = ...)) +\n  geom_col(...) +        # étape 2 : ajout des formes (barres)\n  labs(...) +            # étape 3 : ajouter des titres\n  theme_classic(...)     # étape 4 : amélioration du thème\n\nNous pouvons mettre à jour notre précédent schéma avec ces fonctions :\n\n\n\nThe main components of a plot, with their associated functions\n\n\n\n\n\n\n\n\nNote\n\n\n\nDans l’exemple précédent, nous passons le jeu de données à la fonction ggplot() à l’aide de l’opérateur pipe (comme nous l’avons souvent fait avec d’autres fonctions). C’est possible car le premier argument nécessaire de la fonction est le dataframe contenant les variables à représenter. Soyez attentifs, il est facile de se tromper et de chercher à utiliser un + à la place du |&gt;\n\n\nDans la section suivante, nous allons décrire les différentes étapes plus en détail, en utilisant notre jeu de données rougeole à Moissala pour faire notre première courbe épidémique."
  },
  {
    "objectID": "sessions_core/06_epicurves.html#sec-epicurve-steps",
    "href": "sessions_core/06_epicurves.html#sec-epicurve-steps",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Votre premier ggplot",
    "text": "Votre premier ggplot\n\nPréparer vos données : Agrégation par jour\nNous aimerions tracer une courbe des cas quotidiens. Vous l’aurez peut-être remarqué, nos données actuelles sont quotidiennes, mais il est évident que plusieurs cas peuvent se produire certains jours. Donc,il faut agréger les données par jour. Heureusement, vous avez déjà appris à résumer les données lors des sessions précédentes.\n\nEn utilisant count(), créez un nouveau dataframe appelé df_cases qui résume le nombre total de cas observés par jour. L’en-tête de ce cadre de données devrait ressembler à ceci :\n\n\n  date_debut n\n1 2022-08-13 1\n2 2022-08-17 1\n3 2022-08-18 1\n4 2022-08-22 1\n5 2022-08-30 2\n6 2022-09-01 1\n\n\n\nBien !\nDans les étapes suivantes, vous allez utiliser df_cas pour tracer une courbe épidémique du nombre de cas par semaine. En revanche, les exemples données dans les exercices pour illustrer le fonctionnement des fonctions seront faits sur le nombre de hospitalisations par semaine. Pour cela, j’utiliserai un dataframe df_hopital, qui ressemble à ceci :\n\n\n  date_admission patients\n1     2022-08-14        1\n2     2022-08-25        1\n3     2022-09-02        1\n4     2022-09-06        1\n5     2022-09-09        1\n6     2022-09-10        1\n\n\n\n\nEtape 1 : Créer le canevas\nLa première étape est de créer votre “canevas” en spécifiant votre jeu de données et le nom des colonnes que vous voulez représenter sur le graphique. Cela est fait à l’aide de la fonction ggplot(aes()) selon la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_data |&gt;\n  ggplot(aes(x = x_axis_variable_name,\n             y = y_axis_variable_name))\n\nPour l’exemple, je vais placer la date (date_admission) sur l’axe des x et le nombre de patients (patients) sur l’axe des y :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients))\n\n\n\n\n\n\n\n\nDans Rstudio, ce graphique devrait apparaître dans l’onglet “Plots” dans le panneau en bas à droite (par défaut) :\n\n\n\nThe plot pannel in RStudio IDE\n\n\n\n\n\n\n\n\nNote\n\n\n\nJust like with {dplyr}, we write our column names without quotation marks. This is unsurprising as {ggplot2}, like {dplyr}, is a member of the {tidyverse} and therefore uses similar syntax.\n\n\nQu’est ce que cette fonction aes() que nous avons imbriqué dans la fonction ggplot() ?\nLa fonction aes() n’est jamais utilisée seule, elle est toujours passée à ggplot(). Elle sert à faire correspondre les variables du jeu de données aux éléments visuels du graphique (en anglais on parle de “mapping”, qui est occasionnellement traduit par “mappage”). Les plus basiques de ces éléments graphiques sont les axes, mais on peut aussi définir comment la couleur ou la taille d’éléments varie en fonction de variables dans les données (par exemple, statut à la sortie).\n\nCréez une nouvelle section # PLOT COURBE EPI. Ensuite, en vous inspirant de l’exemple précédent, créez la base d’un ggplot avec le dataframe df_cas, et définissez l’axe des x et des x.\n\nPour le moment, le résultat devrait ressembler à ceci :\n\n\n\n\n\n\n\n\n\nTrès bien. Maintenant, ajoutons les barres\n\n\nEtape 2 : Ajouter les formes\nMaintenant que la toile est prête, commençons à dessiner dessus, et ajoutons des formes. Dans {ggplot2}, les formes géométriques sont surnommées des “géométries” ou “geom” en raccourci, et représentent les données. Les geoms les plus courants sont :\n\nDiagrammes en bâtons (geom_col() or geom_bar())\nHistogrammes (geom_histogram())\nNuages de points(geom_point())\nCourbes(geom_line())\nDiagramme en boîte à moustache (boxplots) (geom_boxplot())\n\nAujourd’hui nous allons nous concentrer sur les diagrammes en bâton, pour créer une courbe épidémique. Nous allons utiliser la fonction geom_col().\nNous allons maintenant rajouter les barres à la courbe des cas hospitalisés. Rappelez-vous que l’on ajoute une nouvelle couche à notre objet ggplot à l’aide de +.\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col()\n\n\n\n\n\n\n\n\nC’est génial, cela ressemble vraiment à une épicurve. Bien qu’elle ait l’air un peu… grise. Si nous voulons mettre à jour la couleur de nos barres (appelée le fill), nous devons simplement ajouter l’argument fill to geom_col().\nFaisons un essai :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\")\n\n\n\n\n\n\n\n\n\nMettez à jour votre graphe pour ajouter les barres avec la couleur #2E4573.\n\nVotre graphe devrait ressembler à ceci :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDans {ggplot2}, les couches doivent être ajoutées à un objet ggplot existant (le canevas définit à l’étape 1). Exécuter la fonction geom_col() toute seule ne produira pas un graphe. Si l’on reprend notre analogie avec la peinture, ce serait comme essayer d’utiliser la peinture sans support (toile).\n\n\nCe graphe s’améliore d’instant en instant ! Maintenant il est temps de le rendre un petit peu plus informatif…\n\n\nAjouter les titres\nUn bon graphique doit avoir des titres et des labels informatifs or pour le moment, ce n’est pas le cas de nos graphiques (n n’est pas très informatif).\nLa fonction lab() permet d’ajouter des titres et labels à plusieurs éléments du graphique :\n\nTitre des axes (x = ety =)\nTitre du graphique (title =)\nCaption\n\nComme avec les autres couches, nous pouvons ajouter la couche contenant les titres et labels à notre graphe avec le signe + :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la région de Madoul (Tchad)\")\n\n\n\n\n\n\n\n\n\nAjoutez des titres raisonnables à votre graphe.  Bonus. Ajoutez une source des données en utilisant caption.\n\nVotre graphe pourrait maintenant ressembler à celle-ci (par exemple) :\n\n\n\n\n\n\n\n\n\n\n\nChanger le thème\nLe thème de base de ggplot n’est pas très attractif, et la taille des polices est trop petite pour être lisible sur la majorité des supports. Si vous voulez utiliser votre graphique dans des rapports ou des présentations, il vaudrait mieux améliorer son apparence.\nPour cela, il suffit d’ajouter une couche “thème” à notre graphe (la dernière couche pour aujourd’hui !). Si le nom des fonctions des geoms commençait toujours par geom_, le nom de toutes les fonctions de thème commence par theme_. Il existe plusieurs thèmes prédéfinis, et vous pouvez aller les regarder sur le site de {ggplot2}.\nAujourd’hui, nous allons utiliser theme_classic(), qui offre une alternative élégante au thème de base :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la région de Madoul (Tchad)\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nC’est déjà plus joli. Maintenant, nous voudrions augmenter la taille de la police. Nous pouvons faire ça en ajustant la taille de la police à l’aide de l’argument base_size:\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la région de Madoul (Tchad)\") +\n  theme_classic(base_size = 17)\n\n\n\n\n\n\n\n\n’est beaucoup mieux !\nRappelez-vous que la taille de la police doit être choisie en fonction de la destination du graphe (présentation, rapport informel, rapport final ?). Il en va de même pour le choix du thème, qui reste un choix partiellement subjectif. Il existe des principes de visualisation qui peuvent guider vos choix lors de la création d’un graphe (ou d’une table), mais la visualisation de données est autant un art qu’une science.\n\nAjoutez une dernière couche à votre graphe pour ajouter un thème de votre choix, avec une taille de police plus appropriée.\n\n\n\nSauvegarder votre graphique\nSi vous souhaitez enregistrer votre graphe, vous pouvez cliquer sur le bouton « Exporter » dans le panneau de tracé de RStudio :\n\n\n\nBouton d’enregistrement du tracé dans le panneau de tracé de RStudio"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#la-fin",
    "href": "sessions_core/06_epicurves.html#la-fin",
    "title": "Introduction to data visualization with ggplot2",
    "section": "La Fin !",
    "text": "La Fin !\nBravo! Vous avez créé votre première courbe épidémique en R !\n\n\n\n Solutions file\n\n\n\n\nExercices supplémentaires\n\nCréez plutôt une courbe de la date de consultation. N’oubliez pas de mettre à jour les titres et les légendes.\nUtilisez le theme_minimal() sur un de vos graphiques, avec une police de taille de base de 18.\nAllez sur ce site), choisissez une couleur et mettez à jour la couleur de vos barres.\n\n\n\nExercices de défi\n\nAu lieu d’agréger par date, comptez le nombre de patients par sous-préfecture. Essayez d’adapter votre code pour créer un diagramme à barres du nombre de patients par sous-préfecture."
  },
  {
    "objectID": "sessions_core/06_epicurves.html#ressources",
    "href": "sessions_core/06_epicurves.html#ressources",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Ressources",
    "text": "Ressources\n\nUn livre complet sur l’utilisation de {ggplot2}.\n\nUn chapitre entier sur les épicurves"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html",
    "href": "sessions_core/04_data_verbs_conditional.html",
    "title": "Traitement de données, recoder et filtrer",
    "section": "",
    "text": "Dans la session précédente vous avez appris les bases du traitement de données en R avec les fonctions du {tidyverse}, en particulier comment sélectionner et modifier les colonnes d’un data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre à :\n\nÉcrire des conditions logiques basiques, ce qui va nous permettre de :\nSélectionner des lignes d’un data frame avec filter()\nRecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "href": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "title": "Traitement de données, recoder et filtrer",
    "section": "",
    "text": "Dans la session précédente vous avez appris les bases du traitement de données en R avec les fonctions du {tidyverse}, en particulier comment sélectionner et modifier les colonnes d’un data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre à :\n\nÉcrire des conditions logiques basiques, ce qui va nous permettre de :\nSélectionner des lignes d’un data frame avec filter()\nRecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "href": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Mise en place",
    "text": "Mise en place\nPrérequis : cette leçon part du principe que vous connaissez les bases de la manipulation de données avec {dplyr}, et en particulier la fonction mutate(). Aller vous rafraîchir si besoin.\n\nNous utiliserons la liste linéaire avec les données brutes qui peut être téléchargée ici :\n\n\n\n Télécharger les données\n\n\n\n Si ce n’est pas déjà fait, enregistrez la dans le sous-dossier approprié de votre projet RStudio puis créez un nouveau script appelé filtrer_recoder.R dans votre sous-dossier R. Ajoutez un en-tête approprié et chargez les paquets suivants : {here}, {rio} et {tidyverse}.  Enfin, ajoutez une section dédiée à l’import des données, utilisez {here} et {rio} pour importer vos données dans R, et assignez-les à un objet que nous appellerons df_brut"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#filtrer-des-données-avec-des-conditions-logiques",
    "href": "sessions_core/04_data_verbs_conditional.html#filtrer-des-données-avec-des-conditions-logiques",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Filtrer des données avec des conditions logiques",
    "text": "Filtrer des données avec des conditions logiques\nNous avons appris précédemment comment comment sélectionner les colonnes d’un data frame. Nous allons à présent apprendre la tâche complémentaire, qui est la sélection des lignes d’un data frame. C’est une tâche particulièrement courante du travail d’épidémiologiste qui permet de sélectionner des observations qui satisfont à certains critères. Le paquet {dplyr} possède bien évidement une fonction pour ça, la fonction filter().\nAvant de pouvoir l’utiliser nous allons néanmoins devoir apprendre à écrire des conditions logique, qui sont également un prérequis pour recoder des variables. Les conditions logiques sont des questions (ou tests) auxquelles R va répondre par TRUE ou FALSE (ou NA).\n\nEgalité\nLa syntaxe de filter() est assez simple :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition_logique])\n\nCette syntaxe permet de conserver les lignes où condition_logique est vraie. Ici, la condition logique va demander si quelque chose est égale à autre chose. Par exemple, si telle variable est égale à telle valeur (est ce que patient a été hospitalisé ?). En R, nous testons l’égalité avec l’opérateur ==.\nEn pratique, pour créer un filtre qui ne garde que les patients hospitalisés nous écrivons :\n\ndf_brut |&gt;\n  filter(hospitalisation == \"oui\")\n\nIci, filter() parcourt chaque ligne de notre data frame et teste si la valeur d’hospitalisation dans cette ligne est égale à \"oui\". La fonction ne renvoie alors que les lignes où la réponse à la question est TRUE [vrai].\n\nFiltrez vos données pour ne conserver que les patients qui avaient de la fièvre (c’est à dire les patients contenant la valeur \"Yes\" dans la colonne fievre. Le début de la colonne fievre dans la sortie filtrée est :\n\n\n  fievre\n1    Yes\n2    Yes\n3    Yes\n4    Yes\n5    Yes\n6    Yes\n\n\nInspectez la sortie et df_brut. Pourquoi df_brut contient-il encore les patients qui n’avaient pas de fièvre ?\n\n\n\nInégalité\nParfois, nous préférons tester l’inégalité plutôt que l’égalité ; pour examiner les patients qui ne se sont pas rétablis, par exemple, qu’ils soient décédés ou sorti contre avis médical. Dans ce cas nous utiliserons l’opérateur !=, ce qui donne ce code :\n\ndf_brut |&gt;\n  filter(issue != 'gueri') # Garde les lignes avec patients NON guéris\n\n\nFiltrez votre data frame pour ne montrer que les patients qui n’ont pas de carte confirmant leur statut vaccinal. Le début de la colonne filtrée ressemble à :\n\n\n  statut_vaccinal\n1             Non\n2             Non\n3             Non\n4             Non\n5             Non\n6             Non\n\n\nAstuce : Rappelez-vous que vous pouvez utiliser count() pour vérifier les modalités de statut_vaccinal.\n\n\n\nSupérieur à / Inférieur à\nDans le cas des variables numériques, on sera souvent intéressé par savoir si une valeur est supérieure ou inférieure à un seuil. Par exemple, quels sont les patients de moins de 5 ans. Ici, nous utiliserons les opérateurs &lt; et &gt; pour évaluer si une variable est inférieure à ou supérieure à une valeur donnée, respectivement.\nNous pouvons par exemple filtrer les patients de moins de 60 mois :\n\ndf_brut |&gt;\n  filter(age &lt; 60)\n\n\nAffichez un data frame ne contenant que les patients souffrant de malnutrition aiguë sévère. Le début de la colonne concernée est :\n\n\n    pb\n1  244\n2  232\n3  123\n4  210\n5   80\n6  220\n7  152\n8  155\n9  232\n10 135\n\n\nEcrivez un autre filtre qui sélectionne les patients âgés de plus de 15 ans. L’en-tête de votre colonne d’âge doit ressembler à ceci :\n\n\n  age\n1 348\n2 348\n3 312\n4 432\n5 444\n6 324\n\n\n\nSi nous ne voulons pas l’égalité stricte nous pouvons ajouter un signe égal aux opérateurs précédents, ce qui donne &lt;= pour “inférieur ou égal à” et &gt;= pour “supérieur ou égal à”. Attention, le = doit venir après les opérateurs &lt; et &gt;, pas avant.\nPour filtrer les patients avec 10 ans ou moins :\n\ndf_brut |&gt;\n  filter(age &lt;= 120)\n\n\nSélectionnez tous les patients avec un état nutritionnel normal, c’est-à-dire les patients dont le PB est supérieur ou égal à 125mm. L’en-tête du pb devrait ressembler à ceci :\n\n\n    pb\n1  244\n2  232\n3  210\n4  220\n5  152\n6  155\n7  232\n8  135\n9  146\n10 202\n\n\n\n\n\nConditions multiples\nIl est possible de combiner plusieurs conditions logiques dans un même filtre ! Il suffit de séparer plusieurs conditions logiques par une virgule.\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition 1],\n         [condition 2],\n         [condition 3])\n\nPar exemple, nous pourrions sélectionner tous les patients hospitalisés de moins de cinq ans :\n\ndf_brut |&gt;\n  filter(age &lt; 5,\n         hospitalisation == \"oui\")\n\n\nCréez un filtre qui sélectionne tous les patients de la sous-préfecture de Koumra hospitalisés et sévèrement malnutris Cela donne :\n\n\n    id sous_prefecture hospitalisation  pb\n1 8624          KOUMRA             oui 103\n2 8939          KOUMRA             oui  67\n3 9957          KOUMRA             oui  71\n\n\nIndice :  if faut une condition sur le statut d’hospitalisation, une sur la sous-préfecture et une sur le PB.\n\n\n\nRésumé des conditions logiques\nNous avons fait le tour des conditions logiques les plus basiques en R. Les voici rassemblées dans un tableau pour références futures :\n\n\n\nCondition\nR\n\n\n\n\nA identique à B ?\nA == B\n\n\nA pas identique à B ?\nA != B\n\n\nA supérieur à B ?\nA &gt; B\n\n\nA supérieur ou égal à B ?\nA &gt;= B\n\n\nA inférieur à B ?\nA &lt; B\n\n\nA inférieur ou égal à B ?\nA &lt;= B"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "href": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Recoder des variables avec case_when()",
    "text": "Recoder des variables avec case_when()\nL’utilité des conditions logiques dans le traitement de données va bien plus loin que la sélection de lignes ! Elles sont par exemple très utiles quand nous voulons recoder des variables. Nous utiliserons les conditions logiques à l’intérieur de la fonction case_when() (également du paquet {dplyr}) pour recoder les variables.\nLa fonction case_when() est un peu plus complexe que ce que l’on a vu jusqu’à présent, mais très puissante (et va donc vous être très utile). Nous allons décomposer sa syntaxe pas à pas.\nVous utiliserez presque toujours case_when() dans un mutate() pour recoder une variable existante ou en créer une nouvelle, avec cette syntaxe :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  mutate(nouvelle_colonne = case_when(\n    [condition_1] ~ [valeur_si_condition_1_est TRUE],\n    [condition_2] ~ [valeur_si_condition_2_est TRUE],\n    .défaut = [valeur_par_défaut]))\n\nDécomposons-la commande.\nA l’exception de la dernière ligne, chaque ligne à l’intérieur de la fonction case_when() a le format suivant :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n[condition] ~ [valeur si condition est VRAIE]  # Les crochets sont là pour la lisibilité\n\nAinsi, pour recoder les patients avec un PB inférieur à 110mm comme \"MAS\", nous écrivons la commande suivante dans notre case_when() :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n# [condition] ~ [valeur si VRAIE]\n   pb &lt; 110   ~ \"MAS\"\n\nIl y a en général plus d’une condition ! Dans notre exemple, une autre condition logique testerait si le patient est modérément malnutri avec l’instruction pb &lt; 125 ~ \"MAM\".\nLa dernière ligne de notre pseudo code contient l’argument .default et sert à fournir la valeur à utiliser lorsqu’aucune des conditions n’est remplie. Dans notre exemple, ça pourrait être \"Normal\".\nPour résumer, pour résumer, pour créer une variable contenant le statut nutritionnel à partir du PB :\n\ndf_brut |&gt;\n  mutate(malnut = case_when(\n    pb &lt; 110 ~ \"MAS\",\n    pb &lt; 125 ~ \"MAM\",\n    .default = \"Normal\"))\n\n\nExécutez le code ci-dessus pour créer une variable malnut contenant le statut nutritionnel des patients. Le haut des deux colonnes concernées renvoie :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAS\n6 220 Normal\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nL’ordre des conditions logiques est important ! case_when() teste les conditions dans l’ordre que vous lui donnez et attribue une valeur dès qu’une condition est TRUE.\nAinsi, dans l’exemple ci-dessus, case_when() pose ces questions suivantes dans l’ordre :\n\nEst-ce que pb &lt; 110 pour ce patient ? Si oui, attribuer la valeur \"MAS\"\nSi le patient n’est pas MAS, est-ce que pb &lt; 125 ? Si oui, attribuer la valeur \"MAM\"\nSi aucune des conditions précédentes n’est vraie, attribuer la valeur \"Normal\"\n\n\n\n\nIntervertissez l’ordre des deux premières conditions dans le case_when()précédent (pb &lt; 125 testé en premier). Le haut des deux colonnes concernées est maintenant :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAM\n6 220 Normal\n\n\nVous pouvez enregistrer le data frame crée dans un objet temporaire temp pour l’inspecter plus facilement. Où sont les patients MAS ? Comprenez-vous ce qui s’est passé ?\n\n\n\n\n\n\n\nNote\n\n\n\nL’argument .default dans case_when() n’est pas obligatoire. Si vous ne l’incluez pas, case_when() utilisera la valeur NA par défaut.\n\n\nDans notre exemple, nous avons utilisé case_when() pour créer une variable catégorique (le statut nutritionnel) à partir d’une variable continue (le PB). Un autre exemple typique et similaire est de créer une colonne contenant les classes d’âge.\n\nUtilisez case_when() pour créer une variable groupe_age avec les catégories suivantes :\n\n\"&lt; 5 Ans\"\n\"5 - 15 Ans\"\n\"&gt; 15 Ans\".\nsi l’âge est manquant, attribuer la valeur \"Inconnu\".\n\nFaites attention à l’ordre ! L’en-tête des colonnes concernées doit ressembler à ceci :\n\n\n   age  age_group\n1   36    &lt; 5 Ans\n2    5    &lt; 5 Ans\n3  156 5 - 15 Ans\n4    8    &lt; 5 Ans\n5    7    &lt; 5 Ans\n6    4    &lt; 5 Ans\n7    2    &lt; 5 Ans\n8   48    &lt; 5 Ans\n9  156 5 - 15 Ans\n10 348   &gt; 15 Ans\n\n\n\n\nL’opérateur %in%\nNous savons maintenant recoder les variables en catégories, ce qui vous arrivera très souvent en épidémiologie. Un autre cas d’usage majeur est d’utiliser case_when() pour standardiser les valeurs d’une variable.\n\nUtilisez count() pour inspecter les variables catégorielles de votre jeu de données. Lesquelles devraient être standardisées ?\n\nVous avez dû voir que la variable sexe présente quelques problèmes d’encodage. Par exemple, les patientes sont codées comme f, female et femme. Utilisons case_when() pour recoder cette variable. Ici, nous ne créerons pas une nouvelle variable, mais remplacerons la variable existante :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(sexe == \"f\"      ~ \"Femme\",\n                          sexe == \"female\" ~ \"Femme\",\n                          sexe == \"femme\"  ~ \"Femme\",\n                          sexe == \"h\"      ~ \"Homme\",\n                          sexe == \"male\"   ~ \"Homme\",\n                          sexe == \"homme\"  ~ \"Homme\",\n                          .default = \"Inconnu\"))\n\nCe code fonctionne correctement mais est terriblement répétitif et verbeux. Heureusement il y a un raccourci pour lister toutes les options à réaffecter à “Femme” (et celles à “Homme”), l’opérateur %in% ! L’opérateur %in% permet de tester la condition “est ce que la valeur existe dans ce vecteur ?”.\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\n[valeur] %in% [vector_des_options]\n\nAinsi, par exemple, nous pourrions vérifier si la valeur “f” est dans les options “f” et “femme” :\n\n\"f\" %in% c(\"f\", \"femme\")\n\n\nExécutez l’instruction ci-dessus. Quel est le type de données de votre résultat ?\n\nLa commande renvoie un bolléen, c’est-à-dire un résultat logique. C’est donc une condition logique valide à utiliser dans un case_when() (ou un filter()) ! On peut donc simplifier notre code :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(\n    sexe %in% c(\"f\", \"female\", \"femme\") ~ \"Femme\",\n    sexe %in% c(\"h\", \"male\", \"homme\") ~ \"Homme\",\n    .default = \"Inconnu\"))\n\nC’est plus court comme ça…\n\nUtilisez case_when() et l’opérateur %in% pour créer une nouvelle colonne vacc_status_strict qui a la valeur :\n\n\"Oui\" si le statut vaccinal est confirmé\n\"Non\" pour les cas non vaccinés\n\n\"Non vérifié\" sinon.\n\nLa tête de la nouvelle colonne ressemble à ceci :\n\n\n  statut_vaccinal statut_vaccinal_strict\n1            &lt;NA&gt;            Non vérifié\n2             Non                    Non\n3      Oui - oral            Non vérifié\n4             Non                    Non\n5             Non                    Non\n6             Non                    Non"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-données",
    "href": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-données",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Pipeline de nettoyage des données",
    "text": "Pipeline de nettoyage des données\nMaintenant que vous savez utiliser les conditions logiques pour recoder colonnes avec case_when(), nous pouvons reprendre le pipeline de nettoyage que nous avions commencé dans la session précédente.\n\nReprenez, le code de la session précédente, amendez-le et complétez le pour créer un gros pipeline de nettoyage des données, qui crée un data frame df_linelist en effectuant les opérations suivantes :\n\nSupprimer les variables nom_complet et unite_age\nRenommer les variables suivantes :\n\nage devient age_ans\nsous_prefecture devient prefecture\nvillage_commune devient village\nnom_structure_sante devient structure\n\nAjouter une variable age_ans avec l’âge du patient en années\nMettre à jour region et prefecture pour utiliser la casse de titre\nMettre à jour toutes les colonnes contenant des dates pour utiliser le type Date\nCréer une nouvelle variable groupe_age avec les groupes &lt; 6 mois, 6 - 11 mois, 12 - 59 mois, 5 - 15 ans et &gt; 15 ans (les patients dont l’âge est inconnu sont Inconnu)\nRecoder le sexe pour n’avoir que les valeurs : Femme, Homme et Inconnu\n\nSupprimer toutes les lignes en double\n\nLe début de vos données finales devrait ressembler à ceci :\n\n\n  id  sexe age_mois  region prefecture        village date_debut\n1  1 Femme       36 Mandoul   Moissala Sangana Koïtan 2022-08-13\n2  2 Femme        5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3 Femme      156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 Homme        8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7 Homme        7 Mandoul   Moissala      Tétindaya 2022-08-30\n6 10 Homme        4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             oui     2022-08-14\n2        2022-08-25             oui     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25             non           &lt;NA&gt;\n5        2022-09-02             non           &lt;NA&gt;\n6        2022-09-02             oui     2022-09-02\n                        structure tdr_paludisme fievre eruption toux\n1 Hôpital du District de Moissala       negatif     No     &lt;NA&gt;  Yes\n2 Hôpital du District de Moissala       negatif     No       No  Yes\n3                      CS Silambi       negatif    Yes     &lt;NA&gt;   No\n4 Hôpital du District de Moissala       negatif     No       No   No\n5                      CS Silambi       negatif   &lt;NA&gt;       No  Yes\n6                    Moissala Est       negatif    Yes       No   No\n  yeux_rouges pneumonie encephalite  pb statut_vaccinal doses_vaccin issue\n1          No        No          No 244            &lt;NA&gt;         &lt;NA&gt; gueri\n2          No      &lt;NA&gt;          No 232             Non         &lt;NA&gt;  &lt;NA&gt;\n3          No        No        &lt;NA&gt; 123      Oui - oral         &lt;NA&gt; gueri\n4        &lt;NA&gt;        No          No 210             Non         &lt;NA&gt; gueri\n5         Yes        No          No  80             Non         &lt;NA&gt; gueri\n6        &lt;NA&gt;        No          No 220             Non         &lt;NA&gt; gueri\n  date_issue    age_ans   groupe_age\n1 2022-08-18  3.0000000 12 - 59 mois\n2 2022-08-28  0.4166667     &lt; 6 mois\n3       &lt;NA&gt; 13.0000000   5 - 15 ans\n4       &lt;NA&gt;  0.6666667  6 - 11 mois\n5       &lt;NA&gt;  0.5833333  6 - 11 mois\n6 2022-09-03  0.3333333     &lt; 6 mois\n\n\n\nTop ! Nous pouvons maintenant exporter ce data frame (presque) propre hors de R. Pour cela nous utiliserons la fonction export() de {rio} (et notre fidèle compagnon, la fonction here() de {here} pour gérer les chemins d’accès) :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.xlsx'))\n\nNotez ici que nous plaçons nos données dans le sous-dossier clean dans data.\n\n\n\n\n\n\nAstuce\n\n\n\nEnregistrer les données au format .xlsx est utile pour pouvoir les ouvrir dans Excel pour les inspecter ou les partager. Cependant, nous préférerons souvent utiliser un fichier avec l’extension .rds. Ce type de fichier est spécifique à R et est plus robuste aux problèmes liés à l’encodage ou au formatage des dates que les fichiers de type .xlsx ou .csv.\nPour exporter votre data frame vers un fichier .rds, il suffit de modifier l’extension :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.rds')) # TADAM !"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "href": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "title": "Traitement de données, recoder et filtrer",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo. Lors des deux dernières sessions vous avez appris à utiliser les fonctions qui forment le socle du traitement de données, mais aussi les conditions logiques et comment organiser votre code en un pipeline de nettoyage !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "href": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "title": "Traitement de données, recoder et filtrer",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires\n\nConditions : Si nous créons les deux vecteurs suivants :\n\n\nvec1 &lt;- c(1, 2, 3, 4, 5)\nvec2 &lt;- c(1, 3, 4, 2, 5)\n\nEffectuez les tests suivants :\n\nEst-ce que vec1 est égal à vec2 ? La sortie devrait être TRUE, FALSE, FALSE, FALSE, TRUE.\nEst-ce que les valeurs de vec1 sont supérieures ou égales à vec2 ? La sortie devrait être TRUE, FALSE, FALSE, TRUE, TRUE.\nEst-ce que les valeurs de vec1 existent à n’importe quel endroit de vec2 ? La sortie devrait être TRUE, TRUE, TRUE, TRUE, TRUE.\nEst-ce que les valeurs de vec2 sont NA ? Indice : vous devez utiliser la fonction is.na().\n\n\nEcrivez une commande pour tester si la structure de santé “Moissala Ouest” est présente dans la liste linéaire.\nFiltrer : créez des data frames qui ne contiennent que les lignes suivantes :\n\nPatients de la sous-préfecture de Bedaya\nPatients sans fièvre\nPatients qui ont testé négatif au test palu\nPatients sans information manquante dans la colonne fièvre\nPatients hospitalisés en 2023\nPatients de 15 ans ou plus hospitalisés\nPatients habitant à Moissala, hospitalisés dans l’hôpital Moissala Est avant le 1er février 2023\nEnfants de moins de cinq ans souffrant de malnutrition aigüe sévère\n\nNettoyage : ajoutez des étapes à votre chaîne / pipeline de nettoyage\n\nPassez les colonnes hospitalisation et tdr_paludisme en casse titre\nRecodez la colonne issue pour homogénéiser les catégories et ne garder que “Décédé”, “Guéri” et “Perdu de vue”\nCréez une colonne est_mort qui contient TRUE si le patient est décédé et FALSE sinon\nCréez une colonne statut_vaccinal_simple qui simplifie la colonne statu_vaccinal et ne contient que les modalités “Oui”, “Non”, “Inconnu”\n\nSimplification du code : le code suivant s’exécute sans erreurs, mais pourrait être raccourci car l’auteur n’a pas pris en compte certaines des propriétés de case_when(). Simplifiez la commande. N’oubliez pas de vérifier à la fin que vous obtenez le même résultat !\n\n\ndf %&gt;% \n  mutate(groupe_age2 = case_when(\n    age_mois &lt; 6 ~ \"&lt; 6 mois\",\n    age_mois &gt;= 6 & age_mois &lt; 12  ~ \"6 - 11 mois\",\n    age_mois &gt;= 12 &  age_mois &lt; 59 ~ \"12 - 59 mois\",\n    age_ans &gt;= 5 & age_ans &lt;= 15 ~ \"5 - 15 ans\",\n    age_ans &gt; 15 ~ \"&gt; 15 ans\",\n    is.na(age_ans) ~ \"Inconnu\",\n    is.na(age_mois)  ~ \"Inconnu\",\n    .default = \"Inconnu\")\n  )\n\n\nCorriger : quelqu’un a tenté de corriger le code ci-dessus, mais a commis quelques erreurs (vicieuses, elles n’empêchent pas la commande de s’exécuter, mais le résultat est faux !). Essayez de les corriger. Vous savez que vous avez tout corrigé quand vous obtenez le même résultat qu’auparavant.\n\n\ndf %&gt;% \n  mutate(groupe_age2 = case_when(\n    age_mois &lt;= 6 ~ \"&lt; 6 mois\",\n    age_mois &lt; 11 ~ \"6 - 11 mois\",\n    age_ans &lt; 5 ~ \"12 - 59 mois\",\n    age_ans &lt;= 15 ~ \"5 - 15 ans\",\n    age_ans &gt;= 15 ~ \"&gt; 15 ans\",\n    .default = \"Inconnu\")\n  )\n\n\n\nDéfis\n\nEnregistrez un fichier .csv sur votre ordinateur qui contient les données nettoyées pour les patients habitant Bouna et hospitalisés en 2022.\nAffichez un data frame contenant le nombre de participants venant de la sous-préfecture de Moissala et qui ont été hospitalisés dans une des structures de Moissala (pour faire simple, les structures avec “Moissala” dans leur nom).\n\n\n\n\n\n\n\nAstuce\n\n\n\nPour la dernière étape, vous pouvez utiliser l’opérateur %in% que l’on a vu dans cette session ou aller lire la page d’aide de la fonction str_detect() et tenter de l’utiliser à l’intérieur de la fonction filter().\n\n\nLa sortie ressemble à ceci :\n\n\n                        structure   n\n1 Hôpital du District de Moissala 304\n2                    Moissala Est 296\n3                   Moissala Nord 323\n4                    Moissala Sud 281\n\n\n\nCréez un fichier Excel qui contient la liste de tous les patients qui sont présents plus d’une fois dans vos données nettoyées. Pourquoi ces patients doivent-ils probablement être examinés de plus près ?\n\n\n\n\n\n\n\nAstuce\n\n\n\n\n\nPour faire ça vous avez besoin des fonctions count(), filter() et export() + here()."
  },
  {
    "objectID": "sessions_core/02_import_data.html",
    "href": "sessions_core/02_import_data.html",
    "title": "Importer des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets dans la session\nEcrire des chemins d’accès aux fichiers robustes\nImporter et inspecter des données dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des données s’appliquent aussi à votre code : on souhaite écrire un script qui fonctionne maintenant, mais également dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider à aller dans cette direction, et la première est d’avoir un code source propre et bien organisé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#objectifs",
    "href": "sessions_core/02_import_data.html#objectifs",
    "title": "Importer des données",
    "section": "",
    "text": "Créer un projet RStudio\nMettre en place un code organisé et bien documenté\nInstaller et charger des paquets dans la session\nEcrire des chemins d’accès aux fichiers robustes\nImporter et inspecter des données dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des données s’appliquent aussi à votre code : on souhaite écrire un script qui fonctionne maintenant, mais également dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider à aller dans cette direction, et la première est d’avoir un code source propre et bien organisé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "href": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "title": "Importer des données",
    "section": "Mise en place du projet",
    "text": "Mise en place du projet\n\nStructure des dossiers\n\nSi ce n’est pas déjà fait, téléchargez le dossier du cours décompressez-le. Sauvegardez le dossier non compressé à un endroit non connecté à OneDrive et ouvrez-le.\n\n\n\n  Dossier du cours\n\n\n\n\nCe dossier illustre une structure typique et recommandée pour vos projets de code :\n\n📁 data\n\n📁 raw\n📁 clean\n\n📁 R\n📁 outputs\n\nCe dossier sera votre répertoire de travail pour toutes les sessions de ce cours. Vous y créerez un projet RStudio (explications ci-dessous), et y enregistrerez tous vos scripts (sous dossier R). Les données brutes se trouvent déjà dans data/raw.\n\n\nDéfinitions\nVoici deux concepts importants que nous allons rencontrer dans cette session :\nRépertoire de travail. Le répertoire de travail est l’emplacement (dossier) où votre session R en cours travaille. Si vous enregistrez un fichier, par exemple, il sera enregistré dans ce dossier par défaut. De même, Si vous ouvrez un fichier, ce dossier sera affiché par défaut. Tous les chemins relatifs auront ce dossier pour origine. Par défaut, R choisit généralement votre dossier “Documents” comme répertoire de travail sur les machines Windows.\nRacine. La racine fait référence au niveau de dossier le plus élevé du répertoire de travail. Si le dossier de votre cours s’appelle FETCHR la racine se trouverait directement à l’intérieur de celui-ci (et non dans l’un de ses sous-dossiers comme R ou data).\n\n\nProjets RStudio\nUn projet RStudio est outil qui va faciliter votre vie et aider RStudio à trouver les différents fichiers.\nPour rappel, votre interface doit ressembler à ceci :\n\n\n\n\n\n\nFigure 1: Capture d’écran d’une interface RStudio typique\n\n\n\n\nOuvrez RStudio et suivez ces étapes pour créer un nouveau projet :\n\ncliquez sur File &gt; New Project &gt; Existing Directory &gt; Browse,\nnaviguez jusqu’au dossier du cours (en l’ouvrant)\ncliquez sur Create Project.\n\n\n\nDans l’explorateur Windows, examinez le dossier du cours. Vous devriez maintenant voir un nouveau fichier avec l’extension .Rproj qui a une petite icône bleue avec un R au milieu\n\n\n\n\nIcône associée aux projets RStudio\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi vous ne voyez pas ce fichier, c’est probablement parce qu’il est caché par défaut sur votre ordinateur. Pour modifier ce paramètre dans l’explorateur Windows, allez dans le menu Afficher et sélectionnez Extensions de noms de fichier.\n\n\nLorsque vous ouvrez un projet RStudio, RStudio démarre une nouvelle session R spécifique à ce projet, ouvre les fichiers associés et définit la racine de votre dossier comme répertoire de travail. Une conséquence immédiate est que le panneau Files en bas à droite de l’interface montre les sous dossiers présents dans le répertoire de travail, i.e. votre dossier de cours.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est fortement recommandé de mettre en place un projet RStudio distinct pour chacune de vos analyses afin de garantir que les fichiers de vos projets restent organisés.\n\n\nIl existe plusieurs façons d’ouvrir un projet RStudio :\n\nUtilisez le menu RStudio File &gt; Open Project puis sélectionnez le fichier .Rproj approprié\nCliquez sur le bouton Project: (none) en haut à droite de l’interface RStudio\nNaviguez dans l’explorateur de fichiers Windows jusqu’à votre dossier de cours et double-cliquez sur le fichier avec l’extension .Rproj\n\n\n\nLes options de RStudio\nAvant de poursuivre, allons modifier certaines des options de RStudio qui peuvent causer des problèmes.\n\nOuvrez les options globales (Tools &gt; Global Options) et ouvrez l’onglet General (menu de gauche). Déselectionnez toutes les cases des sections R Sessions, Workspace et History.\n\n\n\n\nCapture d’écran des options de RStudio\n\n\nLorsque ces options sont activées, RStudio enregistre les objets de votre environnement et les charge à chaque fois que vous ouvrez une nouvelle session R. Ca semble être une bonne idée, mais il est en fait préférable de toujours commencer votre travail à partir d’une session R vide afin d’éviter les erreurs.\n\n\n\n\n\n\nImportant\n\n\n\nN’oubliez pas que toutes les commandes nécessaires au nettoyage et à l’analyse de vos données doivent être enregistrées explicitement dans un script, dans le bon ordre. Faire retourner le script devrait arriver aux mêmes résultats que précédement.\n\n\n\n\nCréation d’un nouveau script\n\nOuvrez un nouveau script et enregistrez-le dans le sous-dossier R de votre projet sous le nom import_data.R.\nAjoutez des métadonnées au début du script, comme recommandé lors première session, en utilisant des commentaires. Veillez à inclure :\n\nLe titre\nL’auteur du script\nLa date de création\nUne description rapide de ce que fait le script\n\n\nNous sommes prêts à commencer à coder"
  },
  {
    "objectID": "sessions_core/02_import_data.html#sec-packages",
    "href": "sessions_core/02_import_data.html#sec-packages",
    "title": "Importer des données",
    "section": "Paquets",
    "text": "Paquets\nLes paquets [packages] sont des collections de fonctions qui étendent les fonctionalités de R. Vous en utiliserez un grand nombre pendant ce cours et dans votre travail quotidien. R étant open-souce, les packages sont téléchargeable et utilisable gratuitement.\n\n\n\n\n\n\nNote\n\n\n\nDans ce cours, nous utiliserons une convention commune qui est de référencer les paquets entre {}. Par exemple {ggplot2} est le nom du paquet ggplot2 qui contient des fonctions pour créer des graphes, telles que ggplot(), geom_point() etc…\n\n\n\nInstallation\nLa fonction install.packages() télécharge et installe un nouveau paquet sur votre ordinateur, dans la bibliothèque de paquets associée à R. Vous n’avez à faire cette opération qu’une seule fois par paquet et ordinateur.\n\ninstall.packages(\"here\") # installe le paquet {here} \n\nN’oubliez pas de mettre le nom du paquet entre guillemets lorsque vous utilisez la commande install.packages(). Que se passe-t-il si vous ne le faites pas ?\n\n\n\n\n\n\nNote\n\n\n\nSi vous suivez cette session dans le cadre d’un cours, pour éviter tout problème potentiel de connectivité internet pendant la formation, nous vous avons déjà fait installer la plupart des paquets du cours.\nSi vous suivez ce tutoriel seul ou si vous n’avez pas encore installé les paquets, vous devrez installer manuellement chaque nouveau paquet que nous rencontrerons avec la fonction install.packages().\n\n\n\n\nUtilisation\nUne fois qu’un paquet est installé, il faut indiquer à R que nous souhaitons l’utiliser pour une session donnée en le chargeant dans la session avec la fonction library().\n\nlibrary(here) # charge le paquet {here} dans la session\n\n\nUtilisez la fonction library() pour charger les paquets here et rio qui seront utilisés aujourd’hui.\n\nIl se peut que vous obteniez parfois un message d’avertissement signalant que certaines fonctions ont été masquées ou que la version actuelle du paquet a été construite pour une version différente de R. Ces messages ne doivent pas vous inquiéter, mais il faut les lire et essayer de comprendre ce qui se passe.\n\nExécutez le code suivant. Comprenez-vous le message d’erreur ?\n\nlibrary(ggplot)\n\n\nLe code ci-dessus génère une erreur car il y a une faute de frappe dans le nom du paquet, et vous avez donc essayé de charger un paquet qui n’existe pas. Rappelez-vous que R est pénible, et en particulier est sensible à la casse : beaucoup de vos erreurs viendront de petites fautes dans les noms de fonctions ou d’objets. Ici, par exemple, nous voulions charger le paquet ggplot2 mais nous avons écrit ggplot à la place.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est recommandé d’avoir une section au début de votre script qui charge tous les paquets dont vous aurez besoin dans votre script en un seul endroit :\n\n# Packages ----------------------------\nlibrary(tidyverse)   # manipulation de données\nlibrary(lubridate)   # manipulation des dates\n\nCelà permet de savoir rapidement quels paquets doivent être installés pour exécuter un script.\n\n\n\nCréez une section “Paquets” dans votre script à l’aide de commentaires\n\n\n\nMettre à jour les paquets\nR dispose d’une communauté de développeurs très active et il est assez courant que les paquets soient mis à jour, avec de nouvelles fonctionalités ou des corrections de bugs. Pour mettre à jour les paquets de votre bibliothèque, rendez-vous dans l’onglet Packages du panneau inférieur droit et cliquez sur Update. N’oubliez pas que vous devez être connecté à internet pendant ce processus.\n\n\n\n\n\n\nImportant\n\n\n\nLa mise à jour de certains paquets peut parfois changer le comportement de certaines fonctions, ce qui peut casser votre code. Pas de panique. La meilleure pratique consiste à adapter votre code mais, dans le pire des cas, vous pouvez installer une ancienne version du paquet incriminé."
  },
  {
    "objectID": "sessions_core/02_import_data.html#importation-de-données",
    "href": "sessions_core/02_import_data.html#importation-de-données",
    "title": "Importer des données",
    "section": "Importation de données",
    "text": "Importation de données\n\nTrouver son chemin…\nPour ouvrir un fichier dans R, vous devez fournir un chemin d’accès au fichier. Un chemin d’accès est simplement un (long) nom pour un fichier qui inclut son emplacement sur votre ordinateur. Les chemins d’accès peuvent être absolus ou relatifs.\n\nChemins d’accès absolus\nLes chemins d’accès absolus sont spécifiques à votre ordinateur et vont jusqu’au niveau de votre disque dur. Par exemple : D:/OneDrive - MSF/Documents/monitoring/cholera/fancy_project/data/raw/example_linelist.xlsx. Il est clair que ce chemin ne fonctionne que sur un ordinateur particulier.\nL’utilisation de chemins absolus encodés en dur est fortement déconseillé car cela rend votre code fragile et augmente la maintenance : en effet, les chemins devront tous être mis à jour chaque fois quelqu’un d’autre exécute votre code, ou que le dossier du projet est déplacé sur votre ordinateur.\n\n\nChemins d’accès relatifs\nLes chemins relatifs sont définis par rapport à votre répertoire de travail. Comme l’emplacement du fichier .Rproj définit le répertoire de travail, les chemins sont relatifs à cette racine. Pour vous, un chemin relatif ressemblera à ça : data/raw/example_linelist.xlsx.\nCela signifie que tant que la structure interne du dossier contenant votre projet est préservée, le chemin d’accès relatif sera valable quelque soit l’ordinateur.\n\n\nChemins d’accès robustes avec la fonction here()\nLe paquet {here} dispose d’une fonction here() qui aide à créer des chemins d’accès. Elle présente deux avantages :\n\nElle détecte la présence d’un fichier .Rproj et est capable de construire un chemin absolu à partir d’un chemin relatif dans votre projet RStudio.\nElle choisit automatiquement le séparateur adapté à votre système d’exploitation : /, \\ ou //.\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"C:/Users/M-MOUSSET/AppData/Local/Temp/RtmpgTsDDx/file5d3c80033f1/data/raw/example_linelist.xlsx\"\n\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"C:/Users/M-MOUSSET/AppData/Local/Temp/RtmpgTsDDx/file5d3c80033f1/data/raw/example_linelist.xlsx\"\n\n\nVoyez comme nous n’avons défini que le chemin relatif et la fonction a reconstitué le chemin absolu. Celà marchera donc sur l’ordinateur d’un collègue, y compris sur un autre système d’exploitation, du moment que la structure du répertoire de travail est intacte.\nNous vous encourageons fortement à utiliser here() chaque fois que vous devez créer un chemin d’accès à un fichier.\n\nExécutez le code ci-dessus dans la console. Quel chemin d’accès here(\"data\", \"raw\") vous donne-t-il ?\n\n\nUtilisez here() pour créer le chemin vers le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx.\n\n\n\n\n\n\n\nImportant\n\n\n\nhere() crée une chaîne de caractères contenant l’adresse d’un fichier, mais ne vérifie pas si ce fichier existe réellement sur votre ordinateur. Si le fichier est absent ou s’il y a une faute de frappe dans votre code, vous obtiendrez une erreur lors de l’utilisation du chemin ainsi créé. Vous pouvez tester si un fichier existe à cette adresse avec la fonction file.exists().\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nOn veut souvent définir plusieurs chemins dans un projet (données brutes, données propres, où sauver les graphes etc.). C’est une bonne pratique que de créer une nouvelle section au début de votre script, après le chargement des paquets, pour définir et stocker les chemins d’accès dans des objets.\n\n\n\n\n\nImporter les données\nDans R, différents formats de fichiers sont importés par différentes fonctions spécialisées, ce qui est fastidieux à mémoriser et à charger. La fonction import() du paquet {rio} nous fait gagner du temps en reconnaissant l’extension des fichier et en appelent automatiquement une fonction spécialisée pour charger les données.\nComme import() ne fait qu’appeler d’autres fonctions en arrière-plan, il est possible qu’elle ait besoin d’arguments optionnels spécifiques pour certains types de fichier.\n\n\n\n\n\n\nAstuce\n\n\n\nLa (longue) liste des types de fichiers pris en charge par {rio} est sur le site du paquet. Dans la suite de la leçon, nous nous concentrerons sur l’importation de données à partir de fichiers Excel .xlsx.\n\n\n\nImport de la première feuille\nAu minimum la fonction import() a besoin qu’on lui donne le chemin du fichier avec l’argument file :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"))\n\nNotez que nous avons imbriqué la commande here() à l’intérieur de la commande import(). L’imbrication de fonctions est autorisée et même courrante en R. R évalue les fonctions imbriquées de l’intérieur (here()) à l’extérieur (import()). La valeur renvoyée par here() est donc utilisée comme valeur d’entrée d’import().\n\nImportez le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx en utilisant here() et import().\n\nSi votre importation a fonctionné correctement, R affichera les données dans la console mais ne les enregistrera pas dans l’environnement car nous ne les avons pas assignées à un objet.\n\nRéimportez vos données, mais cette fois-ci, sauvegardez-les dans un objet appelé df_linelist.\n\n\n\n\n\n\n\nAstuce\n\n\n\nSi votre jeu de données est très gros, il vaut mieux éviter de l’afficher dans la console…\n\n\n\n\nImport d’une autre feuille\nComme vous venez de le voir, la fonction import() importe la première feuille d’un fichier Excel par défaut. Il est cependant possible de passer le numéro de la feuille ou son nom (en chaîne de caractères) à l’argument which :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"),  # chemin\n       which = 2)                                            # spécifie la deuxième feuille\n\nNotez que l’argument which est spécifique aux types de fichiers comportant plusieurs feuilles, tels que les fichiers Excel ou .Rdata. Si vous essayez de l’utiliser sur un fichier .csv l’argument sera ignoré."
  },
  {
    "objectID": "sessions_core/02_import_data.html#aperçu-des-données",
    "href": "sessions_core/02_import_data.html#aperçu-des-données",
    "title": "Importer des données",
    "section": "Aperçu des données",
    "text": "Aperçu des données\nNous avons importé un jeu de données dans R et l’avons assigné à un objet (df_linelist). Nous pouvons maintenant inspecter le data frame créé pour vérifier que l’export s’est bien passé, et commencer à évaluer le nettoyage à faire.\nNous pouvons commencer par jeter un coup d’œil rapide aux premières lignes du data frame à l’aide de la fonction head(). Son premier argument est le data frame à inspecter et le second, n, accepte un nombre de lignes à afficher (optionnel).\n\nhead(df_linelist, n = 10) # Affiche les 10 premières lignes\n\n\nUtilisez head() pour examiner les 12 premières lignes de df_linelist.\n\nNous pouvons inspecter la structure du data frame à partir de l’onglet Environnement dans le panneau supérieur droit. Nous pouvons également visualiser le data frame dans le le visualiseur de données de RStudio (en haut à gauche).\n\nCliquez sur le bouton rond bleu à côté de df_linelist dans votre environnement pour examiner sa structure. Cliquez ensuite sur le nom du data frame pour le visualiser.\n\nLe visualiseur permet d’afficher le data frame comme dans un tableur et est un moyen pratique d’examiner rapidement vos données. Vous pouvez trier et filtrer vos données dans cet onglet mais ces actions ne modifieront pas l’objet df_linelist. Le visualiseur peut également être ouvert en utilisant directement la fonction View() sur le data frame."
  },
  {
    "objectID": "sessions_core/02_import_data.html#cest-fini",
    "href": "sessions_core/02_import_data.html#cest-fini",
    "title": "Importer des données",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo et n’oubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "href": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "title": "Importer des données",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices supplémentaires\n\nUtilisez dim() pour examiner les dimensions de votre data frame.\nUtilisez str() pour vérifier le type de données de chaque colonne. Voyez-vous quelque chose d’étrange ? N’oubliez pas que vous pouvez également utiliser des fonctions telles que is.character() et is.numeric() si vous souhaitez tester le type d’une colonne particulière.\nEn utilisant une fonction apprise lors de la première session, pouvez-vous extraire les noms des colonnes du data frame ? Ces résultats correspondent-ils à ce que vous voyez lorsque vous ouvrez les données dans Excel ?\nEssayez d’exécuter la fonction summary() sur votre data frame. Qu’est ce que le résultat vous apprend sur les variables ?\n\n\n\nRessources complémentaires\n\nLe site web de {rio}\nPlus d’exemples sur l’importation de données de différents types de fichiers"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Ressources",
    "section": "",
    "text": "Cette page contiendra (éventuellement) des ressources externes pour poursuivre votre parcours d’apprentissage du R."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{repicentre}",
    "section": "",
    "text": "Bienvenue à {repicentre}\nUne plateforme open source pour apprendre R dans les contextes humanitaires. Qu’aimeriez-vous faire ?\n\n\n\n\n\nApprendre Parcours linéaire en commençant par les bases  Start\n\n\n\n\n\nExplorer Catalogue complet de cours d’autoformation  Start\n\n\n\n\n\nRessources Ressources externes pour aller plus loin  Start"
  },
  {
    "objectID": "about.html#salut",
    "href": "about.html#salut",
    "title": "À Propos",
    "section": "Salut",
    "text": "Salut\nBienvenue sur {repicentre}, un site open source développé par Epicentre pour vous aider à apprendre R pour les contextes humanitaires. Le site est composé de tutoriels autodidactes et propose deux options principales d’apprentissage :\n\nLinéaire. Conçu pour les personnes n’ayant aucune expérience préalable de R, le cours linéaire vous guidera à travers les concepts de base de R en utilisant une étude de cas sur la rougeole au Tchad. Le cours couvre les concepts suivants :\n\nStructures de données et l’interface RStudio\nImportation de données\nManipulation de données\nNettoyage des données\nAgrégation de données\nVisualisation des données\n\nExploration. Si vous avez un peu plus d’expérience ou si vous recherchez un sujet particulier, n’hésitez pas à explorer la gamme complète des tutoriels. Les tutoriels sont classés par catégories et sont conçus pour être autonomes."
  },
  {
    "objectID": "about.html#recommandations-et-demandes",
    "href": "about.html#recommandations-et-demandes",
    "title": "À Propos",
    "section": "Recommandations et demandes",
    "text": "Recommandations et demandes\nY a-t-il un sujet sur lequel vous aimeriez voir un tutoriel qui n’est pas encore disponible ? C’est très bien ! N’hésitez pas à nous le faire savoir en ouvrant un “issue” sur le repo GitHub associé à ce site web. Si vous ne savez pas comment ouvrir un issue, veuillez contacter Cat Eisenhauer."
  },
  {
    "objectID": "about.html#contribuer",
    "href": "about.html#contribuer",
    "title": "À Propos",
    "section": "Contribuer",
    "text": "Contribuer\nVous souhaitez contribuer à la rédaction ou à la maintenance de tutoriels ? Incroyable ! Veuillez contacter Cat."
  },
  {
    "objectID": "explore.html",
    "href": "explore.html",
    "title": "Explorer",
    "section": "",
    "text": "Choisissez votre propre aventure en parcourant toutes les sessions disponibles.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des données\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et importez des données pour travailler dans R.\n\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to data visualization with ggplot2\n\n\n\nCore\n\n\nVisualization\n\n\n\nApprenez les bases de la visualisation avec ggplot2, et créez votre première épicurve\n\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTableaux récapitulatifs\n\n\n\nCore\n\n\nTableaux de resumé\n\n\n\nCréer des tableaux récapitulatifs\n\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, les bases\n\n\n\nCore\n\n\nManipulation des données\n\n\nNettoyage des données\n\n\n\nUne introduction à la manipulation et au nettoyage des données à l’aide du paquet {dplyr}.\n\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, recoder et filtrer\n\n\n\nCore\n\n\nManipulation des données\n\n\nNettoyage des données\n\n\nLogique\n\n\n\nApprenez à recoder vos variables avec {dplyr} et comment sélectionner les lignes d’un data frame suivant certains critères\n\n\n\n\n\n\n5 mars 2025\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "pathway.html",
    "href": "pathway.html",
    "title": "Cours",
    "section": "",
    "text": "Ces sessions peuvent être suivies afin d’obtenir un niveau de base dans R. La série suppose aucune expérience préalable dans R et convient bien aux débutants.\nVous en voulez plus ? Vous voulez plus de flexibilité ? Consultez le catalogue complet des sessions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à R\n\n\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\nImporter des données\n\n\n\n\n\nCréez un projet Rstudio, installez les paquets utiles et importez des données pour travailler dans R.\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, les bases\n\n\n\n\n\nUne introduction à la manipulation et au nettoyage des données à l’aide du paquet {dplyr}.\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de données, recoder et filtrer\n\n\n\n\n\nApprenez à recoder vos variables avec {dplyr} et comment sélectionner les lignes d’un data frame suivant certains critères\n\n\n\n\n\n5 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\nTableaux récapitulatifs\n\n\n\n\n\nCréer des tableaux récapitulatifs\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to data visualization with ggplot2\n\n\n\n\n\nApprenez les bases de la visualisation avec ggplot2, et créez votre première épicurve\n\n\n\n\n\n4 mars 2025\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "sessions_core/01_introduction.html",
    "href": "sessions_core/01_introduction.html",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCréer et exécuter un script\nCréer des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#objectifs",
    "href": "sessions_core/01_introduction.html#objectifs",
    "title": "Introduction à R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCréer et exécuter un script\nCréer des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#format-des-exercices",
    "href": "sessions_core/01_introduction.html#format-des-exercices",
    "title": "Introduction à R",
    "section": "Format des exercices",
    "text": "Format des exercices\nCes exercices sont dans un format tutoriel contenant de brèves explications sur les concepts clés, des exemples et des instructions à suivre. Notre approche est très orientée sur la pratique, et à l’exception de cette première session partiellement axée sur l’interface, vous aurez beaucoup d’occasions de coder.\nLes instructions pour les exercices seront données dans les formats suivants :\n\nCet encadré contient des instructions généralistes. Vous le trouverez en général au début d’une session, avec des instructions de mise en place.\n Exemple : Ouvrez un script vide et nommez-le mon_premier_script.R.\n\n\nCet encadré contient des instructions de code que vous devez écrire dans votre script ou la console.\n Exemple : Créez un objet region qui contient la valeur \"Mandoul\".\n\n\nCet encadré vous demande d’observer ou étudier quelque chose.\n Exemple : Inspectez l’interface de RStudio.\n\nAu cours de ces exercices, vous rencontrerez certainement des erreurs, qui se produisent lorsque R n’est pas en mesure d’exécuter une commande. Cela peut se produire pour de nombreuses raisons : une faute d’orthographe dans le nom d’un objet ou d’une fonction, le mauvais type de données fournis etc. Lorsqu’une erreur se produit, R arrête les calculs en cours et affiche un message expliquant ce qu’il s’est passé. Il est tout à fait normal d’avoir des erreurs, ça arrive tout le temps, à tous les programmeurs, qu’ils soient novices ou experts. Comme lorsque vous apprenez une langue (non informatique), vous vous améliorerez avec la pratique, en faisant des erreurs et en apprenant à les corriger."
  },
  {
    "objectID": "sessions_core/01_introduction.html#rstudio-et-r",
    "href": "sessions_core/01_introduction.html#rstudio-et-r",
    "title": "Introduction à R",
    "section": "RStudio et R",
    "text": "RStudio et R\nR est un langage de programmation fonctionnel qui peut être utilisé pour nettoyer et manipuler des données, effectuer des analyses (en particulier des analyses statistiques), visualiser des résultats, et bien plus encore.\nRStudio est un logiciel qui fournit une interface facile à utiliser pour R (également appelé IDE, pour “Integrated Development Environment”). Son utilisation n’est pas obligatoire, mais très fortement recommandée pour les débutants.\n\nPremiers pas avec RStudio\n\nOuvrez RStudio en utilisant le menu de démarrage de votre ordinateur ou le raccourci créé par défaut sur le bureau ; si RStudio était déjà ouvert, fermez-le et ouvrez-le à nouveau.\n\nVous devriez voir une interface qui ressemble à ceci :\n\n\n\nVue de l’interface de l’IDE Rstudio à l’ouverture\n\n\n\nInspectez l’interface de RStudio.\n\nVous verrez trois ou quatre panneaux.\n\nPanneau supérieur droit\nEn haut à droite se trouve un panneau avec plusieurs onglets. La plupart d’entre eux dépassent le cadre de ce cours, mais nous utiliserons les deux onglets suivants :\n\nEnvironment : liste les objets enregistrés par l’utilisateur dans la session en cours. Comme vous venez de démarrer une nouvelle session, votre environnement devrait être vide.\nHistory : comprend l’historique de toutes les commandes que vous avez exécutées au cours de la session actuelle.\n\n\n\n\n\n\n\nNote\n\n\n\nOuvrir une nouvelle session R, c’est comme redémarer son ordinateur : tout est vide et prêt pour le calcul, de la même manière qu’il n’y a aucun programme ouvert lorsque vous allumez votre ordinateur pour la première fois.\nNous vous encourageons à arrêter et à re-démarrer vos sessions R régulièrement. Parfois cela corrigera certains de vos problèmes !\n\n\n\n\nPanneau inférieur droit\nEn bas à droite se trouve un autre panneau comprenant les onglets suivants :\n\nFiles : un explorateur de fichiers pour le répertoire de travail, qui est l’emplacement du dossier dans lequel R travaille actuellement.\nPlots : là où RStudio affichera les graphiques statiques. Cet onglet devrait être vide pour le moment.\nPackages : liste de tous les paquets R installés sur votre ordinateur. Les paquets sont des collections de fonctions qui permettent d’étendre les fonctionnalités de R. Nous les aborderons plus en détail dans la prochaine leçon.\nHelp : un endroit pour lire les pages d’aide et la documentation pour les fonctions et les paquets.\nViewer : un emplacement où RStudio affichera des sorties html telles que des tableaux, des widgets interactifs ou même des tableaux de bord.\n\n\n\nPartie gauche\n\nA gauche (ou en bas à gauche si vous avez déjà quatre panneaux), vous devriez voir l’onglet console, où le code R est exécuté.\nEn haut à gauche (si vous avez quatre panneaux) se trouvent les scripts R ouverts.\n\n\n\n\nLa console\nLa console est l’endroit où le code R s’exécute.\nAu début d’une nouvelle session, un texte d’information sur votre cofiguration apparaît tout en haut de la console, dont le numéro et nom de la version de R. En dessous de ces informations, il y a une ligne avec le symbole &gt; et un curseur clignotant.\nPour exécuter une commande dans R, tapez-la à la suite du &gt; et pressez Entrée. R traitera alors votre code et affichera le résultat (s’il y en a un). Un nouveau &gt; s’affichera alors sur la ligne suivante, indiquant que la console est prête pour la commande suivante.\n\n\n\n\n\n\nImportant\n\n\n\nSi la dernière ligne est préfacée d’un + au lieu d’un &gt;, cela signifie que la console n’est pas prête. Soit elle attend qu’un calcul d’une commande précédente finisse, soit elle attend la fin d’une commande incomplète. A tout moment, vous pouvez interrompre l’exécution en pressant la touche Echap.\n\n\n\nExécutez les commandes suivantes dans la console, une ligne à la fois, et observez les résultats.\n\n5 + 90\n\n6 * 171\n\n189 / 36.6\n\n92^3\n\n(12 + 9)^4 / 1000\n\nExécutez maintenant la commande suivante. Notez que le ) fermant est manquant, ce qui rend la commande incomplète. Que se passe-t-il ?\n\n3 / (2 + 97\n\n\nVous avez peut-être noté dans les exemples précédents que notre code contient beaucoup d’espaces. C’est en effet une bonne pratique que d’inclure des espaces autour de la plupart des opérateurs, tels que +, -, *, /, &lt;, &gt;, = et &lt;-. Ces espaces facilitent la lecture et la compréhension de votre code, et dans certains cas (rares) ils permettent d’éviter des erreurs. Néanmoins, certains opérateurs ne doivent pas être entourés d’espaces, tels que ^, . et :.\n\n1+29+4.8/3*3           # Mauvais\n1 + 29 + 4.8 / 3 * 3   # Bien\n\n1 ^ 2  # Mauvais\n1^2    # Bien\n\nNous pouvons également exécuter des fonctions dans la console. Nous aborderons les fonctions plus en détail plus tard mais sachez que les fonctions dans R sont similaires aux fonctions dans Excel (telles que SOMME ou MOYENNE).\n\nExécutez les commandes suivantes dans la console (une ligne à la fois).\n\n# Trouvez la valeur minimale\nmin(5, 10)\nmin(1, 8, 56, 0.3)\n\n# Trouvez la valeur maximale\nmax(568, 258, 314)\n\n\n\n\nScripts\nLes scripts sont des fichiers texte qui contiennent une série de commandes pour un langage de programmation particulier. L’extension du fichier indique le langage dans lequel les commandes sont écrites. Ici nous utiliserons l’extension .R. Les scripts nous permettent de créer du code qui peut être réutilisé, partagé et même automatisé.\n\nÉcrire son premier script\nPour créer un nouveau script, allez dans le menu File &gt; New File &gt; R Script. Alternativement, cliquez sur la petite icône avec un + vert sur une page blanche située en dessous du menu File. Ou encore, utilisez le raccourci clavier CTRL + MAJ + N. Ce nouveau script non sauvegardé apparaîtra sous la forme d’un document vierge dans le panneau supérieur gauche.\n\n\n\nEtapes pour créer un nouveau script dans RStudio\n\n\nPour enregistrer votre script, utilisez le menu File &gt; Save As ou le raccourci clavier CTRL + S.\n\nCréez un script et enregistrez-le sous le nom decouverte.R(n’oubliez l’extension !). Pour l’instant, vous pouvez l’enregistrer sur votre bureau ou à tout autre endroit pratique, mais nous aborderons l’organisation des scripts dans la prochaine session.\n\n\n\nExécuter du code à partir d’un script\nPour exécuter du code à partir d’un script, placez votre curseur sur la ligne que vous souhaitez exécuter (ou sélectionnez plusieurs lignes) et effectuez l’une des opérations suivantes :\n\nCliquez sur le bouton Run en haut à droite de la fenêtre de script\nUtilisez le raccourci CTRL + Entrée (le curseur passera ensuite à la ligne suivante)\nUtiliser le raccourci ALT + Entrée (le curseur restera sur la ligne actuelle)\n\n\nCopiez le code que vous aviez exécuté dans la console lors des exercices précédents dans votre script et exécutez-le en testant les différentes méthodes ci-dessus.\nA partir de maintenant, vous écrirez votre code dans votre script et l’exécuterez à partir de là, sauf indication contraire de notre part.\n\n\n\nCommentaires\nDans R, le code qui est précédé d’un # (dièse) n’est pas exécuté, il est juste ignoré jusqu’à la fin de la ligne. C’est donc un bon moyen de documenter votre code.\n\n# Ceci est un commentaire\n\n2 + 3  # Ceci est aussi un commentaire\n\nIl est utile pour vous et vos collègues de commencer vos scripts par quelques lignes commentées fournissant des informations importantes sur le contenu de votre script.\n\n# IMPORT & PREPARATION DES DONNEES #\n# Auteure :  Mathilde Mousset\n# Date de création : 23/11/2024\n# Dernière mise à jour : 28/01/2024\n# Description : Importat et nettoyage des données de surveillance rougeole de Moissala\n\n\nAjoutez quelques commentaires au début de votre script pour le décrire.\n\nLes commentaires sont également un moyen pratique de diviser les scripts longs en sections thématiques, telles que “Import des données”, “Analyse”, “Visualisation”, etc. Par exemple :\n\n# NOM DE LA SECTION 1 -----------------------------------------------             \n\n# NOM DE LA SECTION 2 -----------------------------------------------             \n\n\nUtilisez les commentaires pour créer des sections dans votre script qui correspondent aux sections principales de ce tutoriel.\n\nEnfin, les commentaires permettent de prendre des notes sur votre code pour aider à la compréhension (celle de votre “moi futur” et celle de vos collègues). On entend souvent le conseil de se focaliser sur les commentaires qui expliquent le “pourquoi” plutôt que le “quoi”, car le “quoi” d’un code bien écrit devrait être clair.\nPar exemple, ce commentaire est superflu :\n\n1 + 3  # Code pour additionner un et trois\n\nEn comparaison, voici quelques cas où un commentaire est mérité :\n\nVous définissez une constante, une valeur seuil de séroprévalence par exemple. Ajoutez un commentaire indiquant la référence d’où provient la valeur.\nVotre code contient une valeur ou un nom de fichier qui doit être mis à jour chaque semaine. Indiquez le dans un commentaire afin que toute personne utilisant le code en soit informée.\nVous utilisez une commande contre-intuitive de premier abord, ou un paquet rare que votre collègue ne connaît peut-être pas. Commentez pour expliquer vos raisons.\n\nCeci étant dit, vous êtes en plein apprentissage, et les scripts que vous écrivez pendant ce cours sont l’équivalent de vos notes de cours, alors n’hésitez pas à utiliser autant de commentaires que vous le souhaitez pour expliquer les commandes et vous rappeler de ce qu’elles font. Vous écrirez naturellement moins de commentaires avec la pratique, lorsque les choses qui nouvelles aujourd’hui deviendront naturelles.\n\n\n\n\n\n\nAstuce\n\n\n\nCommentez une ligne sélectionnée avec le raccourci CTRL + MAJ + C.\nAjoutez une section de premier niveau avec CTRL + MAJ + R.\n\n\n\nAjoutez quelques commentaires pour décrire le code que vous avez écrit jusqu’à présent dans votre script."
  },
  {
    "objectID": "sessions_core/01_introduction.html#types-de-données",
    "href": "sessions_core/01_introduction.html#types-de-données",
    "title": "Introduction à R",
    "section": "Types de données",
    "text": "Types de données\nR dispose de plusieurs types de données. Ceux que nous verrons le plus souvent dans ce cours sont les suivants :\n\nnumérique [numeric en anglais]\nchaîne de caractères (texte) [string en anglais]\nbooléen (VRAI / FAUX) [boolean en anglais]\ndate [date]\nfacteur [factor]\n\n\nNumérique\nLe type numérique englobe les entiers [integers en anglais] et les doubles (nombres décimaux). Les nombres en R n’ont pas de signalétique, tapez simplement la valeur brute dans votre script ou votre console.\n\n\nChaînes de caractères\nLes chaînes de caractères [strings] représentent le texte en R. Elles sont tapées en entourant votre texte de guillemets simples ou doubles, \"district\" ou 'cas' par exemple (les guillemets doubles sont généralement considérés comme la meilleure pratique).\n\nComparez la sortie dans la console pour les commandes suivantes :\n\n28         # numérique\n\"28\"       # texte\n28 + \"28\"  # donne une erreur\n\n\nLa dernière commande ci-dessus a renvoyé une erreur car nous ne pouvons pas effectuer d’opérations arithmétiques combinant du texte et des nombres.\n\n\n\n\n\n\nImportant\n\n\n\nR est sensible à la casse (majuscules ou minuscules), ce qui signifie que \"ABC\" n’est pas équivalent à \"abc\".\n\n\n\nSi vous souhaitez créer une chaîne de caractères contenant des guillemets, il faut échapper les guillements les faisant précéder d’un \\. Par exemple : \"Elle dit \\\"Bonjour\\\" et s'en alla\" ou 'C\\'est une belle journée'. Si vous avez utilisé des guillements doubles pour créer votre chaîne de caractères, vous pouvez utiliser des guillemets simples à l’intérieur de celle-ci (par exemple : \"C'est une belle journée\") et vice versa (par exemple : 'Elle dit \"Bonjour\" et s'en alla').\n\n\n\nBooléen (logique)\nLe type booléen (ou logique) stocke des valeurs vrai/faux et est créé en écrivant soit TRUE [VRAI] ou FALSE [FAUX] sans guillemets.\nEn interne, R traduit TRUE et FALSE en équivalents numériques 1 et 0 respectivement, ce qui peut être utile pour des opérations arithmétiques.\n\n\n\n\n\n\nNote\n\n\n\nVous verrez peut-être des personnes qui utilisent T ou F mais c’est déconseillé car T et F peuvent également être utilisés comme noms d’objets ou de variables. En revanche, les valeurs TRUE et FALSE sont réservées (protégées), ce qui signifie qu’elles ne peuvent pas être réaffectés à une autre valeur.\n\n\n\n\nDéterminer le type d’un objet\nIl existe plusieurs fonctions permettant de déterminer le type d’un objet (souvent appelé la classe de l’objet en R [class].\n\nTapez les commandes suivantes dans votre script et exécutez-les :\n\n# Obtenir le type\nclass(28)  \nclass(\"Mandoul\")\n\n# Test du type\nis.numeric(28)\nis.numeric(\"Mandoul\")\nis.character(\"Mandoul\")\n\nis.numeric(TRUE)\nis.character(TRUE)\nis.logical(FALSE)"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-assignement-operator",
    "href": "sessions_core/01_introduction.html#sec-assignement-operator",
    "title": "Introduction à R",
    "section": "Enregistrer un objet",
    "text": "Enregistrer un objet\nEn R, presque tout est un objet y compris les fonctions, les vecteurs et les structures plus complexes. Souvent, nous souhaitons réutiliser certains objets tout au long d’un script (un jeu de données par exemple). Il est donc très utile de les stocker dans notre environnement (la mémoire de R). Pour ce faire, nous utilisons l’opérateur d’assignation &lt;-.\n\nRegardez le panneau environnement en haut à droite. Il devrait être vide. Tapez la commande suivante dans votre script et exécutez-la. Elle enregistre une variable appelée cas dans votre environnement.\n\ncas &lt;- 28\n\nInspectez à nouveau l’environnement. Est-il toujours vide ?\n\nSi vous souhaitez accéder à la valeur de votre nouvel objet, cas il vous suffit d’exécuter son nom.\n\ncas\n\n[1] 28\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous écrivons les chaînes de caractères entre guillements pour permettre à R de faire la différence entre un objet cas et le texte \"cas\".\n\n\nUne fois créés, les objets peuvent être utilisés dans d’autres commandes :\n\ncas + 5\n\n[1] 33\n\n\n\nDans votre script, créez un objet appelé region qui contient la valeur \"Mandoul\". Est-il bien apparu dans votre environnement ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN’oubliez pas que nous devons toujours entourer l’opérateur &lt;- par des espaces afin d’améliorer la lisibilité et d’éviter les erreurs.\n\nx&lt;-3     # MAUVAIS\nx &lt;- 3   # BIEN\n\n\n\n\nMettre à jour d’un objet\nNous souhaitons souvent mettre à jour la valeur stockée dans un objet. Pour ce faire, il suffit d’assigner une nouvelle valeur avec la même syntaxe que celle utilisée lors de la création de l’objet :\n\ncas &lt;- 32\n\n\nMettez à jour l’objet region avec la valeur \"Moyen Chari\".\n\n\n\nNoms d’objets\nPour nommer vos objets, il existe quelques règles (relativement) strictes :\n\nNe pas commencer par un chiffre\nNe pas utiliser d’espaces (utiliser un _ à la place)\nNe pas utiliser de valeurs réservées (comme TRUE et FALSE) ou des noms de fonctions (comme mean)\nNe pas utiliser de majuscules (c’est plus une convention qu’une règle dure)\n\nAu-delà de ces règles, il existe également des bonnes pratiques plus subjectives et des styles personnels. En règle générale, les noms doivent être courts et descriptifs :\n\na &lt;- 19                              # Pas informatif\nage_du_patient_a_l_admission &lt;- 19   # Trop long\nage &lt;- 19                            # Concis et précis\n\nDes noms clairs et informatifs contribuent à rendre votre code plus lisible, ce qui permet aux autres de le comprendre facilement sans avoir à constamment consulter le dictionnaire de données."
  },
  {
    "objectID": "sessions_core/01_introduction.html#structures-de-données",
    "href": "sessions_core/01_introduction.html#structures-de-données",
    "title": "Introduction à R",
    "section": "Structures de données",
    "text": "Structures de données\nJusqu’à maintenant, nous avons créé des objets simples qui contenaient une seule valeur. A présent nous allons nous intéresser à des structures plus complexes qui peuvent contenir des jeux de données.\n\nVecteurs\nIl est possible de rassembler plusieurs valeurs (telles que des valeurs numériques ou des chaînes de caractères) en un seul objet, appelé vecteur.\nTechniquement, il existe plusieurs types de vecteurs, dont :\n\nles vecteurs simples (ou vecteurs atomiques) ne peuvent contenir qu’un seul type de valeurs. Par exemple, un vecteur d’entiers contenant 2, 4, 6 ou un vecteur de texte contenant \"Mandoul\", \"Moyen Chari\".\nles vecteurs récursifs (généralement appelés listes) sont plus complexes et peuvent contenir plusieurs dimensions et types de données. Nous ne les aborderons pas dans cette leçon.\n\nCette leçon n’entrera pas dans les détails abstraits de ces structures et se concentrera sur celles que vous rencontrerez le plus souvent dans votre travail.\n\nVecteurs simples\nLes vecteurs simples peuvent contenir une ou plusieurs valeurs d’un seul type de données. Ils ont donc deux propriétés essentielles : une longueur et un type. Dans le cadre de ce cours, nous utiliserons indifféremment les termes “vecteur simple” et “vecteur”, comme c’est généralement le cas dans la communauté R.\nTechniquement, vous avez déjà créé vos premiers vecteurs simples lorsque vous avez construit les objets cas et region. Il s’agissait de vecteurs avec une longueur de taille une. Pour créer un vecteur avec plus d’une valeur, nous utiliserons la fonction c() (moyen mnémotechnique) :\n\ncas &lt;- c(2, 5, 8, 0, 4)\n\n\nMettez à jour cas avec les valeurs ci-dessus et mettez à jour region pour créer un vecteur de chaînes de caractères contenant les valeurs suivantes : Mandoul, Moyen-Chari, Logone Oriental, Tibesti et Logone Occidental.\n\nNous pouvons maintenant utiliser des fonctions sur les objets que nous avons créés :\n\nmean(cas)  # Calcule la moyenne des valeurs stockées dans le vecteur\n\n[1] 3.8\n\ntoupper(region)  # Convertit les valeurs du vecteur en majuscules\n\n[1] \"MANDOUL\"           \"MOYEN-CHARI\"       \"LOGONE ORIENTAL\"  \n[4] \"TIBESTI\"           \"LOGONE OCCIDENTAL\"\n\n\n\nEcrivez des commandes dans votre script pour effectuer les actions suivantes :\n\ncalculer la somme des valeurs de cas avec la fonction sum()\nconvertir le texte de region en minuscules à l’aide de la fonction tolower()\n\n\n\n\n\nAccès aux valeurs d’un vecteur\nIl est possible d’accéder à une valeur d’un vecteur en donnant son indice (i.e. sa position dans le vecteur) entre crochets :\n\ncas[2]   # Deuxième valeur de cas\n\n[1] 5\n\ncas[10]  # Dixième valeur de cas\n\n[1] NA\n\n\nOups il n’y a pas de dixième valeur dans cas ! Nous reviendrons sur ce que ce NA signifie dans la section valeurs manquantes.\nNous pouvons également accéder à une plage de valeurs, comme nous pourrions le faire dans Excel. Nous utilisons l’opérateur : entre la position minimum et maximum de la plage :\n\ncas[2:4]  # de la deuxième à la quatrième valeur\n\n[1] 5 8 0\n\n\n\nAffichez la 3ème valeur du vecteur region.\nAccédez aux valeurs “Mandoul” et “Moyen-Chari” du vecteur region.\n\n\n\nData frames\nLes data frames sont des structures tabulaires / tableaux en 2D avec des lignes et des colonnes. Il s’agit d’une structure très similaire à celle d’un “tableau” dans Excel. En tant qu’épidémiologistes, ce type d’objet est l’un des plus utiles et vous l’utiliserez quotidiennement pour stocker des jeux de données (des listes linéaires par exemple).\n\nCréation d’un data frame\nNous créons un data frame avec la fonction data.frame() :\n\ndata.frame(col1 = c(1, 4, 2, 9),\n           col2 = c(\"un peu de texte\", \"plus de text\", \"Salut !\", \"les epidemiologistes !\"))\n\n  col1                   col2\n1    1        un peu de texte\n2    4           plus de text\n3    2                Salut !\n4    9 les epidemiologistes !\n\n\nIci, on a crée col1 à partir d’un vecteur numérique, et col2 à partir d’un vecteur de chaînes de caractères. Nous avons choisi les noms des colonnes (col1 et col2), ce qui est normal, mais vous pouvez exécuter le code sans nommer les colonnes pour voir comment R crée lui même des noms.\n\nDans votre script, créez un data frame nomé data_cas qui contient cas dans une colonne et region dans l’autre.\n\n\n\nExploration d’un data frame\nL’objet data_cas devrait maintenant apparaître dans votre environnement. Vous pouvez cliquer sur le cercle bleu avec un triangle blanc pour dérouler des informations supplémentaires, ou cliquer sur son nom pour le visualiser dans un onglet dans le même volet que votre script.\n\n\n\nLe data frame data_cas apparaît désormais dans l’onglet Environnement.\n\n\nIl existe plusieurs fonctions pratiques pour explorer un data frame :\n\nExécutez les commandes suivantes et essayez de déterminer le type d’informations qu’elles renvoient.\n\nstr(data_cas)     # STRucture de l'object\ndim(data_cas)     # DIMension de l'object\nnrow(data_cas)    # Nombre de lignes (row = ligne)\nncol(data_cas)    # Nombre de COLonnes\nnames(data_cas)   # noms des colonnes\n\n\nPratiquons un peu plus ! R est livré avec quelques data frames intégrés auxquels il est possible d’accéder directement, dont un appelé iris. C’est pratique pour cette session car nous n’avons pas encore appris à importer des données dans R (ne vous inquiétez pas, nous travaillerons sur des données de liste linéaire dès la prochaine session !).\nNous pouvons afficher les premières lignes de ce data frame grâce à la fonction head() [head = la tête en anglais] :\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nCombien de lignes et de colonnes y a-t-il dans iris? Quels sont les noms des colonnes de ce data frame ?\n\n\n\nAccéder aux données d’un data frame\nEn R, il existe plusieurs méthodes pour accéder aux lignes et/ou colonnes d’un data frame. Dans cette session d’introduction, nous nous concentrerons sur la syntaxe [row, column].\nNous pouvons utiliser un numéro (ou un intervalle) de ligne pour extraire des lignes, et des numéros (ou un intervalle) de colonnes pour extraire les colonnes. Ont peut également utiliser le nom des colonnes pour y accéder.\n\ndata_cas[1, 2]    # Afficher la valeur de la ligne 1, deuxième colonne\n\n[1] \"Mandoul\"\n\ndata_cas[1, \"region\"]   # Afficher la valeur de la lignbe 1, pour la colonne région\n\n[1] \"Mandoul\"\n\n\nSi nous voulons isoler toutes les lignes (ou colonnes), nous pouvons simplement laisser un espace à la place du numéro/nom :\n\ndata_cas[1, ]  # Extrait la première ligne (garde toutes les colonnes)\n\n  cas  region\n1   2 Mandoul\n\ndata_cas[2:4, ]   # Valeurs des lignes 2 à 4, pour toutes les colonnes\n\n  cas         region\n2   5       Sud Kivu\n3   8 Kasai oriental\n4   0          Kasai\n\ndata_cas[ , \"region\"]   # Garde toutes les lignes mais que la colonne région\n\n[1] \"Mandoul\"        \"Sud Kivu\"       \"Kasai oriental\" \"Kasai\"         \n[5] \"Haut Katanga\"  \n\n\nNous pouvons même sélectionner plusieurs indices non consécutifs en utilisant un vecteur :\n\ndata_cas[c(1, 3), ]  # Ligne 1 et 3 (toutes les colonnes)\n\n  cas         region\n1   2        Mandoul\n3   8 Kasai oriental\n\n\nSoyez attentifs, le type de l’objet renvoyé par [ ] dépend de l’indexation utilisée :\n\nstr(data_cas[1 , ])   # Renvoit un data frame\n\n'data.frame':   1 obs. of  2 variables:\n $ cas   : num 2\n $ region: chr \"Mandoul\"\n\nstr(data_cas[ , 1])   # Renvoit un vecteur\n\n num [1:5] 2 5 8 0 4\n\n\nUne syntaxe simplifiée existe pour extraire des colonnes d’un data frame :\n\ndata_cas[2]           # Renvoit la deuxième colonne (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\ndata_cas[\"region\"]    # Renvoit la colonne région (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\n\n\nEcrivez le code pour :\n\nextraire la troisième valeur de la colonne region de votre data frame\nextraire les deuxième et troisième valeurs de la colonne cas\ncalculer la somme des valeurs de la colonne cas"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-missing-values",
    "href": "sessions_core/01_introduction.html#sec-missing-values",
    "title": "Introduction à R",
    "section": "Valeurs manquantes",
    "text": "Valeurs manquantes\nEn tant qu’épidémiologistes, nous sommes constamment confrontés aux données manquantes. Dans R, celles-ci sont codées à l’aide d’une valeur spéciale : NA [signifiant Not Available]. La valeur NA n’a pas de type fixe, elle prend celui des valeurs qui l’entourent. Par exemple, un NA dans une colonne numérique est traitée comme une valeur numérique. Nous aurons des occasions de manipuler les NA dans la suite du cours."
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-functions",
    "href": "sessions_core/01_introduction.html#sec-functions",
    "title": "Introduction à R",
    "section": "Fonctions",
    "text": "Fonctions\nLes fonctions sont des objets qui contiennent des commandes (au lieu de valeurs) qui sont exécutées chaque fois que la fonction est lancée. Vous êtes sans doute familiers avec les fonctions dans Excel, telles que la fonction SOMME() ou la fonction MOYENNE(). Bonne nouvelle, les fonctions sont similaires dans R !\nLa majorité des fonctions que vous allez utiliser ont besoin d’informations complémentaires : a minima des données, mais aussi d’autres paramètres. On appelle ces informations des arguments. Les arguments sont normalement nommés.\nPar exemple, lorsque nous avons exécuté la commande sum(cas), nous avons fourni le vecteur cas comme premier (et seul) argument de la fonction sum().\nParmis les arguments d’une fonction, certains peuvent être obligatoires, d’autres facultatifs. Le premier argument est presque toujours obligatoire et est souvent un data frame ou un vecteur de données. Comme c’est un argument évident, on omet souvent son nom (il vous a sans doute semblé naturel de taper mean(cas) au lieu de mean(x = cas)).\nLes arguments facultatifs, en revanche, sont généralement utilisés avec neur nom. Par exemple : mean(cas, na.rm = TRUE). Les arguments facultatifs sont souvent fournis avec des valeurs par défaut raisonnables, ce qui fait que l’utilisateur ne les spécifie que lorsqu’il a besoin de changer ces valeurs par défaut. Par exemple, l’argument na.rm de la fonction mean() controle comment les valeurs manquantes sont gérées lors du calcul de la moyenne [“na” en référence aux valeurs manquantes NA, et “rm” comme raccourci de “ReMove”, que l’on peut traduire dans ce contexte par enlever ou ignorer]. Par défault, la valeur de na.rm est FALSE Ainsi, par défaut, la moyenne de données avec des valeurs manquantes renverra toujours NA :\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nCeci est vrai pour de nombreuses opérations arithmétiques dans R. Si l’on veut que que R calcule la moyenne sur toutes les données disponibles et ignore les valeurs manquantes, nous devons explicitement fournir l’argument na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nAstuce\n\n\n\n\nLes arguments sont séparés par des virgules.\nCes virgules doivent toujours être suivies d’un espace\nChaque fois qu’un argument nommé est utilisé, l’attribut = doit être entouré d’espaces :\n\n\nmean(cas,na.rm=TRUE)     # MAUVAIS\nmean(cas, na.rm = TRUE)  # BON\n\nSi vous écrivez une commande avec de nombreux arguments, séparez chaque argument sur sa propre ligne pour améliorer la lisibilité :\n\nmean(cas, \n     na.rm = TRUE) \n\n\n\nQue se passe-t-il si l’on fournit plusieurs arguments dans le désordre ? Si vous avez nommé les arguments la fonction s’exécutera correctement, mais le code sera contre-intuitif et peu lisible. Nous vous conseillons de respecter l’ordre standard, en plaçant les arguments obligatoires tels que les données en premier.\n\n# Fonctionnel mais dur à lire\nmean(na.rm = TRUE,  \n     x = cas) \n\n# mieux\nmean(cas,         \n     na.rm = TRUE)\n\nEn revanche, si vous ne nommez pas les arguments et les passez dans le désordre, alors la fonction ne fonctionnera pas comme prévu, voire renverra une erreur :\n\nmean(TRUE, cas)  # Pas ce que vous attendez"
  },
  {
    "objectID": "sessions_core/01_introduction.html#terminé",
    "href": "sessions_core/01_introduction.html#terminé",
    "title": "Introduction à R",
    "section": "Terminé !",
    "text": "Terminé !\nC’est tout pour cette session, bravo pour vos débuts avec R et RStudio !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html",
    "href": "sessions_core/03_data_verbs.html",
    "title": "Traitement de données, les bases",
    "section": "",
    "text": "Découvrir les fonctions de {dplyr} pour effectuer les actions essentielles sur les données :\n\nSélectionner des colonnes avec select()\nRenommer des colonnes avec rename()\nCréer de nouvelles colonnes ou modifier des colonnes existantes avec mutate()\nSupprimer les doublons avec distinct()\n\nEnchaîner ces actions avec l’opérateur “pipe” |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#objectifs",
    "href": "sessions_core/03_data_verbs.html#objectifs",
    "title": "Traitement de données, les bases",
    "section": "",
    "text": "Découvrir les fonctions de {dplyr} pour effectuer les actions essentielles sur les données :\n\nSélectionner des colonnes avec select()\nRenommer des colonnes avec rename()\nCréer de nouvelles colonnes ou modifier des colonnes existantes avec mutate()\nSupprimer les doublons avec distinct()\n\nEnchaîner ces actions avec l’opérateur “pipe” |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#mise-en-place",
    "href": "sessions_core/03_data_verbs.html#mise-en-place",
    "title": "Traitement de données, les bases",
    "section": "Mise en place",
    "text": "Mise en place\nPrérequis : cette leçon part du principe que vous savez comment utiliser RStudio et que vous êtes capable d’importer des données. Rafraîchissez-vous si besoin avec les deux premières leçons.\n\nNous utiliserons la linelist avec des données brutes que vous avez importée lors de la leçon précédente, et qui peut être téléchargée ici :\n\n\n\n Télécharger les données\n\n\n\n Si ce n’est pas déjà fait, enregistrez le jeu de données dans le sous-dossier approprié de votre projet RStudio puis créez un nouveau script appelé fonctions_donnees.R dans votre sous-dossier R. Ajoutez un en-tête approprié et chargez les paquets suivants : {here}, {rio} et {tidyverse}.  Enfin, ajoutez une section dédiée à l’import des données, utilisez {here} et {rio} pour importer vos données dans R, et assignez-les à un objet que nous appellerons df_brut."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#traiter-ses-données-avec-dplyr",
    "href": "sessions_core/03_data_verbs.html#traiter-ses-données-avec-dplyr",
    "title": "Traitement de données, les bases",
    "section": "Traiter ses données avec {dplyr}",
    "text": "Traiter ses données avec {dplyr}\nLa mise en place est terminée et nous pouvons maintenant nous focaliser sur nos données ! Cette leçon et les suivantes s’appuieront lourdement sur plusieurs paquets de la collection de paquets tidyverse pour manipuler des data frames, résumer et visualiser les données, et en particulier paquet {dplyr} pour aujourd’hui.\nLe traitement des données (aussi appelé manipulation des données) est un ensemble d’actions essentielles pour préparer et nettoyer les données avant une analyse (que ce soit dans R ou Excel). {dplyr} fournit un grand nombre de fonctions qui nous aident à manipuler les data frames et à réaliser de nombreuses tâches quotidiennes telles que :\n\ncréer des sous-ensembles de nos données en ne gardant que les variables d’intérêt\nrenommer des colonnes\najouter ou modifier des colonnes\nsupprimer les doublons\n\nCes fonctions ont en général un nom intuitif, qui correspond à un verbe. Par exemple, pour renommer des colonnes, on utilisera la fonction rename().\nAujourd’hui nous nous focaliserons sur les quatre verbes (fonctions !) qui permettent d’effectuer les tâches mentionnées précédemment, et que vous utiliserez en permanence. Nous vous montrerons également comment enchaîner les actions dans un “pipeline” pour plus de fluidité.\n\n\n\n\n\n\nNote\n\n\n\nPeut-être avez-vous noté que nous vous parlons du paquet {dplyr} mais nous vous avons fait charger le paquet {tidyverse} lors de la mise en place. C’est que le {tidyverse} est un méta-paquet, et le charger charge automatiquement plusieurs des paquets les plus utiles de l’univers du tidyverse, dont fait partie {dplyr} et d’autres paquets que nous verrons dans la session."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#actions-de-base-sur-les-données",
    "href": "sessions_core/03_data_verbs.html#actions-de-base-sur-les-données",
    "title": "Traitement de données, les bases",
    "section": "Actions de base sur les données",
    "text": "Actions de base sur les données\n\nSélectionner des colonnes\nIl est fréquent de souhaiter écarter des variables d’un jeu de données, soit car ces colonnes contiennent des données sensibles, soit parce que nous n’avons pas besoin d’elles pour une analyse donnée. Nous utiliserons pour cela la fonction select(), qui la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nselect(un_dataframe, colonne_a_garder, autre_colonne_a_garder)\n\nIci, le premier argument est le data frame contenant les données. Les arguments suivants sont les noms des colonnes que nous voulons conserver. Dans le tidyverse, les noms de colonnes n’ont pas besoin d’être écrits entre guillemets.\nLa commande suivante nous permet de sélectionner les colonnes id, sex et age, par exemple :\n\nselect(df_brut, id, sexe, age)\n\n\nUtilisez la fonction select() pour sélectionner les variables suivantes de votre data frame : id, sexe, age, sous_prefecture, date_debut et issue. L’en-tête du data frame renvoyé par la fonction ressemble à ceci :\n\n\n  id  sexe age date_debut issue\n1  1 femme  36 2022-08-13 gueri\n2  2     f   5 2022-08-18  &lt;NA&gt;\n3  3     f 156 2022-08-17 gueri\n4  6 homme   8 2022-08-22 gueri\n5  7     h   7 2022-08-30 gueri\n6 10     h   4 2022-08-30 gueri\n\n\n Comparez ce résultat à df_brut. Ce dernier contient toujours toutes les colonnes importées (ce qui est le comportement désiré). Comprenez-vous pourquoi c’est le cas ?\n\nIl arrive que nous ne voulions supprimer que quelques colonnes d’un jeu de données et si le jeu de données est large ça serait fastidieux d’écrire toutes les colonnes à garder comme nous l’avons fait ci-dessus… Heureusement, nous pouvons préfacer un nom de colonne par l’opérateur soustraction (-) pour indiquer à R de la supprimer.\nPar exemple, pour créer un data frame sans la colonne village_commune :\n\nselect(df_brut, -village_commune)\n\n\nUtilisez cette syntaxe pour créer un data frame qui conserve toutes les colonnes de df_brut à l’exception de nom_complet et unite_age.\n\n\n\nRenommer les colonnes\nIl arrive souvent que nous souhaitions renommer des colonnes d’un jeu de données. La fonction rename() est alors votre meilleure amie.\n\n# NE PAS EXÉCUTER (PSEUDO CODE)\nrename(un_dataframe,\n       nouveau_nom_1 = nom_tout_moche,\n       nouveau_nom_2 = autre_nom_pas_fou)\n\nComme pour select(), le premier argument est le data frame qui contient les données (ce sera le cas pour la majorité des verbes de {dplyr}). Ensuite, chaque nouvel argument est une paire nouveau_nom = ancien_nom indiquant à R les colonnes à renommer et leurs nouveaux noms. Nous vous conseillons d’aller à la ligne pour chaque nouvelle paire pour aider à la lisibilité.\nRenommons la colonne village_commune en village par exemple :\n\nrename(df_brut,\n       village = village_commune)\n\n\nUtilisez la fonction rename() sur df_brut pour renommer les colonnes :\n\nsous_prefecture en prefecture\nvillage_commune en village\nnom_structure_sante en structure\n\n\nIl peut être difficile de vérifier si une commande fonctionne car R affiche le data frame en entier. Dans ce cas, une première solution consiste à créer un objet temporaire plus facile à manipuler. Vous pouvez le nommer comme vous voulez, mais un nom commun est temp (ou tmp en anglais).\n\nRépétez le dernier exercice en assignant la sortie de la commande à un objet appelé temp. Vous pouvez alors utiliser la fonction names() pour vérifier que les noms des colonnes ont bien changé. La sortie de names() devrait être :\n\n\n [1] \"id\"                \"nom_complet\"       \"sexe\"             \n [4] \"age\"               \"unite_age\"         \"region\"           \n [7] \"prefecture\"        \"village\"           \"date_debut\"       \n[10] \"date_consultation\" \"hospitalisation\"   \"date_admission\"   \n[13] \"structure\"         \"tdr_paludisme\"     \"fievre\"           \n[16] \"eruption\"          \"toux\"              \"yeux_rouges\"      \n[19] \"pneumonie\"         \"encephalite\"       \"pb\"               \n[22] \"statut_vaccinal\"   \"doses_vaccin\"      \"issue\"            \n[25] \"date_issue\"       \n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLes objets comme le data frame temp sont généralement utilisés pour tester si quelque chose a fonctionné et peuvent donc être écrasés lorsque vous testez autre chose. Ils ne doivent pas être utilisés comme entrée pour d’autres parties de votre code. Utilisez des noms clairs et appropriés pour vos data frames destinés à être réutilisés, tels que df_linelist ou df_propre.\n\n\n\n\nModifier et ajouter des colonnes\nUne autre tâche essentielle du traitement de données est de modifier des colonnes ou d’en créer de nouvelles. La fonction mutate() permet de faire les deux [to mutate veut dire muter en anglais], avec la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nmutate(un_dataframe,\n       nouvelle_colonne_1 = action(colonne_existante),\n       nouvelle_colonne_2 = autre_action(une_autre_colonne_existante))\n\nDans le code ci-dessus nous créons une nouvelle colonne (nouvelle_colonne_1) en effectuant une action (des calculs par exemple) sur une colonne existante (colonne_existante) dans le data frame un_dataframe. Puis nous créons une autre colonne (nouvelle_colonne_2) sur le même principe. L’action en question peut être variée et plus ou moins complexe : calcul arithmétique, application d’une fonction sur une colonne (ou même plusieurs !) etc.\nPar exemple, nous pourrions créer une nouvelle colonne exprimant le périmètre brachial en cm :\n\nmutate(df_brut,\n       pb_cm = pb / 100) # une opération arithmétique simple\n\n\nUtilisez mutate() pour créer une nouvelle colonne age_ans qui exprime l’âge en années plutôt qu’en mois. L’en-tête de la colonne ressemble à ceci :\n\n\n   age_years\n1  3.0000000\n2  0.4166667\n3 13.0000000\n4  0.6666667\n5  0.5833333\n6  0.3333333\n\n\n\nPour modifier une colonne existante il suffit d’utiliser le nom de la colonne existante à gauche du = au lieu de fournir un nouveau nom.\nPar exemple, si nous voulions remplacer la colonne pb qui contenait des valeurs en mm par une colonne pb contenant les valeurs en cm :\n\nmutate(df_brut,\n       pb = pb / 100)\n\nNous voulons souvent conserver la colonne originelle, mais il existe des cas raisonnables où nous souhaitons écraser les données par une nouvelle version. Par exemple :\n\nmodifier des chaînes de caractères (format, correction de typos etc.)\ncorriger le type de données d’une colonne\n\nNotre jeu de données présente ces deux cas. Par exemple les colonnes region et sous_prefecture sont en majuscules, ce qui n’est pas un problème en soi, mais peut être améliorable. Pour corriger cela nous pouvons utiliser la fonction str_to_title() du paquet {stringr} (qui fait également partie du {tidyverse}) pour passer les valeurs en casse “titre”.\n\nmutate(df_brut,\n       region = str_to_title(region),\n       sous_prefecture = str_to_title(sous_prefecture))\n\n\nUtilisez la fonction mutate() pour mettre à jour le format de tdr_paludisme et issue afin d’utiliser la casse “titres”. L’en-tête de la sortie pour ces deux colonnes devrait maintenant être :\n\n\n  tdr_paludisme issue\n1       Negatif Gueri\n2       Negatif  &lt;NA&gt;\n3       Negatif Gueri\n4       Negatif Gueri\n5       Negatif Gueri\n6       Negatif Gueri\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous n’avons pas eu besoin de charger {stringr} car comme {dplyr}, ce paquet est chargé automatiquement lorsque nous chargeons{tidyverse}.\n\n\nPassons maintenant au problème des variables avec le mauvais type.\n\nVérifiez le type de vos colonnes. Y a-t-il des problèmes ?  Indice : str() peut être utile ici.\n\nLes classes semblent raisonnables sauf pour les dates : certaines colonnes ont la classe caractère et d’autres sont POSIXct. Nous préférerions que toutes ces colonnes utilisent le type Date.\nNous allons utiliser la fonction ymd() du paquet {lubridate} pour faire la conversion en Date. “ymd” est l’abréviation de year month day, c’est à dire année-mois-jour. Cela veut dire que la fonction attend une date fournie dans cet ordre-là (les séparateurs peuvent varier).\nPour corriger la date de décharge :\n\nmutate(df_brut,\n       date_issue = ymd(date_issue))\n\n\nUtilisez mutate() et ymd() pour modifier les colonnes date_debut et date_admission afin qu’elles soient de type Date.\nAstuce : n’hésitez pas à stocker la sortie de la fonction dans un data frame temporaire temp pour vérifier le type des variables modifiées.\n\n\n\nSupprimer les doublons\nNous connaissons désormais les fonctions pour sélectionner, renommer et modifier nos variables. Il est temps à présent de passer à une autre tâche essentielle du nettoyage : la suppression doublons.\nLa fonction distinct() permet de rapidement enlever les lignes identiques d’un data frame avec la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndistinct(un_dataframe)\n\nPar défaut, nous n’avons besoin que d’un seul argument : le jeu de données lui-même. Cela supprime alors toutes les lignes qui sont complètement en double en ne gardant qu’une seule copie. Il existe des usages plus sophistiqués de distinct() pour chercher des doublons partiels, mais leur correction dépasserait du cadre de cette session…\n\nUtilisez la fonction distinct() et créez un data frame temporaire, temp qui contient toutes les observations uniques dans df_brut. Comparez le nombre de lignes de temp à celui de df_brut. Avions-nous des doublons ?"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#lopérateur-pipe",
    "href": "sessions_core/03_data_verbs.html#lopérateur-pipe",
    "title": "Traitement de données, les bases",
    "section": "L’opérateur “pipe”",
    "text": "L’opérateur “pipe”\nNous avons profité de la présentation des fonctions essentielles de {dplyr} pour commencer le nettoyage du jeu de données. Il est temps de rassembler les commandes écrites dans les exercices en un ensemble cohérent pour créer un data frame contenant les données netoyées (au moins en partie) que nous appelerons df_linelist.\n\n\n\n\n\n\nAstuce\n\n\n\nEn général, il est recommandé de conserver une version brute de votre ensemble de données, ici df_brut, qui reste inchangée dans votre code. Ainsi, vous l’avez toujours à disposition dans votre environnement comme référence et elle est toujours disponible au début de votre pipeline de nettoyage pour améliorer la reproductibilité.\n\n\nIl y a plusieurs manières d’enchaîner les différentes étapes que nous avons vues. Intuitivement, nous pourrions commencer comme ceci :\n\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sous_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\nPuis mettre à jour df_linelist :\n\n# Étape 1 : Renommer les variables\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sub_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\n# Étape 2 : Sélectionner les variables à conserver\ndf_linelist &lt;- select(df_linelist,\n                      -nom_complet)\n\nNotez que dans cette deuxième étape, nous utilisons df_linelist comme entrée de select() plutôt que df_brut car nous voulons continuer à travailler sur la version modifiée des données.\nPuis nous ajoutons l’âge en années :\n\n# Étape 1 : Renommer les variables\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sub_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\n# Étape 2 : Sélectionner les variables à conserver\ndf_linelist &lt;- select(df_linelist,\n                      -nom_complet)\n\n# Étape 3 : Ajouter l'âge en années\ndf &lt;- mutate(df_linelist,\n             age_ans = age / 12)\n\nEt caetera. Ce code est tout à fait fonctionnel, mais devient lourd et répétitif si de nombreuses étapes s’enchaînent : à chaque étape nous utilisons en entrée le data frame renvoyé par l’étape précédente pour le mettre à jour…\nIl existe un raccourcis ! L’opérateur pipe (|&gt;) permet d’enchainer des actions de manière plus fluide avec cette syntaxe :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nune_entree |&gt; une_action\n\n# En particulier :\nun_dataframe |&gt; une_fonction()\n\nIci, le pipe prend l’entrée fournie à gauche et la transmet à la fonction à droite. Ainsi, par exemple, au lieu d’écrire\n\nselect(df_brut, id, sexe)\n\nnous pouvons écrire\n\ndf_brut |&gt; select(id, sexe)\n\n\nTestez le code ci-dessus de votre côté.\n\nOn peut se servir de l’opérateur pipe pour enchaîner plusieurs actions. C’est le style de code dit “du tidyverse”, qui ressemble à ceci :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf_linelist &lt;- df_brut |&gt;\n  action_1() |&gt;\n  action_2() |&gt;\n  action_3() |&gt;\n  ...\n\n\n\n\n\n\n\nAstuce\n\n\n\nAller à la ligne entre chaque action est considéré comme une bonne pratique pour rendre le code plus facile à lire et à comprendre.\n\n\nNous pourrions donc remplacer le code précédent par ceci :\n\ndf_linelist &lt;- df_brut |&gt;\n  rename(prefecture = sub_prefecture,\n         village    = village_commune,\n         facility   = health_facility_name) |&gt;\n  select(-full_name) |&gt;\n  mutate(age_years = age / 12)\n\nC’est beaucoup plus fluide que de réaffecter df_linelist après chaque étape !\n\nA votre tour ! Rassemblez maintenant toutes les étapes de nettoyage de la leçon en une seule commande en un seul pipeline.\nUtilisez l’opérateur pipe |&gt;, les fonctions select() rename(), mutate(), str_to_title(), ymd() et distinct() pour créer un data frame df_linelist partiellement nettoyé.  Rappel des étapes :\n\nSupprimer les variables nom_complet et unite_age\nRenommer les variables suivantes :\n\nage devient age_ans\nsous_prefecture devient prefecture\nvillage_commune devient village\nnom_structure_sante devient structure\n\nAjouter une variable age_ans avec l’âge du patient en années\nMettre à jour region et prefecture pour utiliser la casse de titre\nMettre à jour toutes les colonnes contenant des dates pour utiliser le type Date\nSupprimer toutes les lignes en double\n\nL’en-tête de vos données finales devrait ressembler à ceci :\n\n\n  id  sexe age_mois  region prefecture        village date_debut\n1  1 femme       36 Mandoul   Moissala Sangana Koïtan 2022-08-13\n2  2     f        5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3     f      156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 homme        8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7     h        7 Mandoul   Moissala      Tétindaya 2022-08-30\n6 10     h        4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             oui     2022-08-14\n2        2022-08-25             oui     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25             non           &lt;NA&gt;\n5        2022-09-02             non           &lt;NA&gt;\n6        2022-09-02             oui     2022-09-02\n                        structure tdr_paludisme fievre eruption toux\n1 Hôpital du District de Moissala       negatif     No     &lt;NA&gt;  Yes\n2 Hôpital du District de Moissala       negatif     No       No  Yes\n3                      CS Silambi       negatif    Yes     &lt;NA&gt;   No\n4 Hôpital du District de Moissala       negatif     No       No   No\n5                      CS Silambi       negatif   &lt;NA&gt;       No  Yes\n6                    Moissala Est       negatif    Yes       No   No\n  yeux_rouges pneumonie encephalite  pb statut_vaccinal doses_vaccin issue\n1          No        No          No 244            &lt;NA&gt;         &lt;NA&gt; gueri\n2          No      &lt;NA&gt;          No 232             Non         &lt;NA&gt;  &lt;NA&gt;\n3          No        No        &lt;NA&gt; 123      Oui - oral         &lt;NA&gt; gueri\n4        &lt;NA&gt;        No          No 210             Non         &lt;NA&gt; gueri\n5         Yes        No          No  80             Non         &lt;NA&gt; gueri\n6        &lt;NA&gt;        No          No 220             Non         &lt;NA&gt; gueri\n  date_issue    age_ans\n1 2022-08-18  3.0000000\n2 2022-08-28  0.4166667\n3       &lt;NA&gt; 13.0000000\n4       &lt;NA&gt;  0.6666667\n5       &lt;NA&gt;  0.5833333\n6 2022-09-03  0.3333333\n\n\nAstuce :  soyez attentifs à vos noms de colonne. Si vous rennomez une colonne, il faudra utiliser le nouveau nom dans les étapes suivantes du pipeline.\n\nFantastique ! C’est un excellent début de pipeline de nettoyage de vos données. Sauvegardez ce code, car nous le complèterons lors de la prochaine session, durant laquelle nous apprendron une autre étape essentielle du traitement de données : recoder les variables !"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#cest-fini",
    "href": "sessions_core/03_data_verbs.html#cest-fini",
    "title": "Traitement de données, les bases",
    "section": "C’est fini !",
    "text": "C’est fini !\nBravo, vous avez appris les bases de la manipulation de données et comment enchaîner plusieurs commandes dans un pipeline. À partir de maintenant, les fichiers contenant les solutions des exercices fourniront le code final plutôt qu’une correction par exercice, afin d’avoir un script plus réaliste. Par exemple, la solution fournira le pipe final créé à la fin de la session d’aujourd’hui.\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#aller-plus-loin",
    "href": "sessions_core/03_data_verbs.html#aller-plus-loin",
    "title": "Traitement de données, les bases",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices supplémentaires\n\nAjoutez une ligne à votre mutate() pour mettre à jour la variable hospitalisation afin que son texte soit également en casse “titre”\nPeut-être préféreriez-vous utiliser des minuscules pour la colonne region plutôt que la casse “titre” ? Mettez votre code à jour pour le faire. Astuce : vous pouvez utiliser la fonction apprises dans la première session ou tester la fonction str_to_lower() de {stringr}.\nCréez une colonne delai_consultation, qui contient le nombre de jours entre l’apparition des symptômes et la consultation."
  },
  {
    "objectID": "sessions_core/05_summary_table.html",
    "href": "sessions_core/05_summary_table.html",
    "title": "Tableaux récapitulatifs",
    "section": "",
    "text": "Créer des tableaux de contingence avec count()\nCalculer des statistiques récapitulatives par groupe à l’aide de summarize()\nRéviser comment sélectionner les lignes en utilisant filter() et créer/modifier des variables avec mutate()\nCréer des variables catégorielles ordonnées"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#objectifs",
    "href": "sessions_core/05_summary_table.html#objectifs",
    "title": "Tableaux récapitulatifs",
    "section": "",
    "text": "Créer des tableaux de contingence avec count()\nCalculer des statistiques récapitulatives par groupe à l’aide de summarize()\nRéviser comment sélectionner les lignes en utilisant filter() et créer/modifier des variables avec mutate()\nCréer des variables catégorielles ordonnées"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#configuration",
    "href": "sessions_core/05_summary_table.html#configuration",
    "title": "Tableaux récapitulatifs",
    "section": "Configuration",
    "text": "Configuration\nDépendances. Cette session suppose que vous savez utiliser RStudio, que vous êtes capable d’importer des données et que vous connaissez les verbes de base de manipulation des données que nous avons vus dans les sessions de base jusqu’à présent. Si vous avez besoin d’un rappel sur l’un de ces sujets, nous vous encourageons à revoir les sessions de base du parcours d’apprentissage.\n\nCette session utilisera la version nettoyée de l’ensemble de données Moissala sur la rougeole. Téléchargez les données et stockez-les dans data/clean dans votre projet d’entraînement :\n\n\n\n Linelist rougeole nettoyée\n\n\n\n Ouvrez votre projet RStudio et créez un nouveau script dans le sous-dossier R appelé tables.R avec les métadonnées appropriées et une section “Packages” qui importe : {rio}, {here} et {tidyverse}. Ajoutez une section “Import Data” qui charge la version nettoyée de la linelist de la rougeole dans R."
  },
  {
    "objectID": "sessions_core/05_summary_table.html#introduction-agrégation-des-données",
    "href": "sessions_core/05_summary_table.html#introduction-agrégation-des-données",
    "title": "Tableaux récapitulatifs",
    "section": "Introduction : agrégation des données",
    "text": "Introduction : agrégation des données\nRécapitulons. Vous venez d’effectuer l’une des tâches les [plus importantes]{.hovertip bs-toggle=‘tooltip’ bs-title=’Certains considèrent que cela représente 80 % du travail !} d’un épidémiologiste : le nettoyage des données. Maintenant que vous disposez de données propres et normalisées, vous pouvez vous mettre au travail et commencer à les analyser. Les analyses commencent généralement par des tableaux et des résumés qui décrivent nos données :\n\nTableaux de fréquence univariés pour compter les occurrences de différentes valeurs\nStatistiques sommaires des variables numériques (moyenne, médiane, écart-type)\nTableaux croisés pour examiner les relations entre les variables catégorielles\nRésumés par groupe pour comparer les statistiques entre différents sous-ensembles de données"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#compter-plusieurs-colonnes-tableaux-de-contingence",
    "href": "sessions_core/05_summary_table.html#compter-plusieurs-colonnes-tableaux-de-contingence",
    "title": "Tableaux récapitulatifs",
    "section": "Compter plusieurs colonnes (tableaux de contingence)",
    "text": "Compter plusieurs colonnes (tableaux de contingence)\nAu cours de la session d’exploration des données, vous avez appris à créer un tableau de fréquence pour une variable catégorielle unique à l’aide de la fonction count(). C’est bien, mais nous voulons souvent compter le nombre d’observations en fonction de deux variables (ou plus !).\nCes tableaux sont appelés tableaux de contingence. Par exemple, connaître le nombre de patients par sous-préfecture est très utile, mais nous pourrions vouloir stratifier à la fois par sous-préfecture et par groupe d’âge pour voir si certaines zones ont des patients anormalement âgés. Ce type de stratification est un moyen utile d’essayer de trouver des zones qui pourraient être de bons candidats pour des campagnes de rattrapage. C’est facile, il suffit de passer plusieurs noms de colonnes à count() :\n\ndf_linelist |&gt;\n  count(sous_prefecture, age_groupe)\n\n\nCréez un nouveau tableau récapitulatif en comptant le nombre de patients stratifiés par sous_prefecture et hospitalisation. Que se passe-t-il si vous modifiez l’ordre des arguments donnés à count() ?\nMaintenant, en utilisant count(), réponds aux questions suivantes :\n\nCombien de patients étaient des femmes ? Quelle est la proportion ?\nQuelles sont toutes les valeurs possibles de la variable statut_sortie ?\nCombien de patients âgés de 1 à 4 ans se sont rétablis ?"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#filtrer-les-valeurs-na",
    "href": "sessions_core/05_summary_table.html#filtrer-les-valeurs-na",
    "title": "Tableaux récapitulatifs",
    "section": "Filtrer les valeurs NA",
    "text": "Filtrer les valeurs NA\nEn examinant les catégories du statut_sortie, vous devriez avoir remarqué que certaines patientes ont des valeurs manquantes (NA):\n\ndf_linelist |&gt;\n  count(statut_sortie) |&gt;\n  mutate(prop = n / sum(n))\n\n\nObservez le résultat du code ci-dessus. Comment pouvez-vous également calculer la proportion de patients décédés ? Êtes-vous satisfait de ce calcul ?\n\nLa proportion de cas décédés est également appelée taux de létalité. Pour calculer précisément le CFR, nous devons nous assurer que le dénominateur ne comprend que les patients dont nous sommes sûrs du résultat (c’est-à-dire que nous devons supprimer tous les cas avec “NA” ou “contre avis médical”).\nRappelons que nous pouvons le faire en utilisant filter(). Pour garder les valeurs manquantes (NA) dans une variable, nous pouvons utiliser la petite fonction is.na(statut_sortie). L’ajout d’un ! devant fera l’inverse : supprimer les valeurs manquantes de statut_sortie :\n\ndf_linelist |&gt;\n  filter(statut_sortie != \"sortie contre avis medical\", \n         !is.na(statut_sortie)) |&gt;\n  count(statut_sortie)\n\n\nQuelle autre instruction conditionnelle pourriez-vous utiliser dans filter() pour obtenir les mêmes résultats ?\n\nMaintenant que nous avons supprimé les patients dont l’issue est inconnue, nous pouvons ajouter ceci avant de créer notre tableau de fréquence pour obtenir le CFR correct.\n\nÀ l’aide de votre filtre, mettez à jour votre code pour résumer le nombre observé de patients qui ont survécu et sont décédés ainsi que le taux de létalité (proportion de décès). Stockez ce nouveau dataframe dans un objet, cfr_df.\n\n\n\n\n\n\n\nAstuce\n\n\n\nBonus. Une fonction de “raccourci” utile est drop_na() du package {tidyr} qui équivaut à filter(!is.na()).\n\ndf_linelist |&gt;\n  drop_na(statut_sortie) |&gt;\n  count(statut_sortie)\n\ndrop_na() est particulièrement utile car vous pouvez lui donner plusieurs noms de colonnes pour filtrer. Mais attention, cela supprimera toutes les lignes où une ou plusieurs de ces colonnes ont une valeur manquante."
  },
  {
    "objectID": "sessions_core/05_summary_table.html#tableau-récapitulatif-statistiques-par-sous-préfecture",
    "href": "sessions_core/05_summary_table.html#tableau-récapitulatif-statistiques-par-sous-préfecture",
    "title": "Tableaux récapitulatifs",
    "section": "Tableau récapitulatif : statistiques par sous-préfecture",
    "text": "Tableau récapitulatif : statistiques par sous-préfecture\nMaintenant que nous avons produit quelques tableaux de fréquence et de contingence simples, nous pouvons augmenter la complexité. Une tâche courante en épidémiologie consiste à examiner les statistiques résumées dans des sous-ensembles de données.\nPar exemple, on peut nous demander de produire des statistiques sur les patients au niveau des sous-préfectures, c’est-à-dire que pour chaque sous-préfecture dans les données, nous devons répondre aux questions suivantes :\n\nCombien de patients ont été consultés ?\nQuel est leur âge moyen ?\nQuelle a été la date d’admission la plus ancienne ?\nCombien de patients ont été hospitalisés ?\nParmi les enfants de moins de 6 mois, combien sont décédés ?\n\nC’est exactement pour cela que la fonction summarize() a été créée ! Elle nous permet de calculer des statistiques résumées sur un ensemble de données, et la syntaxe est similaire à celle de mutate() :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;\n  mutate(new_col = function_to_create(existing_col))\n\ndf |&gt;\n  summarize(.by = grouping_variable,\n            new_col = summary_function(existing_col))\n\nConsidérons le code suivant, où nous résumons les données pour calculer l’âge moyen de tous les patients.\n\ndf_linelist |&gt;\n  summarize(moy_age = mean(age))\n\n# A tibble: 1 × 1\n  moy_age\n    &lt;dbl&gt;\n1    6.82\n\n\nNotez que ce code donne une seule valeur pour l’âge moyen. Aucune variable de regroupement n’a été fournie, donc summarize() a renvoyé une statistique récapitulative pour l’ensemble du jeu de données. Pour calculer l’âge moyen par strate spécifique, nous devons spécifier une variable de regroupement en utilisant l’argument .by :\n\ndf_linelist |&gt;\n  summarize(.by = sexe, # Faire le résumé (ici, la moyenne) par sexe\n            moy_age = mean(age))\n\n# A tibble: 2 × 2\n  sexe  moy_age\n  &lt;chr&gt;   &lt;dbl&gt;\n1 f        6.77\n2 m        6.87\n\n\n\nJetez un œil aux résultats ci-dessus. Comment les interprétez-vous ?\n\nMaintenant que nous pouvons utiliser summarize(), nous pouvons l’utiliser pour calculer des statistiques récapitulatives appropriées par sous-préfecture. Commençons par appeler un summarize() vide et regrouper les données sur sous_prefecture.\n\nExécutez le code suivant :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture)\n\nQue se passe-t-il lorsque vous exécutez ces lignes ?\n\n\nComptages\nNous voulons d’abord examiner le nombre de cas dans chaque sous_prefecture. Cela peut être fait en utilisant la fonction d’aide n() :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n()  # pour compter\n)\n\n\nOk, maintenant construisons un tableau récapitulatif pour chaque sous-préfecture. Commençons par reproduire les lignes ci-dessus.\n\n\n\nRécapitulatifs des variables continus\nNous pouvons ensuite utiliser les fonctions mean(), median(), min(), max() (et autres) pour produire des récapitulatifs pour les variables continues. Par exemple, l’âge moyen :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n(),\n            mean_age = mean(age))\n\n\nAjoutez la date d’admission minimale à votre tableau pour chacune des sous_prefecture ? Êtes-vous satisfait des résultats ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN’oubliez pas qu’avec les fonctions arithmétiques telles que mean(), median(), min(), max(), vous devez indiquer explicitement à R de supprimer NA.\n\n\n\n\nComptage avec une condition\nNous pouvons également être intéressés par le nombre de patients (lignes) qui répondent à une condition : le nombre de patients de sexe féminin. Le comptage par condition logique peut être effectué avec la syntaxe suivante :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\nsummarize(sum_category = sum(LOGIC_TEST, na.rm = TRUE))\n\nCette somme nous permet de compter toutes les lignes où notre condition a été remplie (retourne TRUE). Par exemple :\nCette somme nous permet de compter toutes les lignes où notre condition a été remplie (retourne TRUE). Par exemple :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_female = sum(sexe == \"f\", na.rm = TRUE))\n\n\nAjoutez une variable à votre tableau qui compte le nombre de patients qui ont été hospitalisés. (c’est-à-dire : les lignes qui ont “oui” dans la variable “hospitalisation”)\n\n\n\nAutres statistiques\nParfois, nous voulons produire une statistique plus compliquée, par exemple l’âge moyen de tous les patients hospitalisés. Ici, la syntaxe est un peu différente :\n\n# NE PAS EXÉCUTER (PSEUDO-CODE)\ndf |&gt;\n  summarize(mean_category = mean(col_to_use[LOGIC_TEST], na.rm = TRUE))\n\nIci, nous avons : - Indiqué quelle statistique de synthèse nous voulons utiliser (mean()) - Indiqué sur quelle colonne nous voulons calculer cette statistique (col_to_use) - Création d’une condition indiquant les observations de cette colonne à utiliser dans le calcul ([LOGIC_TEST])\nPour donner un exemple concret, si nous voulions calculer la moyenne de la variable age mais uniquement pour les patients hospitalisés (c’est-à-dire dans les lignes où hospitalisation == \"oui\") nous écririons :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n(),\n            moy_age_hosp = mean(age[hospitalisation == \"oui\"], na.rm = TRUE))\n\nL’utilisation d’un test logique dans l’exemple ci-dessus est appelée indexation logique, où une condition est essentiellement utilisée pour filtrer les observations que vous souhaitez prendre en compte lors d’un calcul. L’indexation logique est très puissante, mais elle peut aussi demander un certain temps d’adaptation, alors ne vous inquiétez pas trop si ce n’est pas parfaitement clair à ce stade.\n\nPouvez-vous utiliser cette syntaxe pour calculer l’âge moyen des patientes dans votre tableau ?\n\nC’est très bien ! Nous commençons à obtenir un tableau récapitulatif groupé assez exhaustif avec beaucoup d’informations utiles par “sous-préfecture” ! Un défi supplémentaire pour vous :\n\nDÉFI : Pourriez-vous ajouter une variable à votre tableau qui compte le nombre de patients décédés parmi ceux qui ont &lt; 6 mois.\n Note. Vous voulez compter les lignes (donc utiliser sum()) qui remplissent une condition spécifique pour le résultat (statut_sortie == \"deces\"), mais uniquement lorsque age_group == \"&lt; 6 months\"\n\n\n\nUtiliser la sortie\nEnfin, n’oubliez pas que summarize() renvoie un dataframe que nous pouvons ensuite manipuler davantage (par exemple : avec filter() et mutate()).\n\nAjoutez un mutate() après avoir produit votre tableau récapitulatif pour calculer :\n\nLa proportion de patients hospitalisés par sous-préfecture\nLa proportion de patientes par sous-préfecture\n\n\nL’en-tête de votre tableau final devrait ressembler à ceci :\n\n\n# A tibble: 6 × 11\n  sous_prefecture n_patients moy_age min_admission n_femme n_hosp moy_age_hosp\n  &lt;chr&gt;                &lt;int&gt;   &lt;dbl&gt; &lt;date&gt;          &lt;int&gt;  &lt;int&gt;        &lt;dbl&gt;\n1 Moissala              1808    6.84 2022-08-14        923    612         5.49\n2 Bouna                 1376    6.56 2023-01-11        669    412         5.67\n3 Bedjondo               534    7.07 2023-06-09        251    184         5.21\n4 Bekourou               496    6.84 2023-06-17        251    164         6.04\n5 Bedaya                 435    7.10 2023-07-04        209    147         6.16\n6 Koumra                 253    7.11 2023-08-14        138     84         6.26\n# ℹ 4 more variables: moy_age_femme &lt;dbl&gt;, n_deces_moins_6m &lt;int&gt;,\n#   prop_female &lt;dbl&gt;, prop_hosp &lt;dbl&gt;"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#cest-fait",
    "href": "sessions_core/05_summary_table.html#cest-fait",
    "title": "Tableaux récapitulatifs",
    "section": "C’est fait !",
    "text": "C’est fait !\nVous devriez être fiers de vous, la création de tableaux récapitulatifs est une compétence importante pour un épidémiologiste, et le faire en R est très efficace ! N’oubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#pour-aller-plus-loin",
    "href": "sessions_core/05_summary_table.html#pour-aller-plus-loin",
    "title": "Tableaux récapitulatifs",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices supplémentaires\n\nCréez un tableau récapitulatif qui calcule les statistiques suivantes par groupes d’âge :\n\n\nLe nombre de patients\nLa proportion d’hommes\nLe nombre de décès\nLe CFR\nLe nombre de décès parmi les patients atteints de pneumonie\n\n\nFaites un tableau qui montre la proportion de patients par âge ayant reçu un vaccin contre la rougeole (par rappel oral ou par carte) et ceux qui ont reçu 1 ou 2 doses.\nFaites un tableau comparant la proportion de patients hospitalisés et non hospitalisés présentant un TDR positif pour le paludisme, de la fièvre, une éruption cutanée, une toux, des yeux rouges, une pneumonie, une encéphalite et un MUAC « rouge » ou « jaune » (moins de 125 mm).\nCalculer le nombre moyen de jours entre l’apparition des premiers symptômes et la consultation par sous-préfecture.\nCalculer le temps moyen passé à l’hôpital (i.e. jours entre l’admission et le résultat) par résultat (i.e. chez ceux qui ont guéri et ceux qui sont décédés).\n\n\n\nRessources supplémentaires\n\nLe chapitre du manuel EpiR sur le regroupement des données\nUne fois que vous avez des tableaux, vous pouvez les personnaliser en profondeur pour l’affichage/la publication à l’aide du paquetage {gt} :\n\nSite web de gt\nLivre sur gt"
  }
]