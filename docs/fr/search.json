[
  {
    "objectID": "sessions_extra/weekly_epicurves.html",
    "href": "sessions_extra/weekly_epicurves.html",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "",
    "text": "Dans la session principale sur les grapiques, vous avez appris √† tracer une courbe √©pid√©mique du nombre de cas journaliers :\n\n\n\n\n\n\n\n\n\nIci les donn√©es sont agr√©g√©es par jour, ce qui raisonnable si l‚Äô√©pid√©mie est de courte dur√©e ou si vous souhaitez zoomer sur une p√©riode sp√©cifique. Il nous arrivera n√©anmoins de souvent vouloir tracer des courbes hebdomadaires.\nDans cette tutoriel, nous apprendrons √† agr√©ger les donn√©es par semaine, √† tracer le graphique et √† am√©liorer les √©tiquettes de l‚Äôaxe des abscisses.\nPr√©requis : la session sur les courbes √©pid√©miques."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#objectifs",
    "href": "sessions_extra/weekly_epicurves.html#objectifs",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "",
    "text": "Dans la session principale sur les grapiques, vous avez appris √† tracer une courbe √©pid√©mique du nombre de cas journaliers :\n\n\n\n\n\n\n\n\n\nIci les donn√©es sont agr√©g√©es par jour, ce qui raisonnable si l‚Äô√©pid√©mie est de courte dur√©e ou si vous souhaitez zoomer sur une p√©riode sp√©cifique. Il nous arrivera n√©anmoins de souvent vouloir tracer des courbes hebdomadaires.\nDans cette tutoriel, nous apprendrons √† agr√©ger les donn√©es par semaine, √† tracer le graphique et √† am√©liorer les √©tiquettes de l‚Äôaxe des abscisses.\nPr√©requis : la session sur les courbes √©pid√©miques."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#mise-en-place",
    "href": "sessions_extra/weekly_epicurves.html#mise-en-place",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "Mise en place",
    "text": "Mise en place\n\nNous utiliserons la m√™me liste lin√©aire nettoy√©e que pr√©c√©demment et qui peut √™tre t√©l√©charg√©e ici :\n\n\n\n T√©l√©charger les donn√©es\n\n\n\n Si ce n‚Äôest pas d√©j√† fait, enregistrez le jeu de donn√©es dans data/clean puis cr√©ez un nouveau script appel√© courbe_hebdo.R dans votre sous-dossier R (alternativement, vous pouvez rajouter une section au script sur les courbes √©pid√©miques journali√®res).\n Si vous cr√©ez un nouveau script, ajoutez un en-t√™te appropri√© et chargez les paquets suivants : {here}, {rio}, {tidyverse} et {scales}. Importez ensuite les donn√©es propres (moissala_linelist_clean_FR.rds) dans R et enregistrez-les dans un objet df_linelist.\n\nAu cours du tutoriel, les exemples porteront sur les sorties et vous tracerez la courbe √©pid√©mique √† partir de la date de d√©but des sympt√¥mes."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#donn√©es-hebdomadaires",
    "href": "sessions_extra/weekly_epicurves.html#donn√©es-hebdomadaires",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "Donn√©es hebdomadaires",
    "text": "Donn√©es hebdomadaires\nNous allons aborder deux fa√ßons d‚Äôagr√©ger les donn√©es par semaine. Le concept de la premi√®re vous sera sans doute familier (semaines identifi√©es par leur num√©ros), mais nous nous concentrerons sur une m√©thode plus robuste (semaine identifi√©es par la date du premier jour de la semaine).\n\nNum√©ros de semaine\nLa mani√®re la plus intuitive de d‚Äôagr√©ger par semaine est d‚Äôutiliser des num√©ros de semaines, car les donn√©es du MSP sont souvent dans ce format. Vous avez sans doute cr√©√© de nombreuses courbes √©pid√©miques dans ce format vous-m√™mes.\nLa fonction isoweek() du paquet {lubridate} accepte une date (ou un vecteur de dates) et renvoie le num√©ro de semaine ISO.\n\nexemple_date &lt;- as.Date('2025-02-24')\n\nexemple_date\n\n[1] \"2025-02-24\"\n\nisoweek(exemple_date)\n\n[1] 9\n\n\nNous pouvons utiliser cette fonction pour cr√©er une colonne sem_sortie_num dans nos donn√©es :\n\ndf_linelist &lt;- df_linelist |&gt; \n  mutate(sem_sortie_num = isoweek(date_sortie))\n\nLe d√©but des colonnes date_sortie et sem_sortie_num ressemble √† ceci (sans les NA) :\n\ndf_linelist |&gt; \n  tidyr::drop_na(date_sortie) |&gt; \n  select(date_sortie, sem_sortie_num) |&gt; \n  head()\n\n  date_sortie sem_sortie_num\n1  2022-08-18             33\n2  2022-08-28             34\n3  2022-09-03             35\n4  2022-09-12             37\n5  2022-09-10             36\n6  2022-09-18             37\n\n\n\nA vous de jouer. Utilisez les fonctions mutate() et isoweek() pour cr√©er une nouvelle colonne dans votre data frame appel√©e sem_symptomes_num qui contient la semaine ISO associ√©e √† chaque date de d√©but des sympt√¥mes. L‚Äôen-t√™te des colonnes date_debut et sem_symptomes_num devrait ressembler √† ceci :\n\n\n  date_debut sem_symptomes_num\n1 2022-08-13                32\n2 2022-08-18                33\n3 2022-08-17                33\n4 2022-08-22                34\n5 2022-08-30                35\n6 2022-08-30                35\n\n\n\nNous pourrions maintenant utiliser count() sur cette colonne pour agr√©ger les donn√©es par semaine, puis tracer le graphique avec {ggplot2} avec un code tr√®s similaire √† la session principale.\nMalheureusement il y a un probl√®me. Avec le num√©ro de semaine il y a une premi√®re semaine en 2022‚Ä¶ mais aussi en 2023, 2024 etc. Dans le cas d‚Äôune √©pid√©mie courte qui n‚Äôaurait lieu qu‚Äôen 2022, cela ne poserait pas probl√®me. Cependant, notre data frame contient des donn√©es de la r√©gion enti√®re, et les dates s‚Äô√©tendent de 2022 √† 2023. Donc si nous comptions le nombre de patient par num√©ro de semaine, le tableau suivant serait erron√© :\n\n# FAUX\ndf_linelist |&gt; \n  count(sem_symptomes_num) |&gt; \n  head(10)\n\n   sem_symptomes_num  n\n1                  1 36\n2                  2 35\n3                  3 42\n4                  4 56\n5                  5 70\n6                  6 78\n7                  7 85\n8                  8 49\n9                  9 62\n10                10 81\n\n\nPour r√©soudre le probl√®me nous pouvons stratifier par ann√©e :\n\ndf_linelist |&gt; \n  mutate(annee_symptomes = isoyear(date_debut)) |&gt; \n  count(annee_symptomes, sem_symptomes_num) |&gt; \n  head(10)\n\n   annee_symptomes sem_symptomes_num  n\n1             2022                32  1\n2             2022                33  2\n3             2022                34  1\n4             2022                35  8\n5             2022                36  8\n6             2022                37 10\n7             2022                38 17\n8             2022                39 17\n9             2022                40 19\n10            2022                41 16\n\n\nCes chiffres sont d√©sormais corrects. Vous pourriez les repr√©senter avec plusieurs mini graphes par ann√©e sur une m√™me figure, ou simplement filtrer une ann√©e donn√©e et tracer la courbe avec les num√©ros de semaines sur l‚Äôaxe des x. Dans le premier cas, cela donnerait ceci :\n\ndf_linelist |&gt; \n  mutate(annee_symptomes = isoyear(date_debut)) |&gt; \n  count(annee_symptomes, sem_symptomes_num) |&gt; \n  ggplot(aes(x = sem_symptomes_num,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  theme_classic(base_size = 16) +\n  facet_wrap(vars(annee_symptomes),  # Magie pour faire le graphe par ann√©e !\n             ncol = 1)\n\n\n\n\n\n\n\n\nSi vous n‚Äôavez pas lu le satellite sur facet_wrap(), ce n‚Äôest pas grave, voyez ce graphe comme une page de publicit√© pour la capacit√© de ggplot √† faire des graphes multiples rapidement. Les explications sortent du cadre de ce tutoriel et nous allons vous montrer une autre fa√ßon d‚Äôagr√©ger les donn√©es par semaine, qui est robuste aux donn√©es pluriannuelles.\n\n\nPremier jour de la semaine\nUne autre mani√®re d‚Äôagr√©ger par semaine est d‚Äôutiliser la fonction floor_date() (√©galement du package {lubridate}), qui renvoie la premi√®re date d‚Äôune p√©riode donn√©e. Vous pouvez la consid√©rer comme une sorte d‚Äôarrondi √† la plus petite valeur, mais pour les dates.\nLa fonction a un argument unit pour choisir l‚Äô√©chelle de la p√©riode (semaine, mois‚Ä¶) et un argument week_start pour d√©finir le premier jour de la semaine (les lundis sont 1).\n\ndf_linelist &lt;- df_linelist |&gt; \n  mutate(\n    sem_sortie_lundi = floor_date(date_sortie,\n                                  unit = \"week\",\n                                  week_start = 1)\n  )\n\nRegardons les diff√©rentes colonnes de plus pr√®s pour bien comprendre :\n\ndf_linelist |&gt; \n  select(date_sortie, sem_sortie_num, sem_sortie_lundi) |&gt;\n  arrange(date_sortie) |&gt;     # Trie par date\n  head(n = 10)\n\n   date_sortie sem_sortie_num sem_sortie_lundi\n1   2022-08-18             33       2022-08-15\n2   2022-08-28             34       2022-08-22\n3   2022-09-03             35       2022-08-29\n4   2022-09-10             36       2022-09-05\n5   2022-09-12             37       2022-09-12\n6   2022-09-12             37       2022-09-12\n7   2022-09-16             37       2022-09-12\n8   2022-09-17             37       2022-09-12\n9   2022-09-18             37       2022-09-12\n10  2022-09-19             38       2022-09-19\n\n\nPour aider √† comprendre on peut calculer le jour de la semaine associ√© √† chaque date en utilisant la fonction wday() (qui appartient aussi √† {lubridate}, y a comme un th√®me üòâ) [wday est une abr√©viation pour week day] :\n\ndf_linelist |&gt; \n  # Calcule le premier jour de la semaine\n  mutate(\n    jour_sortie = wday(date_sortie, \n                       label = TRUE, \n                       abbr = FALSE),\n    cest_bien_un_lundi  = wday(sem_sortie_lundi, \n                               label = TRUE, \n                               abbr = FALSE)) |&gt; \n  arrange(date_sortie) |&gt;      # Trie par date\n  select(date_sortie,\n         jour_sortie,\n         sem_sortie_num,\n         sem_sortie_lundi,\n         cest_bien_un_lundi) |&gt; \n  head(n = 10)\n\n   date_sortie jour_sortie sem_sortie_num sem_sortie_lundi cest_bien_un_lundi\n1   2022-08-18       jeudi             33       2022-08-15              lundi\n2   2022-08-28    dimanche             34       2022-08-22              lundi\n3   2022-09-03      samedi             35       2022-08-29              lundi\n4   2022-09-10      samedi             36       2022-09-05              lundi\n5   2022-09-12       lundi             37       2022-09-12              lundi\n6   2022-09-12       lundi             37       2022-09-12              lundi\n7   2022-09-16    vendredi             37       2022-09-12              lundi\n8   2022-09-17      samedi             37       2022-09-12              lundi\n9   2022-09-18    dimanche             37       2022-09-12              lundi\n10  2022-09-19       lundi             38       2022-09-19              lundi\n\n\nCeci illustre comment sem_sortie_num et sem_sortie_lundi sont deux fa√ßons de repr√©senter une semaine donn√©e. Mais si les num√©ros de semaine ne sont pas uniques, les dates, elles, le sont !\n\nAjoutez une nouvelle instruction √† votre mutate() pour cr√©er la variable sem_symptomes_lundi qui contient le premier jour de la semaine pour la date d‚Äôapparition des sympt√¥mes. Le premier jour de la semaine est un lundi au Tchad.\n\n\n\n\n\n\n\nAstuce\n\n\n\nLisez la page d‚Äôaide de floor_date() pour conna√Ætre la liste des unit√©s possibles.\n\n\n\n\nAgr√©ger\nMaintenant que nous avons une variables qui identifie la semaine, nous pouvons enfin agr√©ger nos donn√©es !\n\nComptez le nombre de patients par semaine de d√©but des sympt√¥mes, en utilisant le d√©but de la semaine pour identifier les semaines (sem_symptomes_lundi).\nVoici les dix premi√®res lignes de ce √† quoi il devrait ressembler :\n\n\n   sem_symptomes_lundi  n\n1           2022-08-08  1\n2           2022-08-15  2\n3           2022-08-22  1\n4           2022-08-29  8\n5           2022-09-05  8\n6           2022-09-12 10\n7           2022-09-19 17\n8           2022-09-26 17\n9           2022-10-03 19\n10          2022-10-10 16"
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#tracer-le-graphique",
    "href": "sessions_extra/weekly_epicurves.html#tracer-le-graphique",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "Tracer le graphique",
    "text": "Tracer le graphique\nParfait. Nous pouvons maintenant passer nos donn√©es agr√©g√©es √† la commande pour cr√©er le graphique, en faisant quelques ajustements pour que le code pr√©c√©dent fonctionne.\n\nCr√©ez un ggplot avec le m√™me aspect que la courb√© √©pid√©mique de la session principale, mais avec le premier jour de la semaine sur l‚Äôaxe des abscisses. N‚Äôoubliez pas de mettre √† jour les noms des axes !\nIl devrait ressembler √† ceci :\n\n\n\n\n\n\n\n\n\n\nNotez que m√™me si les √©tiquettes sur l‚Äôaxe des abscisses sont des dates, une barre repr√©sente les donn√©es d‚Äôune semaine (sept jours √† compter du lundi)."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#am√©liorer-laxe",
    "href": "sessions_extra/weekly_epicurves.html#am√©liorer-laxe",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "Am√©liorer l‚Äôaxe",
    "text": "Am√©liorer l‚Äôaxe\nIl est maintenant temps d‚Äôam√©liorer cet axe des abscisses.\n{ggplot2} cr√©e automatiquement des √©tiquettes pour l‚Äôaxe des x, en essayant de s‚Äôadapter √† l‚Äô√©tendue des donn√©es. Ces valeurs par d√©faut ne nous conviennent pas toujours, et nous voulons pouvoir manuellement changer les √©tiquettes (plus fr√©quentes ou plus espac√©es, am√©liorer le format etc.).\nPour modifier l‚Äôapparence de l‚Äôaxe, nous allons utiliser une fonction de la famille scale de {ggplot2} : scale_x_date() [scale ici est l‚Äô√©chelle].\n\nModifier la fr√©quence des tirets\nDans {ggplot2}, les breaks [cassures] contr√¥lent la fr√©quence des tirets sur l‚Äôaxe.\nLa fonction scale_x_date() a un argument date_breaks qui accepte l‚Äôintervalle entre deux √©tiquettes dans une cha√Æne de caract√®res aux formats suivants : \"1 week\", \"2 weeks\", \"4 months\", \"2 years\", etc.\n\ndf_linelist |&gt; \n  count(sem_sortie_lundi) |&gt; \n  ggplot(aes(x = sem_sortie_lundi,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date de sortie\",\n       y = \"Patients\",\n       title = \"Sorties rougeole dans la r√©gion de Mandoul (Tchad)\") +\n  scale_x_date(date_breaks = \"4 months\") +  # D√©finit l'intervalle entre √©tiquettes\n  theme_classic(base_size = 16)\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\n\nModifiez votre code pour que la fr√©quence des tirets les rendent lisibles sur votre moniteur.\n\n\n\nAm√©liorer les √©tiquettes\nMaintenant que nous avons g√©r√© l‚Äôintervalle entre les tirets, nous pouvons modifier les √©tiquettes elles-m√™mes (la fa√ßon dont les dates sont affich√©es sur l‚Äôaxe, labels en anglais). Par d√©faut, elles sont sous la forme ann√©e-mois-jour. Nous allons voir deux mani√®res de changer √ßa\n\nAvec le paquet {scales}Avec la syntaxe strptime\n\n\nLa fonction scale_x_date() a un argument label qui accepte plusieurs types d‚Äôentr√©es, telles qu‚Äôun vecteur contenant les dates ou une fonction qui g√©n√®re des labels. Le paquet {scales} fournit une telle fonction, label_date_short(), qui tente de cr√©er des √©tiquettes de dates efficaces et courtes.\n\ndf_linelist |&gt; \n  count(sem_sortie_lundi) |&gt; \n  ggplot(aes(x = sem_sortie_lundi,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date de sortie\",\n       y = \"Patients\",\n       title = \"Sorties rougeole dans la r√©gion de Mandoul (Tchad)\") +\n  scale_x_date(date_breaks = \"2 months\",\n               labels = scales::label_date_short()) + # Etiquettes courtes\n  theme_classic(base_size = 15)\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\n\nModifiez votre code et usez label_date_short() pour cr√©er des √©tiquettes courtes.\n\n\n\nL‚Äôautomatisation c‚Äôest sympa, mais si vous pr√©f√©rez avoir le contr√¥le total, R dispose d‚Äôune syntaxe pour d√©crire les formats de date et d‚Äôheure. Il existe une longue page d‚Äôaide (accessibles avec la commande help(strptime)) avec tous les √©l√©ments de syntaxe, mais voici un r√©sum√© des √©l√©ments les plus utiles pour d√©crire le format d‚Äôune date :\nNum√©ro du jour :\n\n%d: de 01 √† 31\n%e: de 1 √† 31\n\nMois :\n\n%b : nom du mois, forme abr√©vi√©e (la langue d√©pend de la locale de votre ordinateur)\n%B : nom du mois, complet (la langue d√©pend de la locale de votre ordinateur)\n%m : Num√©ro du mois\n\nAnn√©e :\n\n%y : ann√©e √† deux chiffres (sans le si√®cle)\n%Y : ann√©e √† quatre chiffres\n\nS√©parateurs sp√©ciaux :\n\n%n : nouvelle ligne\n%t : tab\n\nVous pouvez assembler ces √©l√©ments dans une cha√Æne de caract√®res, que vous passez √† diff√©rentes fonctions qui acceptent un format comme argument.\nNous allons d‚Äôabord utiliser la fonction format() pour voir rapidement l‚Äôaffichage qu‚Äôelle cr√©e √† partir d‚Äôune syntaxe strptime, puis nous illustrerons l‚Äôusage dans un graphe.\n\n# Cr√©e un vecteur de dates pour explorer des formats diff√©rents\nquelques_dates &lt;- as.Date(c(\"2024-10-06\", \"2024-12-15\", \"2025-01-20\"))\n\n# Exemples de syntaxes possibles\nformat(quelques_dates, \"%Y-%b-%d\")\n\n[1] \"2024-oct.-06\"  \"2024-d√©c.-15\"  \"2025-janv.-20\"\n\nformat(quelques_dates, \"%Y-%b\")\n\n[1] \"2024-oct.\"  \"2024-d√©c.\"  \"2025-janv.\"\n\nformat(quelques_dates, \"%Y %B %d\")\n\n[1] \"2024 octobre 06\"  \"2024 d√©cembre 15\" \"2025 janvier 20\" \n\nformat(quelques_dates, \"%y/%m/%d\")\n\n[1] \"24/10/06\" \"24/12/15\" \"25/01/20\"\n\nformat(quelques_dates, \"%d/%m/%Y\")\n\n[1] \"06/10/2024\" \"15/12/2024\" \"20/01/2025\"\n\n\nRevenons √† notre graphe. La fonction scale_x_date() a un argument date_labels qui accepte une cha√Æne de caract√®re dans le format strptime pour formater les √©tiquettes de dates.\n\ndf_linelist |&gt; \n  count(sem_sortie_lundi) |&gt; \n  ggplot(aes(x = sem_sortie_lundi,\n             y = n)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date de sortie\",\n       y = \"Patients\",\n       title = \"Sorties rougeole dans la r√©gion de Mandoul (Tchad)\") +\n  scale_x_date(\n    date_breaks = \"2 months\",      # D√©finit l'intervalle entre √©tiquettes\n    date_labels = \"%Y%n%b%n%d\") +  # Definit le format des √©tiquettes\n  theme_classic(base_size = 16)\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\n\nModifiez votre graphe pour que les √©tiquettes soient comme ceci :\n\n\n\n\n\n\n\n\n\n\n\nC‚Äôest fini !\nBravo ! Les dates dans R sont un sujet compliqu√©, et leur format est souvent un peu effrayant. Nous esp√©rons que cette petite introduction vous aura donn√© quelques astuces pour que vos courbes √©pid√©miques soient lisibles.\n\n\n\n Solutions\n\n\n\n\n\nAller plus loin\n\nExercices suppl√©mentaires\n\nUtilisez ce format dans cotre graphe : ‚Äú2024-oct.‚Äù, ‚Äú2024-dec.‚Äù\nCr√©ez une courbe √©pid√©mique avec la date de consultation, avec le premier jour de la semaine sur l‚Äôaxe des x (vous √™tes libres du format de la date).\nCr√©ez une courbe √©pid√©mique pour l‚Äôann√©e 2023 qui montre le nombre d‚Äôadmissions hospitali√®res hebdomadaires, avec le num√©ro ISO de la semaine en abscisse.\n\n\n\nD√©fi\n\nTracez une courbe √©pid√©mique de la date d‚Äôapparition des sympt√¥mes par mois. Utilisez un format d‚Äô√©tiquette qui vous semble appropri√© et lisible.\n\n\n\n\nRessources\n\nLe chapitre (en anglais) ‚ÄúElegant graphics for data analyses‚Äô book on date scales\nLa page d‚Äôaide de lubridate"
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#cest-fini",
    "href": "sessions_extra/weekly_epicurves.html#cest-fini",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "C‚Äôest fini !",
    "text": "C‚Äôest fini !\nBravo ! Les dates dans R sont un sujet compliqu√©, et leur format est souvent un peu effrayant. Nous esp√©rons que cette petite introduction vous aura donn√© quelques astuces pour que vos courbes √©pid√©miques soient lisibles.\n\n\n\n Solutions"
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#aller-plus-loin",
    "href": "sessions_extra/weekly_epicurves.html#aller-plus-loin",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices suppl√©mentaires\n\nUtilisez ce format dans cotre graphe : ‚Äú2024-oct.‚Äù, ‚Äú2024-dec.‚Äù\nCr√©ez une courbe √©pid√©mique avec la date de consultation, avec le premier jour de la semaine sur l‚Äôaxe des x (vous √™tes libres du format de la date).\nCr√©ez une courbe √©pid√©mique pour l‚Äôann√©e 2023 qui montre le nombre d‚Äôadmissions hospitali√®res hebdomadaires, avec le num√©ro ISO de la semaine en abscisse.\n\n\n\nD√©fi\n\nTracez une courbe √©pid√©mique de la date d‚Äôapparition des sympt√¥mes par mois. Utilisez un format d‚Äô√©tiquette qui vous semble appropri√© et lisible."
  },
  {
    "objectID": "sessions_extra/weekly_epicurves.html#ressources",
    "href": "sessions_extra/weekly_epicurves.html#ressources",
    "title": "Courbes √©pid√©miques hebdomadaires",
    "section": "Ressources",
    "text": "Ressources\n\nLe chapitre (en anglais) ‚ÄúElegant graphics for data analyses‚Äô book on date scales\nLa page d‚Äôaide de lubridate"
  },
  {
    "objectID": "sessions_extra/faceting.html",
    "href": "sessions_extra/faceting.html",
    "title": "Graphiques multiples (facetting)",
    "section": "",
    "text": "Dans cette session, le but est d‚Äôapprendre √† :\n\ncr√©er des graphiques multiples tr√®s rapidement avec {ggplot2}\nmodifier les param√®tres les plus courants pour am√©liorer l‚Äôapparence de ces graphiques"
  },
  {
    "objectID": "sessions_extra/faceting.html#objectifs",
    "href": "sessions_extra/faceting.html#objectifs",
    "title": "Graphiques multiples (facetting)",
    "section": "",
    "text": "Dans cette session, le but est d‚Äôapprendre √† :\n\ncr√©er des graphiques multiples tr√®s rapidement avec {ggplot2}\nmodifier les param√®tres les plus courants pour am√©liorer l‚Äôapparence de ces graphiques"
  },
  {
    "objectID": "sessions_extra/faceting.html#introduction",
    "href": "sessions_extra/faceting.html#introduction",
    "title": "Graphiques multiples (facetting)",
    "section": "Introduction",
    "text": "Introduction\nPr√©requis : ce satellite s‚Äôappuie sur la session sur les courbes √©pid√©miques, durant laquelle nous avons appris √† visualiser la distribution quotidienne des cas de rougeoles au cours du temps √† l‚Äôaide de {ggplot2} :\n\n\n\n\n\n\n\n\n\nCe graphique est tr√®s utile, mais ce qui serait encore plus utile serait de pouvoir le d√©cliner rapidement selon les modalit√©s d‚Äôune autre variable. Par exemple, nous pourrions vouloir ins√©rer un graphique similaire mais par groupe d‚Äô√¢ge dans un rapport de situation [sitrep en anglais]. Il y a plusieurs mani√®res d‚Äôarriver √† ce r√©sultat. Vous pourriez :\n\nfiltrer un jeu de donn√©es pour chacune des classes d‚Äô√¢ge, copier-coller le code du graphe et l‚Äôadapter pour cr√©er un graphique par classe d‚Äô√¢ge\napprendre √† utiliser les boucles for ou les fonctions des familles apply() ou map() qui servent r√©p√©ter des actions sans copier-coller\nfaire confiance √† {ggplot2} pour avoir une solution rapide‚Ä¶\n\nLa premi√®re option est fastidieuse et source d‚Äôerreurs, et nous la d√©conseillons. La seconde option n‚Äôest pas mauvaise en soi : les outils mentionn√©s sont extr√™mement puissants et de bonnes cibles d‚Äôapprentissage pour quand vous serez plus √† l‚Äôaise avec le langage. Mais ils sont trop avanc√©s pour ce petit tutoriel, et une options simple existe d√©j√† dans {ggplot2}."
  },
  {
    "objectID": "sessions_extra/faceting.html#mise-en-place",
    "href": "sessions_extra/faceting.html#mise-en-place",
    "title": "Graphiques multiples (facetting)",
    "section": "Mise en place",
    "text": "Mise en place\n\nNous utiliserons la m√™me liste lin√©aire nettoy√©e que pr√©c√©demment et qui peut √™tre t√©l√©charg√©e ici :\n\n\n\n T√©l√©charger les donn√©es\n\n\n\n Si ce n‚Äôest pas d√©j√† fait, enregistrez le jeu de donn√©es dans data/clean puis cr√©ez un nouveau script appel√© faceting.R dans votre sous-dossier R (alternativement, vous pouvez rajouter une section au script sur les courbes √©pis).\n Si vous cr√©ez un nouveau script, ajoutez un en-t√™te appropri√© et chargez les paquets suivants : {here}, {rio} et {tidyverse}. Importez ensuite les donn√©es propres dans R et enregistrez-les dans un objet df_linelist."
  },
  {
    "objectID": "sessions_extra/faceting.html#un-graphe-par-modalit√©-faceting",
    "href": "sessions_extra/faceting.html#un-graphe-par-modalit√©-faceting",
    "title": "Graphiques multiples (facetting)",
    "section": "Un graphe par modalit√© (faceting)",
    "text": "Un graphe par modalit√© (faceting)\nDans ggplot, ‚Äúfaceting‚Äù est est l‚Äôaction de cr√©er des graphiques en plusieurs parties. La fonction facet_wrap() trace automatiquement un graphique pour chacune des modalit√©s d‚Äôune variable. Par exemple, vous pouvez cr√©er une courbe √©pi par sexe, ou par site. Comme les autres couches d‚Äôun ggplot, on l‚Äôajoute √† un graphique avec un +. Cela cr√©e une figure avec plusieurs petits graphiques, les fameuses facettes.\n\nPr√©parer les donn√©es\nDans cette le√ßon, nous expliquerons le code en tra√ßant la courbe par sous-pr√©fecture, et vous tracerez la courbe par groupe d‚Äô√¢ge.\nSi l‚Äôon veut tracer la courbe √©pid√©mique par sous-pr√©fecture, il faut que cette variable soit dans le data frame que nous passons √† ggplot(). Nous allons donc cr√©er un nouveau jeu de donn√©es agr√©g√©es qui contient le nombre de patients par jour et par sous-pr√©fecture.\n\ndf_pref &lt;- df_linelist %&gt;%\n  count(date_debut, sous_prefecture,\n        name = 'patients')\n\nhead(df_pref)\n\n  date_debut sous_prefecture patients\n1 2022-08-13        Moissala        1\n2 2022-08-17        Moissala        1\n3 2022-08-18        Moissala        1\n4 2022-08-22        Moissala        1\n5 2022-08-30        Moissala        2\n6 2022-09-01        Moissala        1\n\n\n\nVous devez tracer le nombre de patients par groupe d‚Äô√¢ge, donc il vous faut un data frame agr√©g√© par jour et groupe d‚Äô√¢ge. Cr√©ez-le et enregistrez-le comme df_age. Il a le format suivant :\n\n\n  date_debut age_groupe n\n1 2022-08-13  1 - 4 ans 1\n2 2022-08-17 5 - 14 ans 1\n3 2022-08-18   &lt; 6 mois 1\n4 2022-08-22 6 - 8 mois 1\n5 2022-08-30   &lt; 6 mois 1\n6 2022-08-30 6 - 8 mois 1\n\n\n\n\n\nTracer le graphique\nMaintenant que les donn√©es sont pr√™tes, il ne nous reste plus qu‚Äô√† tracer le graphique. Examinez le code ci-dessous, il est presque identique √† ce que nous avons fait pr√©c√©demment, √† part la derni√®re ligue qui cr√©e les facettes :\n\ndf_pref %&gt;%\n  ggplot(aes(x = date_debut,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date d'apparition des symptomes\",\n       y = \"Cas de rougeole\",\n       title = \"Measles cases in Mandoul (Chad)\") +\n  theme_classic(base_size = 15) +\n  facet_wrap(vars(sous_prefecture))   # Graphique par sous-pref !\n\n\n\n\n\n\n\n\nJ‚Äôesp√®re que vous √™tes souffl√©s ! D‚Äôun point de vue syntaxe, la fonction facer_wrap() prend en argument le nom de la variable cat√©gorique qui nous int√©resse, enrob√© dans la fonction vars().\n\nA votre tour. Tracez le graphe par classe d‚Äô√¢ge. Il devrait ressembler √† √ßa :"
  },
  {
    "objectID": "sessions_extra/faceting.html#modifier-laspect-des-facettes",
    "href": "sessions_extra/faceting.html#modifier-laspect-des-facettes",
    "title": "Graphiques multiples (facetting)",
    "section": "Modifier l‚Äôaspect des facettes",
    "text": "Modifier l‚Äôaspect des facettes\nOuvrez la page d‚Äôaide de la fonction sur le site du paquet pour avoir la liste des arguments accept√©s. Nous allons aborder certains d‚Äôentre eux √† pr√©sent.\n\nNombre de lignes ou de colonnes\nLes arguments nrow et ncol vous permettent de d√©cider combien de facettes il doit y avoir sur une ligne, ou sur une colonne.\nSi nous voulions avoir toutes les facettes sur deux lignes :\n\ndf_pref %&gt;%\n  ggplot(aes(x = date_debut,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date d'apparition des symptomes\",\n       y = \"Cas de rougeole\",\n       title = \"Cas de rougeole dans la r√©gion de Mandoul (Tchad)\") + \n  theme_classic(base_size = 15) +\n  \n  facet_wrap(vars(sous_prefecture),\n             nrow = 2)  \n\n\n\n\n\n\n\n\nOu au contraire nous pouvons forcer le nombre de lignes √† 4 pour avoir une figure tout en hauteur :\n\ndf_pref %&gt;%\n  ggplot(aes(x = date_debut,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date d'apparition des symptomes\",\n       y = \"Cas de rougeole\",\n       title = \"Cas de rougeole dans la r√©gion de Mandoul (Tchad)\") + \n  theme_classic(base_size = 15) +\n  \n  facet_wrap(vars(sous_prefecture),\n             nrow = 4)  \n\n\n\n\n\n\n\n\n\nUtilisez un des deux arguments pr√©sent√©s ci-dessus pour cr√©er un graphe avec trois colonnes.\n\n\n\nPlages des axes\nAvez-vous remarqu√© que les valeurs minimales et maximales en x et en y √©taient les m√™mes pour toutes les facettes ? C‚Äôest que par d√©faut facet_wrap() fixe les plages pour les deux axes. Ce comportement est raisonnable pour pouvoir comparer les facettes et √©viter d‚Äôinduire le lecteur en erreur.\nCeci √©tant dit, si vous √™tes plus int√©ress√© par la forme de la courbe √† l‚Äôint√©rieur de chaque facette que par la comparaison des cat√©gories entre elles, il peut √™tre appropri√© de zoomer sur les donn√©es disponibles en autorisant des axes ind√©pendants (‚Äúlibres‚Äù de varier). Pr√©venez alors le lecteur que les facettes ne sont pas toutes √† la m√™me √©chelle.\nL‚Äôargument scales [√©chelles] accepte les valeurs suivantes :\n\n\"fixed\" : la valeur par d√©faut, x et y √† la m√™me √©chelle pour toutes les facettes\n\"free_x\" : l‚Äô√©chelle de x peut varier entre facettes\n\"free_y\" : l‚Äô√©chelle de y peut varier entre facettes\n\"free\" : les deux axes peuvent varier entre facettes\n\nContrastez le graphe pr√©c√©dent avec celui-ci :\n\n\n\n\n\n\n\n\n\nNous avons autoris√© √† avoir des √©chelles ind√©pendantes sur toutes les facettes en x et en y, pour zoomer sur les cas dans chaque sous-pr√©fecture.\n\nTracez la courbe par groupe d‚Äô√¢ge, avec l‚Äôaxe des abscisses fixe et l‚Äôaxe des ordonn√©es libre."
  },
  {
    "objectID": "sessions_extra/faceting.html#cest-fini",
    "href": "sessions_extra/faceting.html#cest-fini",
    "title": "Graphiques multiples (facetting)",
    "section": "C‚Äôest fini !",
    "text": "C‚Äôest fini !\nBravo, vous avez cr√©√© vos premiers graphiques en fonctions d‚Äôune variable cat√©gorique. Cela devrait vous √™tre tr√®s utile. Sachez que la fonction fonctionne aussi avec d‚Äôautres types de graphes cr√©√©s par {ggplot2}.\nSi le graphique est tr√®s large, il est possible que les √©tiquettes des dates ne soient pas tr√®s lisibles en x, et c‚Äôest le cas pour certains des exemples. Cela peut √™tre contr√¥l√©, et le sujet est abord√© dans un autre satellite !\n\n\n\n Solutions des exercices"
  },
  {
    "objectID": "sessions_core/06_epicurves.html",
    "href": "sessions_core/06_epicurves.html",
    "title": "Introduction to data visualization with ggplot2",
    "section": "",
    "text": "D√©couvrir les bases de la visualisation de donn√©es en R avec le package {ggplot2}\nConstruire une courbe √©pid√©mique simple"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#objectifs",
    "href": "sessions_core/06_epicurves.html#objectifs",
    "title": "Introduction to data visualization with ggplot2",
    "section": "",
    "text": "D√©couvrir les bases de la visualisation de donn√©es en R avec le package {ggplot2}\nConstruire une courbe √©pid√©mique simple"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#introduction",
    "href": "sessions_core/06_epicurves.html#introduction",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Introduction",
    "text": "Introduction\nPour cette derni√®re session, nous allons vous donner une courte introduction √† la visualisation de donn√©es √† l‚Äôaide du package {ggplot2}, un outil populaire. Gardez en t√™te que la visualisation de donn√©es est un √©norme sujet, et {ggplot2} un vaste package et il n‚Äôest pas r√©aliste de tout traiter en trois heures. La session d‚Äôaujourd‚Äôhui est une introduction que nous esp√©rons douce aux concepts de base de la visualisation, en prenant pour objet un graphe fameux en √©pid√©miologie, la courbe √©pid√©mique.\nNotre visualisation finale ressemblera √† ceci :"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#setup",
    "href": "sessions_core/06_epicurves.html#setup",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Setup",
    "text": "Setup\nD√©pendances. Cette session suppose que vous savez utiliser RStudio, que vous √™tes capable d‚Äôimporter des donn√©es et que vous connaissez les verbes de base de manipulation des donn√©es que nous avons vus dans les sessions de base jusqu‚Äô√† pr√©sent. Si vous avez besoin d‚Äôun rappel sur l‚Äôun de ces sujets, nous vous encourageons √† revoir les sessions de base du parcours d‚Äôapprentissage.\n\nCette session utilisera la version nettoy√©e de l‚Äôensemble de donn√©es Moissala sur la rougeole.\n\n\n\n  Course Folder\n\n\n\n Ouvrez votre projet Rstudio du cours et cr√©ez un nouveau script appel√© ‚Äúcourbe_epi.R‚Äù avec les m√©tadonn√©es appropri√©es. Enregistrez le dans R/. Pour cette session, nous aurons besoin de charger les packages {here}, {rio}, {dplyr}, {lubridate}, et{ggplot2}. Ajoutez une section # IMPORTATION DONN√âES o√π vous importez les donn√©es nettoy√©es du cours (linelist_moissala_clean_FR.RDS)."
  },
  {
    "objectID": "sessions_core/06_epicurves.html#les-paradigmes-de-la-cr√©ation-de-graphiques",
    "href": "sessions_core/06_epicurves.html#les-paradigmes-de-la-cr√©ation-de-graphiques",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Les paradigmes de la cr√©ation de graphiques",
    "text": "Les paradigmes de la cr√©ation de graphiques\nIn R, and indeed in everything, there are a loIl y a de nombreuses approches √† la visualisation de donn√©es, en g√©n√©ral et en R en particulier. Les deux plus grands paradigmes sont :\n\nTout en un : cette approche est caract√©ris√©e par l‚Äôexistence d‚Äôune fonction (en g√©n√©ral complexe) pour g√©rer tous les aspects de la construction d‚Äôun graphique. Base R par exemple, utilise cette approche (et n‚Äôest pas le seul).\nGraphiques en couches (ou modulaires) : le graphique est d√©compos√© en √©l√©ments (formes, titres, barres d‚Äôerreurs, th√®mes‚Ä¶) associ√©es √† des couches. Diff√©rentes fonctions ajoutent ou modifient ces √©l√©ments. Ce paradigme est utilis√© par les packages {ggplot2}, {highcharter}, ou {echarts4r} et un certain nombre d‚Äôoutils modernes.\n\nUne discussion approfondie sur les raisons pour lesquelles on peut utiliser une approche plut√¥t qu‚Äôune autre d√©passe le cadre de ce cours, mais nous noterons que la plupart des paquets de visualisation modernes ont tendance √† utiliser un [mod√®le en couches] {.hovertip bs-toggle=‚Äòtooltip‚Äô bs-title=‚ÄúC‚Äôest parce que les mod√®les en couches ont tendance √† √™tre plus pratiques lors de la construction de visualisations complexes ou hautement personnalis√©es.‚Äù}. En gardant cela √† l‚Äôesprit, examinons les types de couches dont nous parlons dans notre approche ¬´ en couches ¬ª.\n\nD√©composition d‚Äôun graphique\nDans ce tutoriel, nous d√©composons les graphiques en quatre composantes (couches) :\n\nLe canevas / les donn√©es\nLes formes g√©om√©triques primaires\nLes titres et labels\nLe th√®me\n\nOn peut illustrer ces composants avec la courb√© √©pid√©mique sch√©matique suivante :\n\n\n\n\n\nLa premi√®re couche, le caneva (ou la toile) est fondamentale. Comme un artiste pr√©pare sa toile vierge et ses outils avant de se lancer dans une peinture, R doit en premier lieu cr√©er un canevas pr√™t √† accueillir les √©l√©ments de repr√©sentation graphique. C‚Äôest lors de la cr√©ation du canevas que nous indiquons √† R que nous voulons cr√©er un graphique, et avec quelles variables.\nIci, nous allons sp√©cifier √† R que nous voulons un graphique o√π l‚Äôaxe horizontal repr√©sente la date, et l‚Äôaxe vertical repr√©sente le nombre de cas. Une fois le canevas mise en place, nous ajouterons d‚Äôautres couches, comme un artiste ajouterait de la peinture, leur signature ou un cadre.\n\n\nOssature d‚Äôun ggplot\nLa recette pour construire un ggplot (un graphe produit par le package {ggplot}) est de la forme suivante :\n\nCr√©ation d‚Äôun canevas √† l‚Äôaide de ggplot(aes(...))\nAjout de couches sur le canevas avec +\n\nNotez que {ggplot2} utilise l‚Äôop√©rateur + pour ajouter des couches sur le graphe.\nLa syntaxe g√©n√©rale d‚Äôun ggplot est :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf |&gt;                    # passer les donn√©es\n  ggplot(aes(x = ...,    # √©tape 1 : cr√©er le canevas\n             y = ...)) +\n  couche_1(...) +        # √©tape 2 : ajout de la premi√®re couche\n  couche_2(...) +        # √©tape 3 : ajout d'une autre couche\n  ...                    # continuer √† ajouter des couches...\n\nLe nombre de couches √† ajouter d√©pend de la complexit√© du graphique que vous souhaitez cr√©er. Dans notre cas, nous ajouterons trois couches en utilisant les fonctions suivantes :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf |&gt;                    # passer les donn√©es\n  ggplot(aes(x = ...,    # √©tape 1 : cr√©er le canevas\n\n             y = ...)) +\n  geom_col(...) +        # √©tape 2 : ajout des formes (barres)\n  labs(...) +            # √©tape 3 : ajouter des titres\n  theme_classic(...)     # √©tape 4 : am√©lioration du th√®me\n\nNous pouvons mettre √† jour notre pr√©c√©dent sch√©ma avec ces fonctions :\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDans l‚Äôexemple pr√©c√©dent, nous passons le jeu de donn√©es √† la fonction ggplot() √† l‚Äôaide de l‚Äôop√©rateur pipe (comme nous l‚Äôavons souvent fait avec d‚Äôautres fonctions). C‚Äôest possible car le premier argument n√©cessaire de la fonction est le dataframe contenant les variables √† repr√©senter. Soyez attentifs, il est facile de se tromper et de chercher √† utiliser un + √† la place du |&gt;\n\n\nDans la section suivante, nous allons d√©crire les diff√©rentes √©tapes plus en d√©tail, en utilisant notre jeu de donn√©es rougeole √† Moissala pour faire notre premi√®re courbe √©pid√©mique."
  },
  {
    "objectID": "sessions_core/06_epicurves.html#sec-epicurve-steps",
    "href": "sessions_core/06_epicurves.html#sec-epicurve-steps",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Votre premier ggplot",
    "text": "Votre premier ggplot\n\nPr√©parer vos donn√©es : Agr√©gation par jour\nNous aimerions tracer une courbe des cas quotidiens. Vous l‚Äôaurez peut-√™tre remarqu√©, nos donn√©es actuelles sont quotidiennes, mais il est √©vident que plusieurs cas peuvent se produire certains jours. Donc,il faut agr√©ger les donn√©es par jour. Heureusement, vous avez d√©j√† appris √† r√©sumer les donn√©es lors des sessions pr√©c√©dentes.\n\nEn utilisant count(), cr√©ez un nouveau dataframe appel√© df_cases qui r√©sume le nombre total de cas observ√©s par jour. L‚Äôen-t√™te de ce cadre de donn√©es devrait ressembler √† ceci :\n\n\n  date_debut n\n1 2022-08-13 1\n2 2022-08-17 1\n3 2022-08-18 1\n4 2022-08-22 1\n5 2022-08-30 2\n6 2022-09-01 1\n\n\n\nBien !\nDans les √©tapes suivantes, vous allez utiliser df_cas pour tracer une courbe √©pid√©mique du nombre de cas par semaine. En revanche, les exemples donn√©es dans les exercices pour illustrer le fonctionnement des fonctions seront faits sur le nombre de hospitalisations par semaine. Pour cela, j‚Äôutiliserai un dataframe df_hopital, qui ressemble √† ceci :\n\n\n  date_admission patients\n1     2022-08-14        1\n2     2022-08-25        1\n3     2022-09-02        1\n4     2022-09-06        1\n5     2022-09-09        1\n6     2022-09-10        1\n\n\n\n\nCr√©er le canevas\nLa premi√®re √©tape est de cr√©er votre ‚Äúcanevas‚Äù en sp√©cifiant votre jeu de donn√©es et le nom des colonnes que vous voulez repr√©senter sur le graphique. Cela est fait √† l‚Äôaide de la fonction ggplot(aes()) selon la syntaxe suivante :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf_data |&gt;\n  ggplot(aes(x = x_axis_variable_name,\n             y = y_axis_variable_name))\n\nPour l‚Äôexemple, je vais placer la date (date_admission) sur l‚Äôaxe des x et le nombre de patients (patients) sur l‚Äôaxe des y :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients))\n\n\n\n\n\n\n\n\nDans Rstudio, ce graphique devrait appara√Ætre dans l‚Äôonglet ‚ÄúPlots‚Äù dans le panneau en bas √† droite (par d√©faut) :\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nJust like with {dplyr}, we write our column names without quotation marks. This is unsurprising as {ggplot2}, like {dplyr}, is a member of the {tidyverse} and therefore uses similar syntax.\n\n\nQu‚Äôest ce que cette fonction aes() que nous avons imbriqu√© dans la fonction ggplot() ?\nLa fonction aes() n‚Äôest jamais utilis√©e seule, elle est toujours pass√©e √† ggplot(). Elle sert √† faire correspondre les variables du jeu de donn√©es aux √©l√©ments visuels du graphique (en anglais on parle de ‚Äúmapping‚Äù, qui est occasionnellement traduit par ‚Äúmappage‚Äù). Les plus basiques de ces √©l√©ments graphiques sont les axes, mais on peut aussi d√©finir comment la couleur ou la taille d‚Äô√©l√©ments varie en fonction de variables dans les donn√©es (par exemple, statut √† la sortie).\n\nCr√©ez une nouvelle section # PLOT COURBE EPI. Ensuite, en vous inspirant de l‚Äôexemple pr√©c√©dent, cr√©ez la base d‚Äôun ggplot avec le dataframe df_cas, et d√©finissez l‚Äôaxe des x et des x.\n\nPour le moment, le r√©sultat devrait ressembler √† ceci :\n\n\n\n\n\n\n\n\n\nTr√®s bien. Maintenant, ajoutons les barres\n\n\nAjouter les formes\nMaintenant que la toile est pr√™te, commen√ßons √† dessiner dessus, et ajoutons des formes. Dans {ggplot2}, les formes g√©om√©triques sont surnomm√©es des ‚Äúg√©om√©tries‚Äù ou ‚Äúgeom‚Äù en raccourci, et repr√©sentent les donn√©es. Les geoms les plus courants sont :\n\nDiagrammes en b√¢tons (geom_col() or geom_bar())\nHistogrammes (geom_histogram())\nNuages de points(geom_point())\nCourbes(geom_line())\nDiagramme en bo√Æte √† moustache (boxplots) (geom_boxplot())\n\nAujourd‚Äôhui nous allons nous concentrer sur les diagrammes en b√¢ton, pour cr√©er une courbe √©pid√©mique. Nous allons utiliser la fonction geom_col().\nNous allons maintenant rajouter les barres √† la courbe des cas hospitalis√©s. Rappelez-vous que l‚Äôon ajoute une nouvelle couche √† notre objet ggplot √† l‚Äôaide de +.\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col()\n\n\n\n\n\n\n\n\nC‚Äôest g√©nial, cela ressemble vraiment √† une √©picurve. Bien qu‚Äôelle ait l‚Äôair un peu‚Ä¶ grise. Si nous voulons mettre √† jour la couleur de nos barres (appel√©e le fill), nous devons simplement ajouter l‚Äôargument fill to geom_col().\nFaisons un essai :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\")\n\n\n\n\n\n\n\n\n\nMettez √† jour votre graphe pour ajouter les barres avec la couleur #2E4573.\n\nVotre graphe devrait ressembler √† ceci :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDans {ggplot2}, les couches doivent √™tre ajout√©es √† un objet ggplot existant (le canevas d√©finit √† l‚Äô√©tape 1). Ex√©cuter la fonction geom_col() toute seule ne produira pas un graphe. Si l‚Äôon reprend notre analogie avec la peinture, ce serait comme essayer d‚Äôutiliser la peinture sans support (toile).\n\n\nCe graphe s‚Äôam√©liore d‚Äôinstant en instant ! Maintenant il est temps de le rendre un petit peu plus informatif‚Ä¶\n\n\nAjouter les titres\nUn bon graphique doit avoir des titres et des labels informatifs or pour le moment, ce n‚Äôest pas le cas de nos graphiques (n n‚Äôest pas tr√®s informatif).\nLa fonction lab() permet d‚Äôajouter des titres et labels √† plusieurs √©l√©ments du graphique :\n\nTitre des axes (x = ety =)\nTitre du graphique (title =)\nCaption\n\nComme avec les autres couches, nous pouvons ajouter la couche contenant les titres et labels √† notre graphe avec le signe + :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la r√©gion de Madoul (Tchad)\")\n\n\n\n\n\n\n\n\n\nAjoutez des titres raisonnables √† votre graphe.  Bonus. Ajoutez une source des donn√©es en utilisant caption.\n\nVotre graphe pourrait maintenant ressembler √† celle-ci (par exemple) :\n\n\n\n\n\n\n\n\n\n\n\nChanger le th√®me\nLe th√®me de base de ggplot n‚Äôest pas tr√®s attractif, et la taille des polices est trop petite pour √™tre lisible sur la majorit√© des supports. Si vous voulez utiliser votre graphique dans des rapports ou des pr√©sentations, il vaudrait mieux am√©liorer son apparence.\nPour cela, il suffit d‚Äôajouter une couche ‚Äúth√®me‚Äù √† notre graphe (la derni√®re couche pour aujourd‚Äôhui !). Si le nom des fonctions des geoms commen√ßait toujours par geom_, le nom de toutes les fonctions de th√®me commence par theme_. Il existe plusieurs th√®mes pr√©d√©finis, et vous pouvez aller les regarder sur le site de {ggplot2}.\nAujourd‚Äôhui, nous allons utiliser theme_classic(), qui offre une alternative √©l√©gante au th√®me de base :\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la r√©gion de Madoul (Tchad)\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nC‚Äôest d√©j√† plus joli. Maintenant, nous voudrions augmenter la taille de la police. Nous pouvons faire √ßa en ajustant la taille de la police √† l‚Äôaide de l‚Äôargument base_size:\n\ndf_hopital |&gt;\n  ggplot(aes(x = date_admission,\n             y = patients)) +\n  geom_col(fill = \"#2E4573\") +\n  labs(x = \"Date\",\n       y = \"Patients par Jour\",\n       title = \"Hospitalisations pour rougeole dans la r√©gion de Madoul (Tchad)\") +\n  theme_classic(base_size = 17)\n\n\n\n\n\n\n\n\n‚Äôest beaucoup mieux !\nRappelez-vous que la taille de la police doit √™tre choisie en fonction de la destination du graphe (pr√©sentation, rapport informel, rapport final ?). Il en va de m√™me pour le choix du th√®me, qui reste un choix partiellement subjectif. Il existe des principes de visualisation qui peuvent guider vos choix lors de la cr√©ation d‚Äôun graphe (ou d‚Äôune table), mais la visualisation de donn√©es est autant un art qu‚Äôune science.\n\nAjoutez une derni√®re couche √† votre graphe pour ajouter un th√®me de votre choix, avec une taille de police plus appropri√©e.\n\n\n\nSauvegarder votre graphique\nSi vous souhaitez enregistrer votre graphe, vous pouvez cliquer sur le bouton ¬´ Exporter ¬ª dans le panneau de trac√© de RStudio :"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#la-fin",
    "href": "sessions_core/06_epicurves.html#la-fin",
    "title": "Introduction to data visualization with ggplot2",
    "section": "La Fin !",
    "text": "La Fin !\nBravo! Vous avez cr√©√© votre premi√®re courbe √©pid√©mique en R !\n\n\n\n Solutions file"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#aller-plus-loin",
    "href": "sessions_core/06_epicurves.html#aller-plus-loin",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices suppl√©mentaires\n\nUtilisez le theme_minimal() sur un de vos graphiques, avec une police de taille de base de 18.\nAllez sur ce site, choisissez une couleur et mettez √† jour la couleur de vos barres.\n\n\n\nExercices de d√©fi\n\nAu lieu d‚Äôagr√©ger par date, comptez le nombre de patients par sous-pr√©fecture. Essayez d‚Äôadapter votre code pour cr√©er un diagramme √† barres du nombre de patients par sous-pr√©fecture.\n\n\n\nSatellites\n\nCourbes √©pid√©miques hebdomadaires\nGraphiques multiples (facetting)"
  },
  {
    "objectID": "sessions_core/06_epicurves.html#ressources",
    "href": "sessions_core/06_epicurves.html#ressources",
    "title": "Introduction to data visualization with ggplot2",
    "section": "Ressources",
    "text": "Ressources\n\nUn livre complet sur l‚Äôutilisation de {ggplot2}.\n\nUn chapitre entier sur les √©picurves"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html",
    "href": "sessions_core/04_data_verbs_conditional.html",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "",
    "text": "Dans la session pr√©c√©dente vous avez appris les bases du traitement de donn√©es en R avec les fonctions du {tidyverse}, en particulier comment s√©lectionner et modifier les colonnes d‚Äôun data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre √† :\n\n√âcrire des conditions logiques basiques, ce qui va nous permettre de :\nS√©lectionner des lignes d‚Äôun data frame avec filter()\nRecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "href": "sessions_core/04_data_verbs_conditional.html#objectifs",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "",
    "text": "Dans la session pr√©c√©dente vous avez appris les bases du traitement de donn√©es en R avec les fonctions du {tidyverse}, en particulier comment s√©lectionner et modifier les colonnes d‚Äôun data frame. Dans cette session nous allons allez plus loin sur la modification des data frame et apprendre √† :\n\n√âcrire des conditions logiques basiques, ce qui va nous permettre de :\nS√©lectionner des lignes d‚Äôun data frame avec filter()\nRecoder des variables avec case_when()"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "href": "sessions_core/04_data_verbs_conditional.html#mise-en-place",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "Mise en place",
    "text": "Mise en place\nPr√©requis : cette le√ßon part du principe que vous connaissez les bases de la manipulation de donn√©es avec {dplyr}, et en particulier la fonction mutate(). Aller vous rafra√Æchir si besoin.\n\nNous utiliserons la liste lin√©aire avec les donn√©es brutes qui peut √™tre t√©l√©charg√©e ici :\n\n\n\n T√©l√©charger les donn√©es\n\n\n\n Si ce n‚Äôest pas d√©j√† fait, enregistrez la dans le sous-dossier appropri√© de votre projet RStudio puis cr√©ez un nouveau script appel√© filtrer_recoder.R dans votre sous-dossier R. Ajoutez un en-t√™te appropri√© et chargez les paquets suivants : {here}, {rio} et {tidyverse}.  Enfin, ajoutez une section d√©di√©e √† l‚Äôimport des donn√©es, utilisez {here} et {rio} pour importer vos donn√©es dans R, et assignez-les √† un objet que nous appellerons df_brut"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#filtrer-des-donn√©es-avec-des-conditions-logiques",
    "href": "sessions_core/04_data_verbs_conditional.html#filtrer-des-donn√©es-avec-des-conditions-logiques",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "Filtrer des donn√©es avec des conditions logiques",
    "text": "Filtrer des donn√©es avec des conditions logiques\nNous avons appris pr√©c√©demment comment comment s√©lectionner les colonnes d‚Äôun data frame. Nous allons √† pr√©sent apprendre la t√¢che compl√©mentaire, qui est la s√©lection des lignes d‚Äôun data frame. C‚Äôest une t√¢che particuli√®rement courante du travail d‚Äô√©pid√©miologiste qui permet de s√©lectionner des observations qui satisfont √† certains crit√®res. Le paquet {dplyr} poss√®de bien √©videment une fonction pour √ßa, la fonction filter().\nAvant de pouvoir l‚Äôutiliser nous allons n√©anmoins devoir apprendre √† √©crire des conditions logique, qui sont √©galement un pr√©requis pour recoder des variables. Les conditions logiques sont des questions (ou tests) auxquelles R va r√©pondre par TRUE ou FALSE (ou NA).\n\nEgalit√©\nLa syntaxe de filter() est assez simple :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition_logique])\n\nCette syntaxe permet de conserver les lignes o√π condition_logique est vraie. Ici, la condition logique va demander si quelque chose est √©gale √† autre chose. Par exemple, si telle variable est √©gale √† telle valeur (est ce que patient a √©t√© hospitalis√© ?). En R, nous testons l‚Äô√©galit√© avec l‚Äôop√©rateur ==.\nEn pratique, pour cr√©er un filtre qui ne garde que les patients hospitalis√©s nous √©crivons :\n\ndf_brut |&gt;\n  filter(hospitalisation == \"oui\")\n\nIci, filter() parcourt chaque ligne de notre data frame et teste si la valeur d‚Äôhospitalisation dans cette ligne est √©gale √† \"oui\". La fonction ne renvoie alors que les lignes o√π la r√©ponse √† la question est TRUE [vrai].\n\nFiltrez vos donn√©es pour ne conserver que les patients qui avaient de la fi√®vre (c‚Äôest √† dire les patients contenant la valeur \"Yes\" dans la colonne fievre. Le d√©but de la colonne fievre dans la sortie filtr√©e est :\n\n\n  fievre\n1    Yes\n2    Yes\n3    Yes\n4    Yes\n5    Yes\n6    Yes\n\n\nInspectez la sortie et df_brut. Pourquoi df_brut contient-il encore les patients qui n‚Äôavaient pas de fi√®vre ?\n\n\n\nIn√©galit√©\nParfois, nous pr√©f√©rons tester l‚Äôin√©galit√© plut√¥t que l‚Äô√©galit√© ; pour examiner les patients qui ne se sont pas r√©tablis, par exemple, qu‚Äôils soient d√©c√©d√©s ou sorti contre avis m√©dical. Dans ce cas nous utiliserons l‚Äôop√©rateur !=, ce qui donne ce code :\n\ndf_brut |&gt;\n  filter(issue != 'gueri') # Garde les lignes avec patients NON gu√©ris\n\n\nFiltrez votre data frame pour ne montrer que les patients qui n‚Äôont pas de carte confirmant leur statut vaccinal. Le d√©but de la colonne filtr√©e ressemble √† :\n\n\n  statut_vaccinal\n1             Non\n2             Non\n3             Non\n4             Non\n5             Non\n6             Non\n\n\nAstuce : Rappelez-vous que vous pouvez utiliser count() pour v√©rifier les modalit√©s de statut_vaccinal.\n\n\n\nSup√©rieur √† / Inf√©rieur √†\nDans le cas des variables num√©riques, on sera souvent int√©ress√© par savoir si une valeur est sup√©rieure ou inf√©rieure √† un seuil. Par exemple, quels sont les patients de moins de 5 ans. Ici, nous utiliserons les op√©rateurs &lt; et &gt; pour √©valuer si une variable est inf√©rieure √† ou sup√©rieure √† une valeur donn√©e, respectivement.\nNous pouvons par exemple filtrer les patients de moins de 60 mois :\n\ndf_brut |&gt;\n  filter(age &lt; 60)\n\n\nAffichez un data frame ne contenant que les patients souffrant de malnutrition aigu√´ s√©v√®re. Le d√©but de la colonne concern√©e est :\n\n\n    pb\n1  244\n2  232\n3  123\n4  210\n5   80\n6  220\n7  152\n8  155\n9  232\n10 135\n\n\nEcrivez un autre filtre qui s√©lectionne les patients √¢g√©s de plus de 15 ans. L‚Äôen-t√™te de votre colonne d‚Äô√¢ge doit ressembler √† ceci :\n\n\n  age\n1 348\n2 348\n3 312\n4 432\n5 444\n6 324\n\n\n\nSi nous ne voulons pas l‚Äô√©galit√© stricte nous pouvons ajouter un signe √©gal aux op√©rateurs pr√©c√©dents, ce qui donne &lt;= pour ‚Äúinf√©rieur ou √©gal √†‚Äù et &gt;= pour ‚Äúsup√©rieur ou √©gal √†‚Äù. Attention, le = doit venir apr√®s les op√©rateurs &lt; et &gt;, pas avant.\nPour filtrer les patients avec 10 ans ou moins :\n\ndf_brut |&gt;\n  filter(age &lt;= 120)\n\n\nS√©lectionnez tous les patients avec un √©tat nutritionnel normal, c‚Äôest-√†-dire les patients dont le PB est sup√©rieur ou √©gal √† 125mm. L‚Äôen-t√™te du pb devrait ressembler √† ceci :\n\n\n    pb\n1  244\n2  232\n3  210\n4  220\n5  152\n6  155\n7  232\n8  135\n9  146\n10 202\n\n\n\n\n\nConditions multiples\nIl est possible de combiner plusieurs conditions logiques dans un m√™me filtre ! Il suffit de s√©parer plusieurs conditions logiques par une virgule.\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  filter([condition 1],\n         [condition 2],\n         [condition 3])\n\nPar exemple, nous pourrions s√©lectionner tous les patients hospitalis√©s de moins de cinq ans :\n\ndf_brut |&gt;\n  filter(age &lt; 5,\n         hospitalisation == \"oui\")\n\n\nCr√©ez un filtre qui s√©lectionne tous les patients de la sous-pr√©fecture de Koumra hospitalis√©s et s√©v√®rement malnutris Cela donne :\n\n\n    id sous_prefecture hospitalisation  pb\n1 8624          KOUMRA             oui 103\n2 8939          KOUMRA             oui  67\n3 9957          KOUMRA             oui  71\n\n\nIndice :  if faut une condition sur le statut d‚Äôhospitalisation, une sur la sous-pr√©fecture et une sur le PB.\n\n\n\nR√©sum√© des conditions logiques\nNous avons fait le tour des conditions logiques les plus basiques en R. Les voici rassembl√©es dans un tableau pour r√©f√©rences futures :\n\n\n\nCondition\nR\n\n\n\n\nA identique √† B ?\nA == B\n\n\nA pas identique √† B ?\nA != B\n\n\nA sup√©rieur √† B ?\nA &gt; B\n\n\nA sup√©rieur ou √©gal √† B ?\nA &gt;= B\n\n\nA inf√©rieur √† B ?\nA &lt; B\n\n\nA inf√©rieur ou √©gal √† B ?\nA &lt;= B"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "href": "sessions_core/04_data_verbs_conditional.html#recoder-des-variables-avec-case_when",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "Recoder des variables avec case_when()",
    "text": "Recoder des variables avec case_when()\nL‚Äôutilit√© des conditions logiques dans le traitement de donn√©es va bien plus loin que la s√©lection de lignes ! Elles sont par exemple tr√®s utiles quand nous voulons recoder des variables. Nous utiliserons les conditions logiques √† l‚Äôint√©rieur de la fonction case_when() (√©galement du paquet {dplyr}) pour recoder les variables.\nLa fonction case_when() est un peu plus complexe que ce que l‚Äôon a vu jusqu‚Äô√† pr√©sent, mais tr√®s puissante (et va donc vous √™tre tr√®s utile). Nous allons d√©composer sa syntaxe pas √† pas.\nVous utiliserez presque toujours case_when() dans un mutate() pour recoder une variable existante ou en cr√©er une nouvelle, avec cette syntaxe :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf_brut |&gt;\n  mutate(nouvelle_colonne = case_when(\n    [condition_1] ~ [valeur_si_condition_1_est TRUE],\n    [condition_2] ~ [valeur_si_condition_2_est TRUE],\n    .d√©faut = [valeur_par_d√©faut]))\n\nD√©composons-la commande.\nA l‚Äôexception de la derni√®re ligne, chaque ligne √† l‚Äôint√©rieur de la fonction case_when() a le format suivant :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\n[condition] ~ [valeur si condition est VRAIE]  # Les crochets sont l√† pour la lisibilit√©\n\nAinsi, pour recoder les patients avec un PB inf√©rieur √† 110mm comme \"MAS\", nous √©crivons la commande suivante dans notre case_when() :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\n# [condition] ~ [valeur si VRAIE]\n   pb &lt; 110   ~ \"MAS\"\n\nIl y a en g√©n√©ral plus d‚Äôune condition ! Dans notre exemple, une autre condition logique testerait si le patient est mod√©r√©ment malnutri avec l‚Äôinstruction pb &lt; 125 ~ \"MAM\".\nLa derni√®re ligne de notre pseudo code contient l‚Äôargument .default et sert √† fournir la valeur √† utiliser lorsqu‚Äôaucune des conditions n‚Äôest remplie. Dans notre exemple, √ßa pourrait √™tre \"Normal\".\nPour r√©sumer, pour r√©sumer, pour cr√©er une variable contenant le statut nutritionnel √† partir du PB :\n\ndf_brut |&gt;\n  mutate(malnut = case_when(\n    pb &lt; 110 ~ \"MAS\",\n    pb &lt; 125 ~ \"MAM\",\n    .default = \"Normal\"))\n\n\nEx√©cutez le code ci-dessus pour cr√©er une variable malnut contenant le statut nutritionnel des patients. Le haut des deux colonnes concern√©es renvoie :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAS\n6 220 Normal\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nL‚Äôordre des conditions logiques est important ! case_when() teste les conditions dans l‚Äôordre que vous lui donnez et attribue une valeur d√®s qu‚Äôune condition est TRUE.\nAinsi, dans l‚Äôexemple ci-dessus, case_when() pose ces questions suivantes dans l‚Äôordre :\n\nEst-ce que pb &lt; 110 pour ce patient ? Si oui, attribuer la valeur \"MAS\"\nSi le patient n‚Äôest pas MAS, est-ce que pb &lt; 125 ? Si oui, attribuer la valeur \"MAM\"\nSi aucune des conditions pr√©c√©dentes n‚Äôest vraie, attribuer la valeur \"Normal\"\n\n\n\n\nIntervertissez l‚Äôordre des deux premi√®res conditions dans le case_when()pr√©c√©dent (pb &lt; 125 test√© en premier). Le haut des deux colonnes concern√©es est maintenant :\n\n\n   pb malnut\n1 244 Normal\n2 232 Normal\n3 123    MAM\n4 210 Normal\n5  80    MAM\n6 220 Normal\n\n\nVous pouvez enregistrer le data frame cr√©e dans un objet temporaire temp pour l‚Äôinspecter plus facilement. O√π sont les patients MAS ? Comprenez-vous ce qui s‚Äôest pass√© ?\n\n\n\n\n\n\n\nNote\n\n\n\nL‚Äôargument .default dans case_when() n‚Äôest pas obligatoire. Si vous ne l‚Äôincluez pas, case_when() utilisera la valeur NA par d√©faut.\n\n\nDans notre exemple, nous avons utilis√© case_when() pour cr√©er une variable cat√©gorique (le statut nutritionnel) √† partir d‚Äôune variable continue (le PB). Un autre exemple typique et similaire est de cr√©er une colonne contenant les classes d‚Äô√¢ge.\n\nUtilisez case_when() pour cr√©er une variable groupe_age avec les cat√©gories suivantes :\n\n\"&lt; 5 Ans\"\n\"5 - 15 Ans\"\n\"&gt; 15 Ans\".\nsi l‚Äô√¢ge est manquant, attribuer la valeur \"Inconnu\".\n\nFaites attention √† l‚Äôordre ! L‚Äôen-t√™te des colonnes concern√©es doit ressembler √† ceci :\n\n\n   age  age_group\n1   36    &lt; 5 Ans\n2    5    &lt; 5 Ans\n3  156 5 - 15 Ans\n4    8    &lt; 5 Ans\n5    7    &lt; 5 Ans\n6    4    &lt; 5 Ans\n7    2    &lt; 5 Ans\n8   48    &lt; 5 Ans\n9  156 5 - 15 Ans\n10 348   &gt; 15 Ans\n\n\n\n\nL‚Äôop√©rateur %in%\nNous savons maintenant recoder les variables en cat√©gories, ce qui vous arrivera tr√®s souvent en √©pid√©miologie. Un autre cas d‚Äôusage majeur est d‚Äôutiliser case_when() pour standardiser les valeurs d‚Äôune variable.\n\nUtilisez count() pour inspecter les variables cat√©gorielles de votre jeu de donn√©es. Lesquelles devraient √™tre standardis√©es ?\n\nVous avez d√ª voir que la variable sexe pr√©sente quelques probl√®mes d‚Äôencodage. Par exemple, les patientes sont cod√©es comme f, female et femme. Utilisons case_when() pour recoder cette variable. Ici, nous ne cr√©erons pas une nouvelle variable, mais remplacerons la variable existante :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(sexe == \"f\"      ~ \"Femme\",\n                          sexe == \"female\" ~ \"Femme\",\n                          sexe == \"femme\"  ~ \"Femme\",\n                          sexe == \"h\"      ~ \"Homme\",\n                          sexe == \"male\"   ~ \"Homme\",\n                          sexe == \"homme\"  ~ \"Homme\",\n                          .default = \"Inconnu\"))\n\nCe code fonctionne correctement mais est terriblement r√©p√©titif et verbeux. Heureusement il y a un raccourci pour lister toutes les options √† r√©affecter √† ‚ÄúFemme‚Äù (et celles √† ‚ÄúHomme‚Äù), l‚Äôop√©rateur %in% ! L‚Äôop√©rateur %in% permet de tester la condition ‚Äúest ce que la valeur existe dans ce vecteur ?‚Äù.\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\n[valeur] %in% [vector_des_options]\n\nAinsi, par exemple, nous pourrions v√©rifier si la valeur ‚Äúf‚Äù est dans les options ‚Äúf‚Äù et ‚Äúfemme‚Äù :\n\n\"f\" %in% c(\"f\", \"femme\")\n\n\nEx√©cutez l‚Äôinstruction ci-dessus. Quel est le type de donn√©es de votre r√©sultat ?\n\nLa commande renvoie un boll√©en, c‚Äôest-√†-dire un r√©sultat logique. C‚Äôest donc une condition logique valide √† utiliser dans un case_when() (ou un filter()) ! On peut donc simplifier notre code :\n\ndf_brut |&gt;\n  mutate(sexe = case_when(\n    sexe %in% c(\"f\", \"female\", \"femme\") ~ \"Femme\",\n    sexe %in% c(\"h\", \"male\", \"homme\") ~ \"Homme\",\n    .default = \"Inconnu\"))\n\nC‚Äôest plus court comme √ßa‚Ä¶\n\nUtilisez case_when() et l‚Äôop√©rateur %in% pour cr√©er une nouvelle colonne vacc_status_strict qui a la valeur :\n\n\"Oui\" si le statut vaccinal est confirm√©\n\"Non\" pour les cas non vaccin√©s\n\n\"Non v√©rifi√©\" sinon.\n\nLa t√™te de la nouvelle colonne ressemble √† ceci :\n\n\n  statut_vaccinal statut_vaccinal_strict\n1            &lt;NA&gt;            Non v√©rifi√©\n2             Non                    Non\n3      Oui - oral            Non v√©rifi√©\n4             Non                    Non\n5             Non                    Non\n6             Non                    Non"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-donn√©es",
    "href": "sessions_core/04_data_verbs_conditional.html#pipeline-de-nettoyage-des-donn√©es",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "Pipeline de nettoyage des donn√©es",
    "text": "Pipeline de nettoyage des donn√©es\nMaintenant que vous savez utiliser les conditions logiques pour recoder colonnes avec case_when(), nous pouvons reprendre le pipeline de nettoyage que nous avions commenc√© dans la session pr√©c√©dente.\n\nReprenez, le code de la session pr√©c√©dente, amendez-le et compl√©tez le pour cr√©er un gros pipeline de nettoyage des donn√©es, qui cr√©e un data frame df_linelist en effectuant les op√©rations suivantes :\n\nSupprimer les variables nom_complet et unite_age\nRenommer les variables suivantes :\n\nage devient age_ans\nsous_prefecture devient prefecture\nvillage_commune devient village\nnom_structure_sante devient structure\n\nAjouter une variable age_ans avec l‚Äô√¢ge du patient en ann√©es\nMettre √† jour region et prefecture pour utiliser la casse de titre\nMettre √† jour toutes les colonnes contenant des dates pour utiliser le type Date\nCr√©er une nouvelle variable groupe_age avec les groupes &lt; 6 mois, 6 - 11 mois, 12 - 59 mois, 5 - 15 ans et &gt; 15 ans (les patients dont l‚Äô√¢ge est inconnu sont Inconnu)\nRecoder le sexe pour n‚Äôavoir que les valeurs : Femme, Homme et Inconnu\n\nSupprimer toutes les lignes en double\n\nLe d√©but de vos donn√©es finales devrait ressembler √† ceci :\n\n\n  id  sexe age_mois  region prefecture        village date_debut\n1  1 Femme       36 Mandoul   Moissala Sangana Ko√Øtan 2022-08-13\n2  2 Femme        5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3 Femme      156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 Homme        8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7 Homme        7 Mandoul   Moissala      T√©tindaya 2022-08-30\n6 10 Homme        4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             oui     2022-08-14\n2        2022-08-25             oui     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25             non           &lt;NA&gt;\n5        2022-09-02             non           &lt;NA&gt;\n6        2022-09-02             oui     2022-09-02\n                        structure tdr_paludisme fievre eruption toux\n1 H√¥pital du District de Moissala       negatif     No     &lt;NA&gt;  Yes\n2 H√¥pital du District de Moissala       negatif     No       No  Yes\n3                      CS Silambi       negatif    Yes     &lt;NA&gt;   No\n4 H√¥pital du District de Moissala       negatif     No       No   No\n5                      CS Silambi       negatif   &lt;NA&gt;       No  Yes\n6                    Moissala Est       negatif    Yes       No   No\n  yeux_rouges pneumonie encephalite  pb statut_vaccinal doses_vaccin issue\n1          No        No          No 244            &lt;NA&gt;         &lt;NA&gt; gueri\n2          No      &lt;NA&gt;          No 232             Non         &lt;NA&gt;  &lt;NA&gt;\n3          No        No        &lt;NA&gt; 123      Oui - oral         &lt;NA&gt; gueri\n4        &lt;NA&gt;        No          No 210             Non         &lt;NA&gt; gueri\n5         Yes        No          No  80             Non         &lt;NA&gt; gueri\n6        &lt;NA&gt;        No          No 220             Non         &lt;NA&gt; gueri\n  date_issue    age_ans   groupe_age\n1 2022-08-18  3.0000000 12 - 59 mois\n2 2022-08-28  0.4166667     &lt; 6 mois\n3       &lt;NA&gt; 13.0000000   5 - 15 ans\n4       &lt;NA&gt;  0.6666667  6 - 11 mois\n5       &lt;NA&gt;  0.5833333  6 - 11 mois\n6 2022-09-03  0.3333333     &lt; 6 mois\n\n\n\nTop ! Nous pouvons maintenant exporter ce data frame (presque) propre hors de R. Pour cela nous utiliserons la fonction export() de {rio} (et notre fid√®le compagnon, la fonction here() de {here} pour g√©rer les chemins d‚Äôacc√®s) :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.xlsx'))\n\nNotez ici que nous pla√ßons nos donn√©es dans le sous-dossier clean dans data.\n\n\n\n\n\n\nAstuce\n\n\n\nEnregistrer les donn√©es au format .xlsx est utile pour pouvoir les ouvrir dans Excel pour les inspecter ou les partager. Cependant, nous pr√©f√©rerons souvent utiliser un fichier avec l‚Äôextension .rds. Ce type de fichier est sp√©cifique √† R et est plus robuste aux probl√®mes li√©s √† l‚Äôencodage ou au formatage des dates que les fichiers de type .xlsx ou .csv.\nPour exporter votre data frame vers un fichier .rds, il suffit de modifier l‚Äôextension :\n\ndf |&gt;\n  export(here('data', 'clean', 'measles_linelist_clean.rds')) # TADAM !"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "href": "sessions_core/04_data_verbs_conditional.html#cest-fini",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "C‚Äôest fini !",
    "text": "C‚Äôest fini !\nBravo. Lors des deux derni√®res sessions vous avez appris √† utiliser les fonctions qui forment le socle du traitement de donn√©es, mais aussi les conditions logiques et comment organiser votre code en un pipeline de nettoyage !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "href": "sessions_core/04_data_verbs_conditional.html#aller-plus-loin",
    "title": "Traitement de donn√©es, recoder et filtrer",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices suppl√©mentaires"
  },
  {
    "objectID": "sessions_core/02_import_data.html",
    "href": "sessions_core/02_import_data.html",
    "title": "Importation des donn√©es",
    "section": "",
    "text": "Cr√©er un projet RStudio\nMettre en place un code organis√© et bien document√©\nInstaller et charger des paquets dans la session\nEcrire des chemins d‚Äôacc√®s aux fichiers robustes\nImporter et inspecter des donn√©es dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des donn√©es s‚Äôappliquent aussi √† votre code : on souhaite √©crire un script qui fonctionne maintenant, mais √©galement dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider √† aller dans cette direction, et la premi√®re est d‚Äôavoir un code source propre et bien organis√©."
  },
  {
    "objectID": "sessions_core/02_import_data.html#objectifs",
    "href": "sessions_core/02_import_data.html#objectifs",
    "title": "Importation des donn√©es",
    "section": "",
    "text": "Cr√©er un projet RStudio\nMettre en place un code organis√© et bien document√©\nInstaller et charger des paquets dans la session\nEcrire des chemins d‚Äôacc√®s aux fichiers robustes\nImporter et inspecter des donn√©es dans R\n\n\n\n\n\n\n\nImportant\n\n\n\nLes principes vus dans le module FETCH sur la gestion des donn√©es s‚Äôappliquent aussi √† votre code : on souhaite √©crire un script qui fonctionne maintenant, mais √©galement dans le futur, et qui soit partageable. Il existe quelques bonnes pratiques qui peuvent nous aider √† aller dans cette direction, et la premi√®re est d‚Äôavoir un code source propre et bien organis√©."
  },
  {
    "objectID": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "href": "sessions_core/02_import_data.html#mise-en-place-du-projet",
    "title": "Importation des donn√©es",
    "section": "Mise en place du projet",
    "text": "Mise en place du projet\n\nStructure des dossiers\n\nSi ce n‚Äôest pas d√©j√† fait, t√©l√©chargez le dossier du cours d√©compressez-le. Sauvegardez le dossier non compress√© √† un endroit non connect√© √† OneDrive et ouvrez-le.\n\n\n\n  Dossier du cours\n\n\n\n\nCe dossier illustre une structure typique et recommand√©e pour vos projets de code :\n\nüìÅ data\n\nüìÅ raw\nüìÅ clean\n\nüìÅ R\nüìÅ outputs\n\nCe dossier sera votre r√©pertoire de travail pour toutes les sessions de ce cours. Vous y cr√©erez un projet RStudio (explications ci-dessous), et y enregistrerez tous vos scripts (sous dossier R). Les donn√©es brutes se trouvent d√©j√† dans data/raw.\n\n\nD√©finitions\nVoici deux concepts importants que nous allons rencontrer dans cette session :\nR√©pertoire de travail. Le r√©pertoire de travail est l‚Äôemplacement (dossier) o√π votre session R en cours travaille. Si vous enregistrez un fichier, par exemple, il sera enregistr√© dans ce dossier par d√©faut. De m√™me, Si vous ouvrez un fichier, ce dossier sera affich√© par d√©faut. Tous les chemins relatifs auront ce dossier pour origine. Par d√©faut, R choisit g√©n√©ralement votre dossier ‚ÄúDocuments‚Äù comme r√©pertoire de travail sur les machines Windows.\nRacine. La racine fait r√©f√©rence au niveau de dossier le plus √©lev√© du r√©pertoire de travail. Si le dossier de votre cours s‚Äôappelle FETCHR la racine se trouverait directement √† l‚Äôint√©rieur de celui-ci (et non dans l‚Äôun de ses sous-dossiers comme R ou data).\n\n\nProjets RStudio\nUn projet RStudio est outil qui va faciliter votre vie et aider RStudio √† trouver les diff√©rents fichiers.\nPour rappel, votre interface doit ressembler √† ceci :\n\n\n\n\n\n\nFigure¬†1: Capture d‚Äô√©cran d‚Äôune interface RStudio typique\n\n\n\n\nOuvrez RStudio et suivez ces √©tapes pour cr√©er un nouveau projet :\n\ncliquez sur File &gt; New Project &gt; Existing Directory &gt; Browse,\nnaviguez jusqu‚Äôau dossier du cours (en l‚Äôouvrant)\ncliquez sur Create Project.\n\n\n\nDans l‚Äôexplorateur Windows, examinez le dossier du cours. Vous devriez maintenant voir un nouveau fichier avec l‚Äôextension .Rproj qui a une petite ic√¥ne bleue avec un R au milieu\n\n\n\n\nIc√¥ne associ√©e aux projets RStudio\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi vous ne voyez pas ce fichier, c‚Äôest probablement parce qu‚Äôil est cach√© par d√©faut sur votre ordinateur. Pour modifier ce param√®tre dans l‚Äôexplorateur Windows, allez dans le menu Afficher et s√©lectionnez Extensions de noms de fichier.\n\n\nLorsque vous ouvrez un projet RStudio, RStudio d√©marre une nouvelle session R sp√©cifique √† ce projet, ouvre les fichiers associ√©s et d√©finit la racine de votre dossier comme r√©pertoire de travail. Une cons√©quence imm√©diate est que le panneau Files en bas √† droite de l‚Äôinterface montre les sous dossiers pr√©sents dans le r√©pertoire de travail, i.e. votre dossier de cours.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est fortement recommand√© de mettre en place un projet RStudio distinct pour chacune de vos analyses afin de garantir que les fichiers de vos projets restent organis√©s.\n\n\nIl existe plusieurs fa√ßons d‚Äôouvrir un projet RStudio :\n\nUtilisez le menu RStudio File &gt; Open Project puis s√©lectionnez le fichier .Rproj appropri√©\nCliquez sur le bouton Project: (none) en haut √† droite de l‚Äôinterface RStudio\nNaviguez dans l‚Äôexplorateur de fichiers Windows jusqu‚Äô√† votre dossier de cours et double-cliquez sur le fichier avec l‚Äôextension .Rproj\n\n\n\nLes options de RStudio\nAvant de poursuivre, allons modifier certaines des options de RStudio qui peuvent causer des probl√®mes.\n\nOuvrez les options globales (Tools &gt; Global Options) et ouvrez l‚Äôonglet General (menu de gauche). D√©selectionnez toutes les cases des sections R Sessions, Workspace et History.\n\n\n\n\nCapture d‚Äô√©cran des options de RStudio\n\n\nLorsque ces options sont activ√©es, RStudio enregistre les objets de votre environnement et les charge √† chaque fois que vous ouvrez une nouvelle session R. Ca semble √™tre une bonne id√©e, mais il est en fait pr√©f√©rable de toujours commencer votre travail √† partir d‚Äôune session R vide afin d‚Äô√©viter les erreurs.\n\n\n\n\n\n\nImportant\n\n\n\nN‚Äôoubliez pas que toutes les commandes n√©cessaires au nettoyage et √† l‚Äôanalyse de vos donn√©es doivent √™tre enregistr√©es explicitement dans un script, dans le bon ordre. Faire retourner le script devrait arriver aux m√™mes r√©sultats que pr√©c√©dement.\n\n\n\n\nCr√©ation d‚Äôun nouveau script\n\nOuvrez un nouveau script et enregistrez-le dans le sous-dossier R de votre projet sous le nom import_data.R.\nAjoutez des m√©tadonn√©es au d√©but du script, comme recommand√© lors premi√®re session, en utilisant des commentaires. Veillez √† inclure :\n\nLe titre\nL‚Äôauteur du script\nLa date de cr√©ation\nUne description rapide de ce que fait le script\n\n\nNous sommes pr√™ts √† commencer √† coder"
  },
  {
    "objectID": "sessions_core/02_import_data.html#sec-packages",
    "href": "sessions_core/02_import_data.html#sec-packages",
    "title": "Importation des donn√©es",
    "section": "Paquets",
    "text": "Paquets\nLes paquets [packages] sont des collections de fonctions qui √©tendent les fonctionalit√©s de R. Vous en utiliserez un grand nombre pendant ce cours et dans votre travail quotidien. R √©tant open-souce, les packages sont t√©l√©chargeable et utilisable gratuitement.\n\n\n\n\n\n\nNote\n\n\n\nDans ce cours, nous utiliserons une convention commune qui est de r√©f√©rencer les paquets entre {}. Par exemple {ggplot2} est le nom du paquet ggplot2 qui contient des fonctions pour cr√©er des graphes, telles que ggplot(), geom_point() etc‚Ä¶\n\n\n\nInstallation\nLa fonction install.packages() t√©l√©charge et installe un nouveau paquet sur votre ordinateur, dans la biblioth√®que de paquets associ√©e √† R. Vous n‚Äôavez √† faire cette op√©ration qu‚Äôune seule fois par paquet et ordinateur.\n\ninstall.packages(\"here\") # installe le paquet {here} \n\nN‚Äôoubliez pas de mettre le nom du paquet entre guillemets lorsque vous utilisez la commande install.packages(). Que se passe-t-il si vous ne le faites pas ?\n\n\n\n\n\n\nNote\n\n\n\nSi vous suivez cette session dans le cadre d‚Äôun cours, pour √©viter tout probl√®me potentiel de connectivit√© internet pendant la formation, nous vous avons d√©j√† fait installer la plupart des paquets du cours.\nSi vous suivez ce tutoriel seul ou si vous n‚Äôavez pas encore install√© les paquets, vous devrez installer manuellement chaque nouveau paquet que nous rencontrerons avec la fonction install.packages().\n\n\n\n\nUtilisation\nUne fois qu‚Äôun paquet est install√©, il faut indiquer √† R que nous souhaitons l‚Äôutiliser pour une session donn√©e en le chargeant dans la session avec la fonction library().\n\nlibrary(here) # charge le paquet {here} dans la session\n\n\nUtilisez la fonction library() pour charger les paquets here et rio qui seront utilis√©s aujourd‚Äôhui.\n\nIl se peut que vous obteniez parfois un message d‚Äôavertissement signalant que certaines fonctions ont √©t√© masqu√©es ou que la version actuelle du paquet a √©t√© construite pour une version diff√©rente de R. Ces messages ne doivent pas vous inqui√©ter, mais il faut les lire et essayer de comprendre ce qui se passe.\n\nEx√©cutez le code suivant. Comprenez-vous le message d‚Äôerreur ?\n\nlibrary(ggplot)\n\n\nLe code ci-dessus g√©n√®re une erreur car il y a une faute de frappe dans le nom du paquet, et vous avez donc essay√© de charger un paquet qui n‚Äôexiste pas. Rappelez-vous que R est p√©nible, et en particulier est sensible √† la casse : beaucoup de vos erreurs viendront de petites fautes dans les noms de fonctions ou d‚Äôobjets. Ici, par exemple, nous voulions charger le paquet ggplot2 mais nous avons √©crit ggplot √† la place.\n\n\n\n\n\n\nAstuce\n\n\n\nIl est recommand√© d‚Äôavoir une section au d√©but de votre script qui charge tous les paquets dont vous aurez besoin dans votre script en un seul endroit :\n\n# Packages ----------------------------\nlibrary(tidyverse)   # manipulation de donn√©es\nlibrary(lubridate)   # manipulation des dates\n\nCel√† permet de savoir rapidement quels paquets doivent √™tre install√©s pour ex√©cuter un script.\n\n\n\nCr√©ez une section ‚ÄúPaquets‚Äù dans votre script √† l‚Äôaide de commentaires\n\n\n\nMettre √† jour les paquets\nR dispose d‚Äôune communaut√© de d√©veloppeurs tr√®s active et il est assez courant que les paquets soient mis √† jour, avec de nouvelles fonctionalit√©s ou des corrections de bugs. Pour mettre √† jour les paquets de votre biblioth√®que, rendez-vous dans l‚Äôonglet Packages du panneau inf√©rieur droit et cliquez sur Update. N‚Äôoubliez pas que vous devez √™tre connect√© √† internet pendant ce processus.\n\n\n\n\n\n\nImportant\n\n\n\nLa mise √† jour de certains paquets peut parfois changer le comportement de certaines fonctions, ce qui peut casser votre code. Pas de panique. La meilleure pratique consiste √† adapter votre code mais, dans le pire des cas, vous pouvez installer une ancienne version du paquet incrimin√©."
  },
  {
    "objectID": "sessions_core/02_import_data.html#importation-de-donn√©es",
    "href": "sessions_core/02_import_data.html#importation-de-donn√©es",
    "title": "Importation des donn√©es",
    "section": "Importation de donn√©es",
    "text": "Importation de donn√©es\n\nTrouver son chemin‚Ä¶\nPour ouvrir un fichier dans R, vous devez fournir un chemin d‚Äôacc√®s au fichier. Un chemin d‚Äôacc√®s est simplement un (long) nom pour un fichier qui inclut son emplacement sur votre ordinateur. Les chemins d‚Äôacc√®s peuvent √™tre absolus ou relatifs.\n\nChemins d‚Äôacc√®s absolus\nLes chemins d‚Äôacc√®s absolus sont sp√©cifiques √† votre ordinateur et vont jusqu‚Äôau niveau de votre disque dur. Par exemple : D:/OneDrive - MSF/Documents/monitoring/cholera/fancy_project/data/raw/example_linelist.xlsx. Il est clair que ce chemin ne fonctionne que sur un ordinateur particulier.\nL‚Äôutilisation de chemins absolus encod√©s en dur est fortement d√©conseill√© car cela rend votre code fragile et augmente la maintenance : en effet, les chemins devront tous √™tre mis √† jour chaque fois quelqu‚Äôun d‚Äôautre ex√©cute votre code, ou que le dossier du projet est d√©plac√© sur votre ordinateur.\n\n\nChemins d‚Äôacc√®s relatifs\nLes chemins relatifs sont d√©finis par rapport √† votre r√©pertoire de travail. Comme l‚Äôemplacement du fichier .Rproj d√©finit le r√©pertoire de travail, les chemins sont relatifs √† cette racine. Pour vous, un chemin relatif ressemblera √† √ßa : data/raw/example_linelist.xlsx.\nCela signifie que tant que la structure interne du dossier contenant votre projet est pr√©serv√©e, le chemin d‚Äôacc√®s relatif sera valable quelque soit l‚Äôordinateur.\n\n\nChemins d‚Äôacc√®s robustes avec la fonction here()\nLe paquet {here} dispose d‚Äôune fonction here() qui aide √† cr√©er des chemins d‚Äôacc√®s. Elle pr√©sente deux avantages :\n\nElle d√©tecte la pr√©sence d‚Äôun fichier .Rproj et est capable de construire un chemin absolu √† partir d‚Äôun chemin relatif dans votre projet RStudio.\nElle choisit automatiquement le s√©parateur adapt√© √† votre syst√®me d‚Äôexploitation : /, \\ ou //.\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"C:/Users/M-MOUSSET/AppData/Local/Temp/RtmpKwyCyA/file4178f8628f8/data/raw/example_linelist.xlsx\"\n\n\n\nlibrary(here)\nhere(\"data\", \"raw\", \"example_linelist.xlsx\")\n\n[1] \"C:/Users/M-MOUSSET/AppData/Local/Temp/RtmpKwyCyA/file4178f8628f8/data/raw/example_linelist.xlsx\"\n\n\nVoyez comme nous n‚Äôavons d√©fini que le chemin relatif et la fonction a reconstitu√© le chemin absolu. Cel√† marchera donc sur l‚Äôordinateur d‚Äôun coll√®gue, y compris sur un autre syst√®me d‚Äôexploitation, du moment que la structure du r√©pertoire de travail est intacte.\nNous vous encourageons fortement √† utiliser here() chaque fois que vous devez cr√©er un chemin d‚Äôacc√®s √† un fichier.\n\nEx√©cutez le code ci-dessus dans la console. Quel chemin d‚Äôacc√®s here(\"data\", \"raw\") vous donne-t-il ?\n\n\nUtilisez here() pour cr√©er le chemin vers le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx.\n\n\n\n\n\n\n\nImportant\n\n\n\nhere() cr√©e une cha√Æne de caract√®res contenant l‚Äôadresse d‚Äôun fichier, mais ne v√©rifie pas si ce fichier existe r√©ellement sur votre ordinateur. Si le fichier est absent ou s‚Äôil y a une faute de frappe dans votre code, vous obtiendrez une erreur lors de l‚Äôutilisation du chemin ainsi cr√©√©. Vous pouvez tester si un fichier existe √† cette adresse avec la fonction file.exists().\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nOn veut souvent d√©finir plusieurs chemins dans un projet (donn√©es brutes, donn√©es propres, o√π sauver les graphes etc.). C‚Äôest une bonne pratique que de cr√©er une nouvelle section au d√©but de votre script, apr√®s le chargement des paquets, pour d√©finir et stocker les chemins d‚Äôacc√®s dans des objets.\n\n\n\n\n\nImporter les donn√©es\nDans R, diff√©rents formats de fichiers sont import√©s par diff√©rentes fonctions sp√©cialis√©es, ce qui est fastidieux √† m√©moriser et √† charger. La fonction import() du paquet {rio} nous fait gagner du temps en reconnaissant l‚Äôextension des fichier et en appelent automatiquement une fonction sp√©cialis√©e pour charger les donn√©es.\nComme import() ne fait qu‚Äôappeler d‚Äôautres fonctions en arri√®re-plan, il est possible qu‚Äôelle ait besoin d‚Äôarguments optionnels sp√©cifiques pour certains types de fichier.\n\n\n\n\n\n\nAstuce\n\n\n\nLa (longue) liste des types de fichiers pris en charge par {rio} est sur le site du paquet. Dans la suite de la le√ßon, nous nous concentrerons sur l‚Äôimportation de donn√©es √† partir de fichiers Excel .xlsx.\n\n\n\nImport de la premi√®re feuille\nAu minimum la fonction import() a besoin qu‚Äôon lui donne le chemin du fichier avec l‚Äôargument file :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"))\n\nNotez que nous avons imbriqu√© la commande here() √† l‚Äôint√©rieur de la commande import(). L‚Äôimbrication de fonctions est autoris√©e et m√™me courrante en R. R √©value les fonctions imbriqu√©es de l‚Äôint√©rieur (here()) √† l‚Äôext√©rieur (import()). La valeur renvoy√©e par here() est donc utilis√©e comme valeur d‚Äôentr√©e d‚Äôimport().\n\nImportez le fichier Moissalla-rougeole-liste-lineaire-FR.xlsx en utilisant here() et import().\n\nSi votre importation a fonctionn√© correctement, R affichera les donn√©es dans la console mais ne les enregistrera pas dans l‚Äôenvironnement car nous ne les avons pas assign√©es √† un objet.\n\nR√©importez vos donn√©es, mais cette fois-ci, sauvegardez-les dans un objet appel√© df_linelist.\n\n\n\n\n\n\n\nAstuce\n\n\n\nSi votre jeu de donn√©es est tr√®s gros, il vaut mieux √©viter de l‚Äôafficher dans la console‚Ä¶\n\n\n\n\nImport d‚Äôune autre feuille\nComme vous venez de le voir, la fonction import() importe la premi√®re feuille d‚Äôun fichier Excel par d√©faut. Il est cependant possible de passer le num√©ro de la feuille ou son nom (en cha√Æne de caract√®res) √† l‚Äôargument which :\n\nimport(file = here(\"data\", \"raw\", \"example_linelist.xlsx\"),  # chemin\n       which = 2)                                            # sp√©cifie la deuxi√®me feuille\n\nNotez que l‚Äôargument which est sp√©cifique aux types de fichiers comportant plusieurs feuilles, tels que les fichiers Excel ou .Rdata. Si vous essayez de l‚Äôutiliser sur un fichier .csv l‚Äôargument sera ignor√©."
  },
  {
    "objectID": "sessions_core/02_import_data.html#aper√ßu-des-donn√©es",
    "href": "sessions_core/02_import_data.html#aper√ßu-des-donn√©es",
    "title": "Importation des donn√©es",
    "section": "Aper√ßu des donn√©es",
    "text": "Aper√ßu des donn√©es\nNous avons import√© un jeu de donn√©es dans R et l‚Äôavons assign√© √† un objet (df_linelist). Nous pouvons maintenant inspecter le data frame cr√©√© pour v√©rifier que l‚Äôexport s‚Äôest bien pass√©, et commencer √† √©valuer le nettoyage √† faire.\nNous pouvons commencer par jeter un coup d‚Äô≈ìil rapide aux premi√®res lignes du data frame √† l‚Äôaide de la fonction head(). Son premier argument est le data frame √† inspecter et le second, n, accepte un nombre de lignes √† afficher (optionnel).\n\nhead(df_linelist, n = 10) # Affiche les 10 premi√®res lignes\n\n\nUtilisez head() pour examiner les 12 premi√®res lignes de df_linelist.\n\nNous pouvons inspecter la structure du data frame √† partir de l‚Äôonglet Environnement dans le panneau sup√©rieur droit. Nous pouvons √©galement visualiser le data frame dans le le visualiseur de donn√©es de RStudio (en haut √† gauche).\n\nCliquez sur le bouton rond bleu √† c√¥t√© de df_linelist dans votre environnement pour examiner sa structure. Cliquez ensuite sur le nom du data frame pour le visualiser.\n\nLe visualiseur permet d‚Äôafficher le data frame comme dans un tableur et est un moyen pratique d‚Äôexaminer rapidement vos donn√©es. Vous pouvez trier et filtrer vos donn√©es dans cet onglet mais ces actions ne modifieront pas l‚Äôobjet df_linelist. Le visualiseur peut √©galement √™tre ouvert en utilisant directement la fonction View() sur le data frame."
  },
  {
    "objectID": "sessions_core/02_import_data.html#cest-fini",
    "href": "sessions_core/02_import_data.html#cest-fini",
    "title": "Importation des donn√©es",
    "section": "C‚Äôest fini !",
    "text": "C‚Äôest fini !\nBravo et n‚Äôoubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "href": "sessions_core/02_import_data.html#pour-aller-plus-loin",
    "title": "Importation des donn√©es",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices suppl√©mentaires\n\nUtilisez dim() pour examiner les dimensions de votre data frame.\nUtilisez str() pour v√©rifier le type de donn√©es de chaque colonne. Voyez-vous quelque chose d‚Äô√©trange ? N‚Äôoubliez pas que vous pouvez √©galement utiliser des fonctions telles que is.character() et is.numeric() si vous souhaitez tester le type d‚Äôune colonne particuli√®re.\nEn utilisant une fonction apprise lors de la premi√®re session, pouvez-vous extraire les noms des colonnes du data frame ? Ces r√©sultats correspondent-ils √† ce que vous voyez lorsque vous ouvrez les donn√©es dans Excel ?\nEssayez d‚Äôex√©cuter la fonction summary() sur votre data frame. Qu‚Äôest ce que le r√©sultat vous apprend sur les variables ?\n\n\n\nRessources compl√©mentaires\n\nLe site web de {rio}\nPlus d‚Äôexemples sur l‚Äôimportation de donn√©es de diff√©rents types de fichiers"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Ressources",
    "section": "",
    "text": "Cette page contiendra (√©ventuellement) des ressources externes pour poursuivre votre parcours d‚Äôapprentissage du R."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{repicentre}",
    "section": "",
    "text": "Bienvenue √† {repicentre}\nUne plateforme open source pour apprendre R dans les contextes humanitaires. Qu‚Äôaimeriez-vous faire ?\n\n\n\n\n\nApprendre Parcours lin√©aire en commen√ßant par les bases  Start\n\n\n\n\n\nExplorer Catalogue complet de cours d‚Äôautoformation  Start\n\n\n\n\n\nRessources Ressources externes pour aller plus loin  Start"
  },
  {
    "objectID": "about.html#salut",
    "href": "about.html#salut",
    "title": "√Ä Propos",
    "section": "Salut",
    "text": "Salut\nBienvenue sur {repicentre}, un site open source d√©velopp√© par Epicentre pour vous aider √† apprendre R pour les contextes humanitaires. Le site est compos√© de tutoriels autodidactes et propose deux options principales d‚Äôapprentissage :\n\nLin√©aire. Con√ßu pour les personnes n‚Äôayant aucune exp√©rience pr√©alable de R, le cours lin√©aire vous guidera √† travers les concepts de base de R en utilisant une √©tude de cas sur la rougeole au Tchad. Le cours couvre les concepts suivants :\n\nStructures de donn√©es et l‚Äôinterface RStudio\nImportation de donn√©es\nManipulation de donn√©es\nNettoyage des donn√©es\nAgr√©gation de donn√©es\nVisualisation des donn√©es\n\nExploration. Si vous avez un peu plus d‚Äôexp√©rience ou si vous recherchez un sujet particulier, n‚Äôh√©sitez pas √† explorer la gamme compl√®te des tutoriels. Les tutoriels sont class√©s par cat√©gories et sont con√ßus pour √™tre autonomes."
  },
  {
    "objectID": "about.html#recommandations-et-demandes",
    "href": "about.html#recommandations-et-demandes",
    "title": "√Ä Propos",
    "section": "Recommandations et demandes",
    "text": "Recommandations et demandes\nY a-t-il un sujet sur lequel vous aimeriez voir un tutoriel qui n‚Äôest pas encore disponible ? C‚Äôest tr√®s bien ! N‚Äôh√©sitez pas √† nous le faire savoir en ouvrant un ‚Äúissue‚Äù sur le repo GitHub associ√© √† ce site web. Si vous ne savez pas comment ouvrir un issue, veuillez contacter Cat Eisenhauer."
  },
  {
    "objectID": "about.html#contribuer",
    "href": "about.html#contribuer",
    "title": "√Ä Propos",
    "section": "Contribuer",
    "text": "Contribuer\nVous souhaitez contribuer √† la r√©daction ou √† la maintenance de tutoriels ? Incroyable ! Veuillez contacter Cat."
  },
  {
    "objectID": "explore.html",
    "href": "explore.html",
    "title": "Explorer",
    "section": "",
    "text": "Choisissez votre propre aventure en parcourant toutes les sessions disponibles.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCourbes √©pid√©miques hebdomadaires\n\n\n\nSatellite\n\n\nVisualization\n\n\n\nApprenez √† tracer des courbes √©pid√©miques hebdomadaires et √† am√©liorer les √©tiquettes des axes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExploration des donn√©es\n\n\n\nSatellite\n\n\nData Exploration\n\n\n\nExplorez vos donn√©es apr√®s l‚Äôimportation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraphiques multiples (facetting)\n\n\n\nSatellite\n\n\nVisualization\n\n\n\nApprenez √† cr√©er plusieurs mini graphiques ‚Äúpar cat√©gorie‚Äù en une seule commande\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportation des donn√©es\n\n\n\nCore\n\n\nRStudio\n\n\nData Import\n\n\n\nCr√©ez un projet Rstudio, installez les paquets utiles et importez des donn√©es pour travailler dans R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to data visualization with ggplot2\n\n\n\nCore\n\n\nVisualization\n\n\n\nApprenez les bases de la visualisation avec ggplot2, et cr√©ez votre premi√®re √©picurve\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction √† R\n\n\n\nCore\n\n\nR Basics\n\n\nData Types\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurveillance\n\n\n\nSatellite\n\n\nSurveillance\n\n\n\nTutoriel d‚Äôaccompagnement au module Surveillance du FETCH\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTableaux r√©capitulatifs\n\n\n\nCore\n\n\nTableaux de resum√©\n\n\n\nCr√©er des tableaux r√©capitulatifs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de donn√©es, les bases\n\n\n\nCore\n\n\nManipulation des donn√©es\n\n\nNettoyage des donn√©es\n\n\n\nUne introduction √† la manipulation et au nettoyage des donn√©es √† l‚Äôaide du paquet {dplyr}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de donn√©es, recoder et filtrer\n\n\n\nCore\n\n\nManipulation des donn√©es\n\n\nNettoyage des donn√©es\n\n\nLogique\n\n\n\nApprenez √† recoder vos variables avec {dplyr} et comment s√©lectionner les lignes d‚Äôun data frame suivant certains crit√®res\n\n\n\n\n\n\n31 mars 2025\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "pathway.html",
    "href": "pathway.html",
    "title": "Cours",
    "section": "",
    "text": "Ces sessions peuvent √™tre suivies afin d‚Äôobtenir un niveau de base dans R. La s√©rie suppose aucune exp√©rience pr√©alable dans R et convient bien aux d√©butants.\nVous en voulez plus ? Vous voulez plus de flexibilit√© ? Consultez le catalogue complet des sessions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction √† R\n\n\n\n\n\nVos premiers pas dans R. Familiarisez-vous avec Rstudio et avec les objets courants de R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportation des donn√©es\n\n\n\n\n\nCr√©ez un projet Rstudio, installez les paquets utiles et importez des donn√©es pour travailler dans R.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de donn√©es, les bases\n\n\n\n\n\nUne introduction √† la manipulation et au nettoyage des donn√©es √† l‚Äôaide du paquet {dplyr}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraitement de donn√©es, recoder et filtrer\n\n\n\n\n\nApprenez √† recoder vos variables avec {dplyr} et comment s√©lectionner les lignes d‚Äôun data frame suivant certains crit√®res\n\n\n\n\n\n31 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\nTableaux r√©capitulatifs\n\n\n\n\n\nCr√©er des tableaux r√©capitulatifs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to data visualization with ggplot2\n\n\n\n\n\nApprenez les bases de la visualisation avec ggplot2, et cr√©ez votre premi√®re √©picurve\n\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "sessions_core/01_introduction.html",
    "href": "sessions_core/01_introduction.html",
    "title": "Introduction √† R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCr√©er et ex√©cuter un script\nCr√©er des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#objectifs",
    "href": "sessions_core/01_introduction.html#objectifs",
    "title": "Introduction √† R",
    "section": "",
    "text": "Se familiariser avec RStudio\nApprendre le fonctionnement de la console\nCr√©er et ex√©cuter un script\nCr√©er des objets de base dans R, tels que des vecteurs et des data frames"
  },
  {
    "objectID": "sessions_core/01_introduction.html#format-des-exercices",
    "href": "sessions_core/01_introduction.html#format-des-exercices",
    "title": "Introduction √† R",
    "section": "Format des exercices",
    "text": "Format des exercices\nCes exercices sont dans un format tutoriel contenant de br√®ves explications sur les concepts cl√©s, des exemples et des instructions √† suivre. Notre approche est tr√®s orient√©e sur la pratique, et √† l‚Äôexception de cette premi√®re session partiellement ax√©e sur l‚Äôinterface, vous aurez beaucoup d‚Äôoccasions de coder.\nLes instructions pour les exercices seront donn√©es dans les formats suivants :\n\nCet encadr√© contient des instructions g√©n√©ralistes. Vous le trouverez en g√©n√©ral au d√©but d‚Äôune session, avec des instructions de mise en place.\n Exemple : Ouvrez un script vide et nommez-le mon_premier_script.R.\n\n\nCet encadr√© contient des instructions de code que vous devez √©crire dans votre script ou la console.\n Exemple : Cr√©ez un objet region qui contient la valeur \"Mandoul\".\n\n\nCet encadr√© vous demande d‚Äôobserver ou √©tudier quelque chose.\n Exemple : Inspectez l‚Äôinterface de RStudio.\n\nAu cours de ces exercices, vous rencontrerez certainement des erreurs, qui se produisent lorsque R n‚Äôest pas en mesure d‚Äôex√©cuter une commande. Cela peut se produire pour de nombreuses raisons : une faute d‚Äôorthographe dans le nom d‚Äôun objet ou d‚Äôune fonction, le mauvais type de donn√©es fournis etc. Lorsqu‚Äôune erreur se produit, R arr√™te les calculs en cours et affiche un message expliquant ce qu‚Äôil s‚Äôest pass√©. Il est tout √† fait normal d‚Äôavoir des erreurs, √ßa arrive tout le temps, √† tous les programmeurs, qu‚Äôils soient novices ou experts. Comme lorsque vous apprenez une langue (non informatique), vous vous am√©liorerez avec la pratique, en faisant des erreurs et en apprenant √† les corriger."
  },
  {
    "objectID": "sessions_core/01_introduction.html#rstudio-et-r",
    "href": "sessions_core/01_introduction.html#rstudio-et-r",
    "title": "Introduction √† R",
    "section": "RStudio et R",
    "text": "RStudio et R\nR est un langage de programmation fonctionnel qui peut √™tre utilis√© pour nettoyer et manipuler des donn√©es, effectuer des analyses (en particulier des analyses statistiques), visualiser des r√©sultats, et bien plus encore.\nRStudio est un logiciel qui fournit une interface facile √† utiliser pour R (√©galement appel√© IDE, pour ‚ÄúIntegrated Development Environment‚Äù). Son utilisation n‚Äôest pas obligatoire, mais tr√®s fortement recommand√©e pour les d√©butants.\n\nPremiers pas avec RStudio\n\nOuvrez RStudio en utilisant le menu de d√©marrage de votre ordinateur ou le raccourci cr√©√© par d√©faut sur le bureau ; si RStudio √©tait d√©j√† ouvert, fermez-le et ouvrez-le √† nouveau.\n\nVous devriez voir une interface qui ressemble √† ceci :\n\n\n\nVue de l‚Äôinterface de l‚ÄôIDE Rstudio √† l‚Äôouverture\n\n\n\nInspectez l‚Äôinterface de RStudio.\n\nVous verrez trois ou quatre panneaux.\n\nPanneau sup√©rieur droit\nEn haut √† droite se trouve un panneau avec plusieurs onglets. La plupart d‚Äôentre eux d√©passent le cadre de ce cours, mais nous utiliserons les deux onglets suivants :\n\nEnvironment : liste les objets enregistr√©s par l‚Äôutilisateur dans la session en cours. Comme vous venez de d√©marrer une nouvelle session, votre environnement devrait √™tre vide.\nHistory : comprend l‚Äôhistorique de toutes les commandes que vous avez ex√©cut√©es au cours de la session actuelle.\n\n\n\n\n\n\n\nNote\n\n\n\nOuvrir une nouvelle session R, c‚Äôest comme red√©marer son ordinateur : tout est vide et pr√™t pour le calcul, de la m√™me mani√®re qu‚Äôil n‚Äôy a aucun programme ouvert lorsque vous allumez votre ordinateur pour la premi√®re fois.\nNous vous encourageons √† arr√™ter et √† re-d√©marrer vos sessions R r√©guli√®rement. Parfois cela corrigera certains de vos probl√®mes !\n\n\n\n\nPanneau inf√©rieur droit\nEn bas √† droite se trouve un autre panneau comprenant les onglets suivants :\n\nFiles : un explorateur de fichiers pour le r√©pertoire de travail, qui est l‚Äôemplacement du dossier dans lequel R travaille actuellement.\nPlots : l√† o√π RStudio affichera les graphiques statiques. Cet onglet devrait √™tre vide pour le moment.\nPackages : liste de tous les paquets R install√©s sur votre ordinateur. Les paquets sont des collections de fonctions qui permettent d‚Äô√©tendre les fonctionnalit√©s de R. Nous les aborderons plus en d√©tail dans la prochaine le√ßon.\nHelp : un endroit pour lire les pages d‚Äôaide et la documentation pour les fonctions et les paquets.\nViewer : un emplacement o√π RStudio affichera des sorties html telles que des tableaux, des widgets interactifs ou m√™me des tableaux de bord.\n\n\n\nPartie gauche\n\nA gauche (ou en bas √† gauche si vous avez d√©j√† quatre panneaux), vous devriez voir l‚Äôonglet console, o√π le code R est ex√©cut√©.\nEn haut √† gauche (si vous avez quatre panneaux) se trouvent les scripts R ouverts.\n\n\n\n\nLa console\nLa console est l‚Äôendroit o√π le code R s‚Äôex√©cute.\nAu d√©but d‚Äôune nouvelle session, un texte d‚Äôinformation sur votre cofiguration appara√Æt tout en haut de la console, dont le num√©ro et nom de la version de R. En dessous de ces informations, il y a une ligne avec le symbole &gt; et un curseur clignotant.\nPour ex√©cuter une commande dans R, tapez-la √† la suite du &gt; et pressez Entr√©e. R traitera alors votre code et affichera le r√©sultat (s‚Äôil y en a un). Un nouveau &gt; s‚Äôaffichera alors sur la ligne suivante, indiquant que la console est pr√™te pour la commande suivante.\n\n\n\n\n\n\nImportant\n\n\n\nSi la derni√®re ligne est pr√©fac√©e d‚Äôun + au lieu d‚Äôun &gt;, cela signifie que la console n‚Äôest pas pr√™te. Soit elle attend qu‚Äôun calcul d‚Äôune commande pr√©c√©dente finisse, soit elle attend la fin d‚Äôune commande incompl√®te. A tout moment, vous pouvez interrompre l‚Äôex√©cution en pressant la touche Echap.\n\n\n\nEx√©cutez les commandes suivantes dans la console, une ligne √† la fois, et observez les r√©sultats.\n\n5 + 90\n\n6 * 171\n\n189 / 36.6\n\n92^3\n\n(12 + 9)^4 / 1000\n\nEx√©cutez maintenant la commande suivante. Notez que le ) fermant est manquant, ce qui rend la commande incompl√®te. Que se passe-t-il ?\n\n3 / (2 + 97\n\n\nVous avez peut-√™tre not√© dans les exemples pr√©c√©dents que notre code contient beaucoup d‚Äôespaces. C‚Äôest en effet une bonne pratique que d‚Äôinclure des espaces autour de la plupart des op√©rateurs, tels que +, -, *, /, &lt;, &gt;, = et &lt;-. Ces espaces facilitent la lecture et la compr√©hension de votre code, et dans certains cas (rares) ils permettent d‚Äô√©viter des erreurs. N√©anmoins, certains op√©rateurs ne doivent pas √™tre entour√©s d‚Äôespaces, tels que ^, . et :.\n\n1+29+4.8/3*3           # Mauvais\n1 + 29 + 4.8 / 3 * 3   # Bien\n\n1 ^ 2  # Mauvais\n1^2    # Bien\n\nNous pouvons √©galement ex√©cuter des fonctions dans la console. Nous aborderons les fonctions plus en d√©tail plus tard mais sachez que les fonctions dans R sont similaires aux fonctions dans Excel (telles que SOMME ou MOYENNE).\n\nEx√©cutez les commandes suivantes dans la console (une ligne √† la fois).\n\n# Trouvez la valeur minimale\nmin(5, 10)\nmin(1, 8, 56, 0.3)\n\n# Trouvez la valeur maximale\nmax(568, 258, 314)\n\n\n\n\nScripts\nLes scripts sont des fichiers texte qui contiennent une s√©rie de commandes pour un langage de programmation particulier. L‚Äôextension du fichier indique le langage dans lequel les commandes sont √©crites. Ici nous utiliserons l‚Äôextension .R. Les scripts nous permettent de cr√©er du code qui peut √™tre r√©utilis√©, partag√© et m√™me automatis√©.\n\n√âcrire son premier script\nPour cr√©er un nouveau script, allez dans le menu File &gt; New File &gt; R Script. Alternativement, cliquez sur la petite ic√¥ne avec un + vert sur une page blanche situ√©e en dessous du menu File. Ou encore, utilisez le raccourci clavier CTRL + MAJ + N. Ce nouveau script non sauvegard√© appara√Ætra sous la forme d‚Äôun document vierge dans le panneau sup√©rieur gauche.\n\n\n\nEtapes pour cr√©er un nouveau script dans RStudio\n\n\nPour enregistrer votre script, utilisez le menu File &gt; Save As ou le raccourci clavier CTRL + S.\n\nCr√©ez un script et enregistrez-le sous le nom decouverte.R(n‚Äôoubliez l‚Äôextension !). Pour l‚Äôinstant, vous pouvez l‚Äôenregistrer sur votre bureau ou √† tout autre endroit pratique, mais nous aborderons l‚Äôorganisation des scripts dans la prochaine session.\n\n\n\nEx√©cuter du code √† partir d‚Äôun script\nPour ex√©cuter du code √† partir d‚Äôun script, placez votre curseur sur la ligne que vous souhaitez ex√©cuter (ou s√©lectionnez plusieurs lignes) et effectuez l‚Äôune des op√©rations suivantes :\n\nCliquez sur le bouton Run en haut √† droite de la fen√™tre de script\nUtilisez le raccourci CTRL + Entr√©e (le curseur passera ensuite √† la ligne suivante)\nUtiliser le raccourci ALT + Entr√©e (le curseur restera sur la ligne actuelle)\n\n\nCopiez le code que vous aviez ex√©cut√© dans la console lors des exercices pr√©c√©dents dans votre script et ex√©cutez-le en testant les diff√©rentes m√©thodes ci-dessus.\nA partir de maintenant, vous √©crirez votre code dans votre script et l‚Äôex√©cuterez √† partir de l√†, sauf indication contraire de notre part.\n\n\n\nCommentaires\nDans R, le code qui est pr√©c√©d√© d‚Äôun # (di√®se) n‚Äôest pas ex√©cut√©, il est juste ignor√© jusqu‚Äô√† la fin de la ligne. C‚Äôest donc un bon moyen de documenter votre code.\n\n# Ceci est un commentaire\n\n2 + 3  # Ceci est aussi un commentaire\n\nIl est utile pour vous et vos coll√®gues de commencer vos scripts par quelques lignes comment√©es fournissant des informations importantes sur le contenu de votre script.\n\n# IMPORT & PREPARATION DES DONNEES #\n# Auteure :  Mathilde Mousset\n# Date de cr√©ation : 23/11/2024\n# Derni√®re mise √† jour : 28/01/2024\n# Description : Importat et nettoyage des donn√©es de surveillance rougeole de Moissala\n\n\nAjoutez quelques commentaires au d√©but de votre script pour le d√©crire.\n\nLes commentaires sont √©galement un moyen pratique de diviser les scripts longs en sections th√©matiques, telles que ‚ÄúImport des donn√©es‚Äù, ‚ÄúAnalyse‚Äù, ‚ÄúVisualisation‚Äù, etc. Par exemple :\n\n# NOM DE LA SECTION 1 -----------------------------------------------             \n\n# NOM DE LA SECTION 2 -----------------------------------------------             \n\n\nUtilisez les commentaires pour cr√©er des sections dans votre script qui correspondent aux sections principales de ce tutoriel.\n\nEnfin, les commentaires permettent de prendre des notes sur votre code pour aider √† la compr√©hension (celle de votre ‚Äúmoi futur‚Äù et celle de vos coll√®gues). On entend souvent le conseil de se focaliser sur les commentaires qui expliquent le ‚Äúpourquoi‚Äù plut√¥t que le ‚Äúquoi‚Äù, car le ‚Äúquoi‚Äù d‚Äôun code bien √©crit devrait √™tre clair.\nPar exemple, ce commentaire est superflu :\n\n1 + 3  # Code pour additionner un et trois\n\nEn comparaison, voici quelques cas o√π un commentaire est m√©rit√© :\n\nVous d√©finissez une constante, une valeur seuil de s√©ropr√©valence par exemple. Ajoutez un commentaire indiquant la r√©f√©rence d‚Äôo√π provient la valeur.\nVotre code contient une valeur ou un nom de fichier qui doit √™tre mis √† jour chaque semaine. Indiquez le dans un commentaire afin que toute personne utilisant le code en soit inform√©e.\nVous utilisez une commande contre-intuitive de premier abord, ou un paquet rare que votre coll√®gue ne conna√Æt peut-√™tre pas. Commentez pour expliquer vos raisons.\n\nCeci √©tant dit, vous √™tes en plein apprentissage, et les scripts que vous √©crivez pendant ce cours sont l‚Äô√©quivalent de vos notes de cours, alors n‚Äôh√©sitez pas √† utiliser autant de commentaires que vous le souhaitez pour expliquer les commandes et vous rappeler de ce qu‚Äôelles font. Vous √©crirez naturellement moins de commentaires avec la pratique, lorsque les choses qui nouvelles aujourd‚Äôhui deviendront naturelles.\n\n\n\n\n\n\nAstuce\n\n\n\nCommentez une ligne s√©lectionn√©e avec le raccourci CTRL + MAJ + C.\nAjoutez une section de premier niveau avec CTRL + MAJ + R.\n\n\n\nAjoutez quelques commentaires pour d√©crire le code que vous avez √©crit jusqu‚Äô√† pr√©sent dans votre script."
  },
  {
    "objectID": "sessions_core/01_introduction.html#types-de-donn√©es",
    "href": "sessions_core/01_introduction.html#types-de-donn√©es",
    "title": "Introduction √† R",
    "section": "Types de donn√©es",
    "text": "Types de donn√©es\nR dispose de plusieurs types de donn√©es. Ceux que nous verrons le plus souvent dans ce cours sont les suivants :\n\nnum√©rique [numeric en anglais]\ncha√Æne de caract√®res (texte) [string en anglais]\nbool√©en (VRAI / FAUX) [boolean en anglais]\ndate [date]\nfacteur [factor]\n\n\nNum√©rique\nLe type num√©rique englobe les entiers [integers en anglais] et les doubles (nombres d√©cimaux). Les nombres en R n‚Äôont pas de signal√©tique, tapez simplement la valeur brute dans votre script ou votre console.\n\n\nCha√Ænes de caract√®res\nLes cha√Ænes de caract√®res [strings] repr√©sentent le texte en R. Elles sont tap√©es en entourant votre texte de guillemets simples ou doubles, \"district\" ou 'cas' par exemple (les guillemets doubles sont g√©n√©ralement consid√©r√©s comme la meilleure pratique).\n\nComparez la sortie dans la console pour les commandes suivantes :\n\n28         # num√©rique\n\"28\"       # texte\n28 + \"28\"  # donne une erreur\n\n\nLa derni√®re commande ci-dessus a renvoy√© une erreur car nous ne pouvons pas effectuer d‚Äôop√©rations arithm√©tiques combinant du texte et des nombres.\n\n\n\n\n\n\nImportant\n\n\n\nR est sensible √† la casse (majuscules ou minuscules), ce qui signifie que \"ABC\" n‚Äôest pas √©quivalent √† \"abc\".\n\n\n\nSi vous souhaitez cr√©er une cha√Æne de caract√®res contenant des guillemets, il faut √©chapper les guillements les faisant pr√©c√©der d‚Äôun \\. Par exemple : \"Elle dit \\\"Bonjour\\\" et s'en alla\" ou 'C\\'est une belle journ√©e'. Si vous avez utilis√© des guillements doubles pour cr√©er votre cha√Æne de caract√®res, vous pouvez utiliser des guillemets simples √† l‚Äôint√©rieur de celle-ci (par exemple : \"C'est une belle journ√©e\") et vice versa (par exemple : 'Elle dit \"Bonjour\" et s'en alla').\n\n\n\nBool√©en (logique)\nLe type bool√©en (ou logique) stocke des valeurs vrai/faux et est cr√©√© en √©crivant soit TRUE [VRAI] ou FALSE [FAUX] sans guillemets.\nEn interne, R traduit TRUE et FALSE en √©quivalents num√©riques 1 et 0 respectivement, ce qui peut √™tre utile pour des op√©rations arithm√©tiques.\n\n\n\n\n\n\nNote\n\n\n\nVous verrez peut-√™tre des personnes qui utilisent T ou F mais c‚Äôest d√©conseill√© car T et F peuvent √©galement √™tre utilis√©s comme noms d‚Äôobjets ou de variables. En revanche, les valeurs TRUE et FALSE sont r√©serv√©es (prot√©g√©es), ce qui signifie qu‚Äôelles ne peuvent pas √™tre r√©affect√©s √† une autre valeur.\n\n\n\n\nD√©terminer le type d‚Äôun objet\nIl existe plusieurs fonctions permettant de d√©terminer le type d‚Äôun objet (souvent appel√© la classe de l‚Äôobjet en R [class].\n\nTapez les commandes suivantes dans votre script et ex√©cutez-les :\n\n# Obtenir le type\nclass(28)  \nclass(\"Mandoul\")\n\n# Test du type\nis.numeric(28)\nis.numeric(\"Mandoul\")\nis.character(\"Mandoul\")\n\nis.numeric(TRUE)\nis.character(TRUE)\nis.logical(FALSE)"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-assignement-operator",
    "href": "sessions_core/01_introduction.html#sec-assignement-operator",
    "title": "Introduction √† R",
    "section": "Enregistrer un objet",
    "text": "Enregistrer un objet\nEn R, presque tout est un objet y compris les fonctions, les vecteurs et les structures plus complexes. Souvent, nous souhaitons r√©utiliser certains objets tout au long d‚Äôun script (un jeu de donn√©es par exemple). Il est donc tr√®s utile de les stocker dans notre environnement (la m√©moire de R). Pour ce faire, nous utilisons l‚Äôop√©rateur d‚Äôassignation &lt;-.\n\nRegardez le panneau environnement en haut √† droite. Il devrait √™tre vide. Tapez la commande suivante dans votre script et ex√©cutez-la. Elle enregistre une variable appel√©e cas dans votre environnement.\n\ncas &lt;- 28\n\nInspectez √† nouveau l‚Äôenvironnement. Est-il toujours vide ?\n\nSi vous souhaitez acc√©der √† la valeur de votre nouvel objet, cas il vous suffit d‚Äôex√©cuter son nom.\n\ncas\n\n[1] 28\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous √©crivons les cha√Ænes de caract√®res entre guillements pour permettre √† R de faire la diff√©rence entre un objet cas et le texte \"cas\".\n\n\nUne fois cr√©√©s, les objets peuvent √™tre utilis√©s dans d‚Äôautres commandes :\n\ncas + 5\n\n[1] 33\n\n\n\nDans votre script, cr√©ez un objet appel√© region qui contient la valeur \"Mandoul\". Est-il bien apparu dans votre environnement ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN‚Äôoubliez pas que nous devons toujours entourer l‚Äôop√©rateur &lt;- par des espaces afin d‚Äôam√©liorer la lisibilit√© et d‚Äô√©viter les erreurs.\n\nx&lt;-3     # MAUVAIS\nx &lt;- 3   # BIEN\n\n\n\n\nMettre √† jour d‚Äôun objet\nNous souhaitons souvent mettre √† jour la valeur stock√©e dans un objet. Pour ce faire, il suffit d‚Äôassigner une nouvelle valeur avec la m√™me syntaxe que celle utilis√©e lors de la cr√©ation de l‚Äôobjet :\n\ncas &lt;- 32\n\n\nMettez √† jour l‚Äôobjet region avec la valeur \"Moyen Chari\".\n\n\n\nNoms d‚Äôobjets\nPour nommer vos objets, il existe quelques r√®gles (relativement) strictes :\n\nNe pas commencer par un chiffre\nNe pas utiliser d‚Äôespaces (utiliser un _ √† la place)\nNe pas utiliser de valeurs r√©serv√©es (comme TRUE et FALSE) ou des noms de fonctions (comme mean)\nNe pas utiliser de majuscules (c‚Äôest plus une convention qu‚Äôune r√®gle dure)\n\nAu-del√† de ces r√®gles, il existe √©galement des bonnes pratiques plus subjectives et des styles personnels. En r√®gle g√©n√©rale, les noms doivent √™tre courts et descriptifs :\n\na &lt;- 19                              # Pas informatif\nage_du_patient_a_l_admission &lt;- 19   # Trop long\nage &lt;- 19                            # Concis et pr√©cis\n\nDes noms clairs et informatifs contribuent √† rendre votre code plus lisible, ce qui permet aux autres de le comprendre facilement sans avoir √† constamment consulter le dictionnaire de donn√©es."
  },
  {
    "objectID": "sessions_core/01_introduction.html#structures-de-donn√©es",
    "href": "sessions_core/01_introduction.html#structures-de-donn√©es",
    "title": "Introduction √† R",
    "section": "Structures de donn√©es",
    "text": "Structures de donn√©es\nJusqu‚Äô√† maintenant, nous avons cr√©√© des objets simples qui contenaient une seule valeur. A pr√©sent nous allons nous int√©resser √† des structures plus complexes qui peuvent contenir des jeux de donn√©es.\n\nVecteurs\nIl est possible de rassembler plusieurs valeurs (telles que des valeurs num√©riques ou des cha√Ænes de caract√®res) en un seul objet, appel√© vecteur.\nTechniquement, il existe plusieurs types de vecteurs, dont :\n\nles vecteurs simples (ou vecteurs atomiques) ne peuvent contenir qu‚Äôun seul type de valeurs. Par exemple, un vecteur d‚Äôentiers contenant 2, 4, 6 ou un vecteur de texte contenant \"Mandoul\", \"Moyen Chari\".\nles vecteurs r√©cursifs (g√©n√©ralement appel√©s listes) sont plus complexes et peuvent contenir plusieurs dimensions et types de donn√©es. Nous ne les aborderons pas dans cette le√ßon.\n\nCette le√ßon n‚Äôentrera pas dans les d√©tails abstraits de ces structures et se concentrera sur celles que vous rencontrerez le plus souvent dans votre travail.\n\nVecteurs simples\nLes vecteurs simples peuvent contenir une ou plusieurs valeurs d‚Äôun seul type de donn√©es. Ils ont donc deux propri√©t√©s essentielles : une longueur et un type. Dans le cadre de ce cours, nous utiliserons indiff√©remment les termes ‚Äúvecteur simple‚Äù et ‚Äúvecteur‚Äù, comme c‚Äôest g√©n√©ralement le cas dans la communaut√© R.\nTechniquement, vous avez d√©j√† cr√©√© vos premiers vecteurs simples lorsque vous avez construit les objets cas et region. Il s‚Äôagissait de vecteurs avec une longueur de taille une. Pour cr√©er un vecteur avec plus d‚Äôune valeur, nous utiliserons la fonction c() (moyen mn√©motechnique) :\n\ncas &lt;- c(2, 5, 8, 0, 4)\n\n\nMettez √† jour cas avec les valeurs ci-dessus et mettez √† jour region pour cr√©er un vecteur de cha√Ænes de caract√®res contenant les valeurs suivantes : Mandoul, Moyen-Chari, Logone Oriental, Tibesti et Logone Occidental.\n\nNous pouvons maintenant utiliser des fonctions sur les objets que nous avons cr√©√©s :\n\nmean(cas)  # Calcule la moyenne des valeurs stock√©es dans le vecteur\n\n[1] 3.8\n\ntoupper(region)  # Convertit les valeurs du vecteur en majuscules\n\n[1] \"MANDOUL\"           \"MOYEN-CHARI\"       \"LOGONE ORIENTAL\"  \n[4] \"TIBESTI\"           \"LOGONE OCCIDENTAL\"\n\n\n\nEcrivez des commandes dans votre script pour effectuer les actions suivantes :\n\ncalculer la somme des valeurs de cas avec la fonction sum()\nconvertir le texte de region en minuscules √† l‚Äôaide de la fonction tolower()\n\n\n\n\n\nAcc√®s aux valeurs d‚Äôun vecteur\nIl est possible d‚Äôacc√©der √† une valeur d‚Äôun vecteur en donnant son indice (i.e. sa position dans le vecteur) entre crochets :\n\ncas[2]   # Deuxi√®me valeur de cas\n\n[1] 5\n\ncas[10]  # Dixi√®me valeur de cas\n\n[1] NA\n\n\nOups il n‚Äôy a pas de dixi√®me valeur dans cas ! Nous reviendrons sur ce que ce NA signifie dans la section valeurs manquantes.\nNous pouvons √©galement acc√©der √† une plage de valeurs, comme nous pourrions le faire dans Excel. Nous utilisons l‚Äôop√©rateur : entre la position minimum et maximum de la plage :\n\ncas[2:4]  # de la deuxi√®me √† la quatri√®me valeur\n\n[1] 5 8 0\n\n\n\nAffichez la 3√®me valeur du vecteur region.\nAcc√©dez aux valeurs ‚ÄúMandoul‚Äù et ‚ÄúMoyen-Chari‚Äù du vecteur region.\n\n\n\nData frames\nLes data frames sont des structures tabulaires / tableaux en 2D avec des lignes et des colonnes. Il s‚Äôagit d‚Äôune structure tr√®s similaire √† celle d‚Äôun ‚Äútableau‚Äù dans Excel. En tant qu‚Äô√©pid√©miologistes, ce type d‚Äôobjet est l‚Äôun des plus utiles et vous l‚Äôutiliserez quotidiennement pour stocker des jeux de donn√©es (des listes lin√©aires par exemple).\n\nCr√©ation d‚Äôun data frame\nNous cr√©ons un data frame avec la fonction data.frame() :\n\ndata.frame(col1 = c(1, 4, 2, 9),\n           col2 = c(\"un peu de texte\", \"plus de text\", \"Salut !\", \"les epidemiologistes !\"))\n\n  col1                   col2\n1    1        un peu de texte\n2    4           plus de text\n3    2                Salut !\n4    9 les epidemiologistes !\n\n\nIci, on a cr√©e col1 √† partir d‚Äôun vecteur num√©rique, et col2 √† partir d‚Äôun vecteur de cha√Ænes de caract√®res. Nous avons choisi les noms des colonnes (col1 et col2), ce qui est normal, mais vous pouvez ex√©cuter le code sans nommer les colonnes pour voir comment R cr√©e lui m√™me des noms.\n\nDans votre script, cr√©ez un data frame nom√© data_cas qui contient cas dans une colonne et region dans l‚Äôautre.\n\n\n\nExploration d‚Äôun data frame\nL‚Äôobjet data_cas devrait maintenant appara√Ætre dans votre environnement. Vous pouvez cliquer sur le cercle bleu avec un triangle blanc pour d√©rouler des informations suppl√©mentaires, ou cliquer sur son nom pour le visualiser dans un onglet dans le m√™me volet que votre script.\n\n\n\nLe data frame data_cas appara√Æt d√©sormais dans l‚Äôonglet Environnement.\n\n\nIl existe plusieurs fonctions pratiques pour explorer un data frame :\n\nEx√©cutez les commandes suivantes et essayez de d√©terminer le type d‚Äôinformations qu‚Äôelles renvoient.\n\nstr(data_cas)     # STRucture de l'object\ndim(data_cas)     # DIMension de l'object\nnrow(data_cas)    # Nombre de lignes (row = ligne)\nncol(data_cas)    # Nombre de COLonnes\nnames(data_cas)   # noms des colonnes\n\n\nPratiquons un peu plus ! R est livr√© avec quelques data frames int√©gr√©s auxquels il est possible d‚Äôacc√©der directement, dont un appel√© iris. C‚Äôest pratique pour cette session car nous n‚Äôavons pas encore appris √† importer des donn√©es dans R (ne vous inqui√©tez pas, nous travaillerons sur des donn√©es de liste lin√©aire d√®s la prochaine session !).\nNous pouvons afficher les premi√®res lignes de ce data frame gr√¢ce √† la fonction head() [head = la t√™te en anglais] :\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\nCombien de lignes et de colonnes y a-t-il dans iris? Quels sont les noms des colonnes de ce data frame ?\n\n\n\nAcc√©der aux donn√©es d‚Äôun data frame\nEn R, il existe plusieurs m√©thodes pour acc√©der aux lignes et/ou colonnes d‚Äôun data frame. Dans cette session d‚Äôintroduction, nous nous concentrerons sur la syntaxe [row, column].\nNous pouvons utiliser un num√©ro (ou un intervalle) de ligne pour extraire des lignes, et des num√©ros (ou un intervalle) de colonnes pour extraire les colonnes. Ont peut √©galement utiliser le nom des colonnes pour y acc√©der.\n\ndata_cas[1, 2]    # Afficher la valeur de la ligne 1, deuxi√®me colonne\n\n[1] \"Mandoul\"\n\ndata_cas[1, \"region\"]   # Afficher la valeur de la lignbe 1, pour la colonne r√©gion\n\n[1] \"Mandoul\"\n\n\nSi nous voulons isoler toutes les lignes (ou colonnes), nous pouvons simplement laisser un espace √† la place du num√©ro/nom :\n\ndata_cas[1, ]  # Extrait la premi√®re ligne (garde toutes les colonnes)\n\n  cas  region\n1   2 Mandoul\n\ndata_cas[2:4, ]   # Valeurs des lignes 2 √† 4, pour toutes les colonnes\n\n  cas         region\n2   5       Sud Kivu\n3   8 Kasai oriental\n4   0          Kasai\n\ndata_cas[ , \"region\"]   # Garde toutes les lignes mais que la colonne r√©gion\n\n[1] \"Mandoul\"        \"Sud Kivu\"       \"Kasai oriental\" \"Kasai\"         \n[5] \"Haut Katanga\"  \n\n\nNous pouvons m√™me s√©lectionner plusieurs indices non cons√©cutifs en utilisant un vecteur :\n\ndata_cas[c(1, 3), ]  # Ligne 1 et 3 (toutes les colonnes)\n\n  cas         region\n1   2        Mandoul\n3   8 Kasai oriental\n\n\nSoyez attentifs, le type de l‚Äôobjet renvoy√© par [ ] d√©pend de l‚Äôindexation utilis√©e :\n\nstr(data_cas[1 , ])   # Renvoit un data frame\n\n'data.frame':   1 obs. of  2 variables:\n $ cas   : num 2\n $ region: chr \"Mandoul\"\n\nstr(data_cas[ , 1])   # Renvoit un vecteur\n\n num [1:5] 2 5 8 0 4\n\n\nUne syntaxe simplifi√©e existe pour extraire des colonnes d‚Äôun data frame :\n\ndata_cas[2]           # Renvoit la deuxi√®me colonne (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\ndata_cas[\"region\"]    # Renvoit la colonne r√©gion (format data frame)\n\n          region\n1        Mandoul\n2       Sud Kivu\n3 Kasai oriental\n4          Kasai\n5   Haut Katanga\n\n\n\nEcrivez le code pour :\n\nextraire la troisi√®me valeur de la colonne region de votre data frame\nextraire les deuxi√®me et troisi√®me valeurs de la colonne cas\ncalculer la somme des valeurs de la colonne cas"
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-missing-values",
    "href": "sessions_core/01_introduction.html#sec-missing-values",
    "title": "Introduction √† R",
    "section": "Valeurs manquantes",
    "text": "Valeurs manquantes\nEn tant qu‚Äô√©pid√©miologistes, nous sommes constamment confront√©s aux donn√©es manquantes. Dans R, celles-ci sont cod√©es √† l‚Äôaide d‚Äôune valeur sp√©ciale : NA [signifiant Not Available]. La valeur NA n‚Äôa pas de type fixe, elle prend celui des valeurs qui l‚Äôentourent. Par exemple, un NA dans une colonne num√©rique est trait√©e comme une valeur num√©rique. Nous aurons des occasions de manipuler les NA dans la suite du cours."
  },
  {
    "objectID": "sessions_core/01_introduction.html#sec-functions",
    "href": "sessions_core/01_introduction.html#sec-functions",
    "title": "Introduction √† R",
    "section": "Fonctions",
    "text": "Fonctions\nLes fonctions sont des objets qui contiennent des commandes (au lieu de valeurs) qui sont ex√©cut√©es chaque fois que la fonction est lanc√©e. Vous √™tes sans doute familiers avec les fonctions dans Excel, telles que la fonction SOMME() ou la fonction MOYENNE(). Bonne nouvelle, les fonctions sont similaires dans R !\nLa majorit√© des fonctions que vous allez utiliser ont besoin d‚Äôinformations compl√©mentaires : a minima des donn√©es, mais aussi d‚Äôautres param√®tres. On appelle ces informations des arguments. Les arguments sont normalement nomm√©s.\nPar exemple, lorsque nous avons ex√©cut√© la commande sum(cas), nous avons fourni le vecteur cas comme premier (et seul) argument de la fonction sum().\nParmis les arguments d‚Äôune fonction, certains peuvent √™tre obligatoires, d‚Äôautres facultatifs. Le premier argument est presque toujours obligatoire et est souvent un data frame ou un vecteur de donn√©es. Comme c‚Äôest un argument √©vident, on omet souvent son nom (il vous a sans doute sembl√© naturel de taper mean(cas) au lieu de mean(x = cas)).\nLes arguments facultatifs, en revanche, sont g√©n√©ralement utilis√©s avec neur nom. Par exemple : mean(cas, na.rm = TRUE). Les arguments facultatifs sont souvent fournis avec des valeurs par d√©faut raisonnables, ce qui fait que l‚Äôutilisateur ne les sp√©cifie que lorsqu‚Äôil a besoin de changer ces valeurs par d√©faut. Par exemple, l‚Äôargument na.rm de la fonction mean() controle comment les valeurs manquantes sont g√©r√©es lors du calcul de la moyenne [‚Äúna‚Äù en r√©f√©rence aux valeurs manquantes NA, et ‚Äúrm‚Äù comme raccourci de ‚ÄúReMove‚Äù, que l‚Äôon peut traduire dans ce contexte par enlever ou ignorer]. Par d√©fault, la valeur de na.rm est FALSE Ainsi, par d√©faut, la moyenne de donn√©es avec des valeurs manquantes renverra toujours NA :\n\nmean(c(1, 3, NA))\n\n[1] NA\n\n\nCeci est vrai pour de nombreuses op√©rations arithm√©tiques dans R. Si l‚Äôon veut que que R calcule la moyenne sur toutes les donn√©es disponibles et ignore les valeurs manquantes, nous devons explicitement fournir l‚Äôargument na.rm = TRUE:\n\nmean(c(1, 3, NA), na.rm = TRUE)\n\n[1] 2\n\n\n\n\n\n\n\n\nAstuce\n\n\n\n\nLes arguments sont s√©par√©s par des virgules.\nCes virgules doivent toujours √™tre suivies d‚Äôun espace\nChaque fois qu‚Äôun argument nomm√© est utilis√©, l‚Äôattribut = doit √™tre entour√© d‚Äôespaces :\n\n\nmean(cas,na.rm=TRUE)     # MAUVAIS\nmean(cas, na.rm = TRUE)  # BON\n\nSi vous √©crivez une commande avec de nombreux arguments, s√©parez chaque argument sur sa propre ligne pour am√©liorer la lisibilit√© :\n\nmean(cas, \n     na.rm = TRUE) \n\n\n\nQue se passe-t-il si l‚Äôon fournit plusieurs arguments dans le d√©sordre ? Si vous avez nomm√© les arguments la fonction s‚Äôex√©cutera correctement, mais le code sera contre-intuitif et peu lisible. Nous vous conseillons de respecter l‚Äôordre standard, en pla√ßant les arguments obligatoires tels que les donn√©es en premier.\n\n# Fonctionnel mais dur √† lire\nmean(na.rm = TRUE,  \n     x = cas) \n\n# mieux\nmean(cas,         \n     na.rm = TRUE)\n\nEn revanche, si vous ne nommez pas les arguments et les passez dans le d√©sordre, alors la fonction ne fonctionnera pas comme pr√©vu, voire renverra une erreur :\n\nmean(TRUE, cas)  # Pas ce que vous attendez"
  },
  {
    "objectID": "sessions_core/01_introduction.html#termin√©",
    "href": "sessions_core/01_introduction.html#termin√©",
    "title": "Introduction √† R",
    "section": "Termin√© !",
    "text": "Termin√© !\nC‚Äôest tout pour cette session, bravo pour vos d√©buts avec R et RStudio !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html",
    "href": "sessions_core/03_data_verbs.html",
    "title": "Traitement de donn√©es, les bases",
    "section": "",
    "text": "D√©couvrir les fonctions de {dplyr} pour effectuer les actions essentielles sur les donn√©es :\n\nS√©lectionner des colonnes avec select()\nRenommer des colonnes avec rename()\nCr√©er de nouvelles colonnes ou modifier des colonnes existantes avec mutate()\nSupprimer les doublons avec distinct()\n\nEncha√Æner ces actions avec l‚Äôop√©rateur ‚Äúpipe‚Äù |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#objectifs",
    "href": "sessions_core/03_data_verbs.html#objectifs",
    "title": "Traitement de donn√©es, les bases",
    "section": "",
    "text": "D√©couvrir les fonctions de {dplyr} pour effectuer les actions essentielles sur les donn√©es :\n\nS√©lectionner des colonnes avec select()\nRenommer des colonnes avec rename()\nCr√©er de nouvelles colonnes ou modifier des colonnes existantes avec mutate()\nSupprimer les doublons avec distinct()\n\nEncha√Æner ces actions avec l‚Äôop√©rateur ‚Äúpipe‚Äù |&gt;"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#mise-en-place",
    "href": "sessions_core/03_data_verbs.html#mise-en-place",
    "title": "Traitement de donn√©es, les bases",
    "section": "Mise en place",
    "text": "Mise en place\nPr√©requis : cette le√ßon part du principe que vous savez comment utiliser RStudio et que vous √™tes capable d‚Äôimporter des donn√©es. Rafra√Æchissez-vous si besoin avec les deux premi√®res le√ßons.\n\nNous utiliserons la linelist avec des donn√©es brutes que vous avez import√©e lors de la le√ßon pr√©c√©dente, et qui peut √™tre t√©l√©charg√©e ici :\n\n\n\n T√©l√©charger les donn√©es\n\n\n\n Si ce n‚Äôest pas d√©j√† fait, enregistrez le jeu de donn√©es dans le sous-dossier appropri√© de votre projet RStudio puis cr√©ez un nouveau script appel√© fonctions_donnees.R dans votre sous-dossier R. Ajoutez un en-t√™te appropri√© et chargez les paquets suivants : {here}, {rio} et {tidyverse}.  Enfin, ajoutez une section d√©di√©e √† l‚Äôimport des donn√©es, utilisez {here} et {rio} pour importer vos donn√©es dans R, et assignez-les √† un objet que nous appellerons df_brut."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#traiter-ses-donn√©es-avec-dplyr",
    "href": "sessions_core/03_data_verbs.html#traiter-ses-donn√©es-avec-dplyr",
    "title": "Traitement de donn√©es, les bases",
    "section": "Traiter ses donn√©es avec {dplyr}",
    "text": "Traiter ses donn√©es avec {dplyr}\nLa mise en place est termin√©e et nous pouvons maintenant nous focaliser sur nos donn√©es ! Cette le√ßon et les suivantes s‚Äôappuieront lourdement sur plusieurs paquets de la collection de paquets tidyverse pour manipuler des data frames, r√©sumer et visualiser les donn√©es, et en particulier paquet {dplyr} pour aujourd‚Äôhui.\nLe traitement des donn√©es (aussi appel√© manipulation des donn√©es) est un ensemble d‚Äôactions essentielles pour pr√©parer et nettoyer les donn√©es avant une analyse (que ce soit dans R ou Excel). {dplyr} fournit un grand nombre de fonctions qui nous aident √† manipuler les data frames et √† r√©aliser de nombreuses t√¢ches quotidiennes telles que :\n\ncr√©er des sous-ensembles de nos donn√©es en ne gardant que les variables d‚Äôint√©r√™t\nrenommer des colonnes\najouter ou modifier des colonnes\nsupprimer les doublons\n\nCes fonctions ont en g√©n√©ral un nom intuitif, qui correspond √† un verbe. Par exemple, pour renommer des colonnes, on utilisera la fonction rename().\nAujourd‚Äôhui nous nous focaliserons sur les quatre verbes (fonctions !) qui permettent d‚Äôeffectuer les t√¢ches mentionn√©es pr√©c√©demment, et que vous utiliserez en permanence. Nous vous montrerons √©galement comment encha√Æner les actions dans un ‚Äúpipeline‚Äù pour plus de fluidit√©.\n\n\n\n\n\n\nNote\n\n\n\nPeut-√™tre avez-vous not√© que nous vous parlons du paquet {dplyr} mais nous vous avons fait charger le paquet {tidyverse} lors de la mise en place. C‚Äôest que le {tidyverse} est un m√©ta-paquet, et le charger charge automatiquement plusieurs des paquets les plus utiles de l‚Äôunivers du tidyverse, dont fait partie {dplyr} et d‚Äôautres paquets que nous verrons dans la session."
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#actions-de-base-sur-les-donn√©es",
    "href": "sessions_core/03_data_verbs.html#actions-de-base-sur-les-donn√©es",
    "title": "Traitement de donn√©es, les bases",
    "section": "Actions de base sur les donn√©es",
    "text": "Actions de base sur les donn√©es\n\nS√©lectionner des colonnes\nIl est fr√©quent de souhaiter √©carter des variables d‚Äôun jeu de donn√©es, soit car ces colonnes contiennent des donn√©es sensibles, soit parce que nous n‚Äôavons pas besoin d‚Äôelles pour une analyse donn√©e. Nous utiliserons pour cela la fonction select(), qui la syntaxe suivante :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\nselect(un_dataframe, colonne_a_garder, autre_colonne_a_garder)\n\nIci, le premier argument est le data frame contenant les donn√©es. Les arguments suivants sont les noms des colonnes que nous voulons conserver. Dans le tidyverse, les noms de colonnes n‚Äôont pas besoin d‚Äô√™tre √©crits entre guillemets.\nLa commande suivante nous permet de s√©lectionner les colonnes id, sex et age, par exemple :\n\nselect(df_brut, id, sexe, age)\n\n\nUtilisez la fonction select() pour s√©lectionner les variables suivantes de votre data frame : id, sexe, age, sous_prefecture, date_debut et issue. L‚Äôen-t√™te du data frame renvoy√© par la fonction ressemble √† ceci :\n\n\n  id  sexe age date_debut issue\n1  1 femme  36 2022-08-13 gueri\n2  2     f   5 2022-08-18  &lt;NA&gt;\n3  3     f 156 2022-08-17 gueri\n4  6 homme   8 2022-08-22 gueri\n5  7     h   7 2022-08-30 gueri\n6 10     h   4 2022-08-30 gueri\n\n\n Comparez ce r√©sultat √† df_brut. Ce dernier contient toujours toutes les colonnes import√©es (ce qui est le comportement d√©sir√©). Comprenez-vous pourquoi c‚Äôest le cas ?\n\nIl arrive que nous ne voulions supprimer que quelques colonnes d‚Äôun jeu de donn√©es et si le jeu de donn√©es est large √ßa serait fastidieux d‚Äô√©crire toutes les colonnes √† garder comme nous l‚Äôavons fait ci-dessus‚Ä¶ Heureusement, nous pouvons pr√©facer un nom de colonne par l‚Äôop√©rateur soustraction (-) pour indiquer √† R de la supprimer.\nPar exemple, pour cr√©er un data frame sans la colonne village_commune :\n\nselect(df_brut, -village_commune)\n\n\nUtilisez cette syntaxe pour cr√©er un data frame qui conserve toutes les colonnes de df_brut √† l‚Äôexception de nom_complet et unite_age.\n\n\n\nRenommer les colonnes\nIl arrive souvent que nous souhaitions renommer des colonnes d‚Äôun jeu de donn√©es. La fonction rename() est alors votre meilleure amie.\n\n# NE PAS EX√âCUTER (PSEUDO CODE)\nrename(un_dataframe,\n       nouveau_nom_1 = nom_tout_moche,\n       nouveau_nom_2 = autre_nom_pas_fou)\n\nComme pour select(), le premier argument est le data frame qui contient les donn√©es (ce sera le cas pour la majorit√© des verbes de {dplyr}). Ensuite, chaque nouvel argument est une paire nouveau_nom = ancien_nom indiquant √† R les colonnes √† renommer et leurs nouveaux noms. Nous vous conseillons d‚Äôaller √† la ligne pour chaque nouvelle paire pour aider √† la lisibilit√©.\nRenommons la colonne village_commune en village par exemple :\n\nrename(df_brut,\n       village = village_commune)\n\n\nUtilisez la fonction rename() sur df_brut pour renommer les colonnes :\n\nsous_prefecture en prefecture\nvillage_commune en village\nnom_structure_sante en structure\n\n\nIl peut √™tre difficile de v√©rifier si une commande fonctionne car R affiche le data frame en entier. Dans ce cas, une premi√®re solution consiste √† cr√©er un objet temporaire plus facile √† manipuler. Vous pouvez le nommer comme vous voulez, mais un nom commun est temp (ou tmp en anglais).\n\nR√©p√©tez le dernier exercice en assignant la sortie de la commande √† un objet appel√© temp. Vous pouvez alors utiliser la fonction names() pour v√©rifier que les noms des colonnes ont bien chang√©. La sortie de names() devrait √™tre :\n\n\n [1] \"id\"                \"nom_complet\"       \"sexe\"             \n [4] \"age\"               \"unite_age\"         \"region\"           \n [7] \"prefecture\"        \"village\"           \"date_debut\"       \n[10] \"date_consultation\" \"hospitalisation\"   \"date_admission\"   \n[13] \"structure\"         \"tdr_paludisme\"     \"fievre\"           \n[16] \"eruption\"          \"toux\"              \"yeux_rouges\"      \n[19] \"pneumonie\"         \"encephalite\"       \"pb\"               \n[22] \"statut_vaccinal\"   \"doses_vaccin\"      \"issue\"            \n[25] \"date_issue\"       \n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLes objets comme le data frame temp sont g√©n√©ralement utilis√©s pour tester si quelque chose a fonctionn√© et peuvent donc √™tre √©cras√©s lorsque vous testez autre chose. Ils ne doivent pas √™tre utilis√©s comme entr√©e pour d‚Äôautres parties de votre code. Utilisez des noms clairs et appropri√©s pour vos data frames destin√©s √† √™tre r√©utilis√©s, tels que df_linelist ou df_propre.\n\n\n\n\nModifier et ajouter des colonnes\nUne autre t√¢che essentielle du traitement de donn√©es est de modifier des colonnes ou d‚Äôen cr√©er de nouvelles. La fonction mutate() permet de faire les deux [to mutate veut dire muter en anglais], avec la syntaxe suivante :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\nmutate(un_dataframe,\n       nouvelle_colonne_1 = action(colonne_existante),\n       nouvelle_colonne_2 = autre_action(une_autre_colonne_existante))\n\nDans le code ci-dessus nous cr√©ons une nouvelle colonne (nouvelle_colonne_1) en effectuant une action (des calculs par exemple) sur une colonne existante (colonne_existante) dans le data frame un_dataframe. Puis nous cr√©ons une autre colonne (nouvelle_colonne_2) sur le m√™me principe. L‚Äôaction en question peut √™tre vari√©e et plus ou moins complexe : calcul arithm√©tique, application d‚Äôune fonction sur une colonne (ou m√™me plusieurs !) etc.\nPar exemple, nous pourrions cr√©er une nouvelle colonne exprimant le p√©rim√®tre brachial en cm :\n\nmutate(df_brut,\n       pb_cm = pb / 100) # une op√©ration arithm√©tique simple\n\n\nUtilisez mutate() pour cr√©er une nouvelle colonne age_ans qui exprime l‚Äô√¢ge en ann√©es plut√¥t qu‚Äôen mois. L‚Äôen-t√™te de la colonne ressemble √† ceci :\n\n\n   age_years\n1  3.0000000\n2  0.4166667\n3 13.0000000\n4  0.6666667\n5  0.5833333\n6  0.3333333\n\n\n\nPour modifier une colonne existante il suffit d‚Äôutiliser le nom de la colonne existante √† gauche du = au lieu de fournir un nouveau nom.\nPar exemple, si nous voulions remplacer la colonne pb qui contenait des valeurs en mm par une colonne pb contenant les valeurs en cm :\n\nmutate(df_brut,\n       pb = pb / 100)\n\nNous voulons souvent conserver la colonne originelle, mais il existe des cas raisonnables o√π nous souhaitons √©craser les donn√©es par une nouvelle version. Par exemple :\n\nmodifier des cha√Ænes de caract√®res (format, correction de typos etc.)\ncorriger le type de donn√©es d‚Äôune colonne\n\nNotre jeu de donn√©es pr√©sente ces deux cas. Par exemple les colonnes region et sous_prefecture sont en majuscules, ce qui n‚Äôest pas un probl√®me en soi, mais peut √™tre am√©liorable. Pour corriger cela nous pouvons utiliser la fonction str_to_title() du paquet {stringr} (qui fait √©galement partie du {tidyverse}) pour passer les valeurs en casse ‚Äútitre‚Äù.\n\nmutate(df_brut,\n       region = str_to_title(region),\n       sous_prefecture = str_to_title(sous_prefecture))\n\n\nUtilisez la fonction mutate() pour mettre √† jour le format de tdr_paludisme et issue afin d‚Äôutiliser la casse ‚Äútitres‚Äù. L‚Äôen-t√™te de la sortie pour ces deux colonnes devrait maintenant √™tre :\n\n\n  tdr_paludisme issue\n1       Negatif Gueri\n2       Negatif  &lt;NA&gt;\n3       Negatif Gueri\n4       Negatif Gueri\n5       Negatif Gueri\n6       Negatif Gueri\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNous n‚Äôavons pas eu besoin de charger {stringr} car comme {dplyr}, ce paquet est charg√© automatiquement lorsque nous chargeons{tidyverse}.\n\n\nPassons maintenant au probl√®me des variables avec le mauvais type.\n\nV√©rifiez le type de vos colonnes. Y a-t-il des probl√®mes ?  Indice : str() peut √™tre utile ici.\n\nLes classes semblent raisonnables sauf pour les dates : certaines colonnes ont la classe caract√®re et d‚Äôautres sont POSIXct. Nous pr√©f√©rerions que toutes ces colonnes utilisent le type Date.\nNous allons utiliser la fonction ymd() du paquet {lubridate} pour faire la conversion en Date. ‚Äúymd‚Äù est l‚Äôabr√©viation de year month day, c‚Äôest √† dire ann√©e-mois-jour. Cela veut dire que la fonction attend une date fournie dans cet ordre-l√† (les s√©parateurs peuvent varier).\nPour corriger la date de d√©charge :\n\nmutate(df_brut,\n       date_issue = ymd(date_issue))\n\n\nUtilisez mutate() et ymd() pour modifier les colonnes date_debut et date_admission afin qu‚Äôelles soient de type Date.\nAstuce : n‚Äôh√©sitez pas √† stocker la sortie de la fonction dans un data frame temporaire temp pour v√©rifier le type des variables modifi√©es.\n\n\n\nSupprimer les doublons\nNous connaissons d√©sormais les fonctions pour s√©lectionner, renommer et modifier nos variables. Il est temps √† pr√©sent de passer √† une autre t√¢che essentielle du nettoyage : la suppression doublons.\nLa fonction distinct() permet de rapidement enlever les lignes identiques d‚Äôun data frame avec la syntaxe suivante :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndistinct(un_dataframe)\n\nPar d√©faut, nous n‚Äôavons besoin que d‚Äôun seul argument : le jeu de donn√©es lui-m√™me. Cela supprime alors toutes les lignes qui sont compl√®tement en double en ne gardant qu‚Äôune seule copie. Il existe des usages plus sophistiqu√©s de distinct() pour chercher des doublons partiels, mais leur correction d√©passerait du cadre de cette session‚Ä¶\n\nUtilisez la fonction distinct() et cr√©ez un data frame temporaire, temp qui contient toutes les observations uniques dans df_brut. Comparez le nombre de lignes de temp √† celui de df_brut. Avions-nous des doublons ?"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#lop√©rateur-pipe",
    "href": "sessions_core/03_data_verbs.html#lop√©rateur-pipe",
    "title": "Traitement de donn√©es, les bases",
    "section": "L‚Äôop√©rateur ‚Äúpipe‚Äù",
    "text": "L‚Äôop√©rateur ‚Äúpipe‚Äù\nNous avons profit√© de la pr√©sentation des fonctions essentielles de {dplyr} pour commencer le nettoyage du jeu de donn√©es. Il est temps de rassembler les commandes √©crites dans les exercices en un ensemble coh√©rent pour cr√©er un data frame contenant les donn√©es netoy√©es (au moins en partie) que nous appelerons df_linelist.\n\n\n\n\n\n\nAstuce\n\n\n\nEn g√©n√©ral, il est recommand√© de conserver une version brute de votre ensemble de donn√©es, ici df_brut, qui reste inchang√©e dans votre code. Ainsi, vous l‚Äôavez toujours √† disposition dans votre environnement comme r√©f√©rence et elle est toujours disponible au d√©but de votre pipeline de nettoyage pour am√©liorer la reproductibilit√©.\n\n\nIl y a plusieurs mani√®res d‚Äôencha√Æner les diff√©rentes √©tapes que nous avons vues. Intuitivement, nous pourrions commencer comme ceci :\n\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sous_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\nPuis mettre √† jour df_linelist :\n\n# √âtape 1 : Renommer les variables\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sub_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\n# √âtape 2 : S√©lectionner les variables √† conserver\ndf_linelist &lt;- select(df_linelist,\n                      -nom_complet)\n\nNotez que dans cette deuxi√®me √©tape, nous utilisons df_linelist comme entr√©e de select() plut√¥t que df_brut car nous voulons continuer √† travailler sur la version modifi√©e des donn√©es.\nPuis nous ajoutons l‚Äô√¢ge en ann√©es :\n\n# √âtape 1 : Renommer les variables\ndf_linelist &lt;- rename(df_brut, \n                      prefecture = sub_prefecture,\n                      village    = village_commune,\n                      structure  = nom_structure_sante)\n\n# √âtape 2 : S√©lectionner les variables √† conserver\ndf_linelist &lt;- select(df_linelist,\n                      -nom_complet)\n\n# √âtape 3 : Ajouter l'√¢ge en ann√©es\ndf &lt;- mutate(df_linelist,\n             age_ans = age / 12)\n\nEt caetera. Ce code est tout √† fait fonctionnel, mais devient lourd et r√©p√©titif si de nombreuses √©tapes s‚Äôencha√Ænent : √† chaque √©tape nous utilisons en entr√©e le data frame renvoy√© par l‚Äô√©tape pr√©c√©dente pour le mettre √† jour‚Ä¶\nIl existe un raccourcis ! L‚Äôop√©rateur pipe (|&gt;) permet d‚Äôenchainer des actions de mani√®re plus fluide avec cette syntaxe :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\nune_entree |&gt; une_action\n\n# En particulier :\nun_dataframe |&gt; une_fonction()\n\nIci, le pipe prend l‚Äôentr√©e fournie √† gauche et la transmet √† la fonction √† droite. Ainsi, par exemple, au lieu d‚Äô√©crire\n\nselect(df_brut, id, sexe)\n\nnous pouvons √©crire\n\ndf_brut |&gt; select(id, sexe)\n\n\nTestez le code ci-dessus de votre c√¥t√©.\n\nOn peut se servir de l‚Äôop√©rateur pipe pour encha√Æner plusieurs actions. C‚Äôest le style de code dit ‚Äúdu tidyverse‚Äù, qui ressemble √† ceci :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf_linelist &lt;- df_brut |&gt;\n  action_1() |&gt;\n  action_2() |&gt;\n  action_3() |&gt;\n  ...\n\n\n\n\n\n\n\nAstuce\n\n\n\nAller √† la ligne entre chaque action est consid√©r√© comme une bonne pratique pour rendre le code plus facile √† lire et √† comprendre.\n\n\nNous pourrions donc remplacer le code pr√©c√©dent par ceci :\n\ndf_linelist &lt;- df_brut |&gt;\n  rename(prefecture = sub_prefecture,\n         village    = village_commune,\n         facility   = health_facility_name) |&gt;\n  select(-full_name) |&gt;\n  mutate(age_years = age / 12)\n\nC‚Äôest beaucoup plus fluide que de r√©affecter df_linelist apr√®s chaque √©tape !\n\nA votre tour ! Rassemblez maintenant toutes les √©tapes de nettoyage de la le√ßon en une seule commande en un seul pipeline.\nUtilisez l‚Äôop√©rateur pipe |&gt;, les fonctions select() rename(), mutate(), str_to_title(), ymd() et distinct() pour cr√©er un data frame df_linelist partiellement nettoy√©.  Rappel des √©tapes :\n\nSupprimer les variables nom_complet et unite_age\nRenommer les variables suivantes :\n\nage devient age_ans\nsous_prefecture devient prefecture\nvillage_commune devient village\nnom_structure_sante devient structure\n\nAjouter une variable age_ans avec l‚Äô√¢ge du patient en ann√©es\nMettre √† jour region et prefecture pour utiliser la casse de titre\nMettre √† jour toutes les colonnes contenant des dates pour utiliser le type Date\nSupprimer toutes les lignes en double\n\nL‚Äôen-t√™te de vos donn√©es finales devrait ressembler √† ceci :\n\n\n  id  sexe age_mois  region prefecture        village date_debut\n1  1 femme       36 Mandoul   Moissala Sangana Ko√Øtan 2022-08-13\n2  2     f        5 Mandoul   Moissala      Mousdan 1 2022-08-18\n3  3     f      156 Mandoul   Moissala     Djaroua Ii 2022-08-17\n4  6 homme        8 Mandoul   Moissala     Monakoumba 2022-08-22\n5  7     h        7 Mandoul   Moissala      T√©tindaya 2022-08-30\n6 10     h        4 Mandoul   Moissala      Danamadja 2022-08-30\n  date_consultation hospitalisation date_admission\n1        2022-08-14             oui     2022-08-14\n2        2022-08-25             oui     2022-08-25\n3        2022-08-20            &lt;NA&gt;           &lt;NA&gt;\n4        2022-08-25             non           &lt;NA&gt;\n5        2022-09-02             non           &lt;NA&gt;\n6        2022-09-02             oui     2022-09-02\n                        structure tdr_paludisme fievre eruption toux\n1 H√¥pital du District de Moissala       negatif     No     &lt;NA&gt;  Yes\n2 H√¥pital du District de Moissala       negatif     No       No  Yes\n3                      CS Silambi       negatif    Yes     &lt;NA&gt;   No\n4 H√¥pital du District de Moissala       negatif     No       No   No\n5                      CS Silambi       negatif   &lt;NA&gt;       No  Yes\n6                    Moissala Est       negatif    Yes       No   No\n  yeux_rouges pneumonie encephalite  pb statut_vaccinal doses_vaccin issue\n1          No        No          No 244            &lt;NA&gt;         &lt;NA&gt; gueri\n2          No      &lt;NA&gt;          No 232             Non         &lt;NA&gt;  &lt;NA&gt;\n3          No        No        &lt;NA&gt; 123      Oui - oral         &lt;NA&gt; gueri\n4        &lt;NA&gt;        No          No 210             Non         &lt;NA&gt; gueri\n5         Yes        No          No  80             Non         &lt;NA&gt; gueri\n6        &lt;NA&gt;        No          No 220             Non         &lt;NA&gt; gueri\n  date_issue    age_ans\n1 2022-08-18  3.0000000\n2 2022-08-28  0.4166667\n3       &lt;NA&gt; 13.0000000\n4       &lt;NA&gt;  0.6666667\n5       &lt;NA&gt;  0.5833333\n6 2022-09-03  0.3333333\n\n\nAstuce :  soyez attentifs √† vos noms de colonne. Si vous rennomez une colonne, il faudra utiliser le nouveau nom dans les √©tapes suivantes du pipeline.\n\nFantastique ! C‚Äôest un excellent d√©but de pipeline de nettoyage de vos donn√©es. Sauvegardez ce code, car nous le compl√®terons lors de la prochaine session, durant laquelle nous apprendron une autre √©tape essentielle du traitement de donn√©es : recoder les variables !"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#cest-fini",
    "href": "sessions_core/03_data_verbs.html#cest-fini",
    "title": "Traitement de donn√©es, les bases",
    "section": "C‚Äôest fini !",
    "text": "C‚Äôest fini !\nBravo, vous avez appris les bases de la manipulation de donn√©es et comment encha√Æner plusieurs commandes dans un pipeline. √Ä partir de maintenant, les fichiers contenant les solutions des exercices fourniront le code final plut√¥t qu‚Äôune correction par exercice, afin d‚Äôavoir un script plus r√©aliste. Par exemple, la solution fournira le pipe final cr√©√© √† la fin de la session d‚Äôaujourd‚Äôhui.\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/03_data_verbs.html#aller-plus-loin",
    "href": "sessions_core/03_data_verbs.html#aller-plus-loin",
    "title": "Traitement de donn√©es, les bases",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExercices suppl√©mentaires\n\nAjoutez une ligne √† votre mutate() pour mettre √† jour la variable hospitalisation afin que son texte soit √©galement en casse ‚Äútitre‚Äù\nPeut-√™tre pr√©f√©reriez-vous utiliser des minuscules pour la colonne region plut√¥t que la casse ‚Äútitre‚Äù ? Mettez votre code √† jour pour le faire. Astuce : vous pouvez utiliser la fonction apprises dans la premi√®re session ou tester la fonction str_to_lower() de {stringr}.\nCr√©ez une colonne delai_consultation, qui contient le nombre de jours entre l‚Äôapparition des sympt√¥mes et la consultation."
  },
  {
    "objectID": "sessions_core/05_summary_table.html",
    "href": "sessions_core/05_summary_table.html",
    "title": "Tableaux r√©capitulatifs",
    "section": "",
    "text": "Cr√©er des tableaux de contingence avec count()\nCalculer des statistiques r√©capitulatives par groupe √† l‚Äôaide de summarize()\nR√©viser comment s√©lectionner les lignes en utilisant filter() et cr√©er/modifier des variables avec mutate()\nCr√©er des variables cat√©gorielles ordonn√©es"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#objectifs",
    "href": "sessions_core/05_summary_table.html#objectifs",
    "title": "Tableaux r√©capitulatifs",
    "section": "",
    "text": "Cr√©er des tableaux de contingence avec count()\nCalculer des statistiques r√©capitulatives par groupe √† l‚Äôaide de summarize()\nR√©viser comment s√©lectionner les lignes en utilisant filter() et cr√©er/modifier des variables avec mutate()\nCr√©er des variables cat√©gorielles ordonn√©es"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#setup",
    "href": "sessions_core/05_summary_table.html#setup",
    "title": "Tableaux r√©capitulatifs",
    "section": "Setup",
    "text": "Setup\nD√©pendances. Cette session suppose que vous savez utiliser RStudio, que vous √™tes capable d‚Äôimporter des donn√©es et que vous connaissez les verbes de base de manipulation des donn√©es que nous avons vus dans les sessions de base jusqu‚Äô√† pr√©sent. Si vous avez besoin d‚Äôun rappel sur l‚Äôun de ces sujets, nous vous encourageons √† revoir les sessions de base du parcours d‚Äôapprentissage.\n\nCette session utilisera la version nettoy√©e de l‚Äôensemble de donn√©es Moissala sur la rougeole.\n\n\n\n Linelist rougeole nettoy√©e\n\n\n\n Ouvrez votre projet RStudio et cr√©ez un nouveau script dans le sous-dossier R appel√© tables.R avec les m√©tadonn√©es appropri√©es et une section ‚ÄúPackages‚Äù qui importe : {rio}, {here} et {tidyverse}. Ajoutez une section ‚ÄúImport Data‚Äù qui charge la version nettoy√©e de la linelist de la rougeole dans R."
  },
  {
    "objectID": "sessions_core/05_summary_table.html#introduction-agr√©gation-des-donn√©es",
    "href": "sessions_core/05_summary_table.html#introduction-agr√©gation-des-donn√©es",
    "title": "Tableaux r√©capitulatifs",
    "section": "Introduction : agr√©gation des donn√©es",
    "text": "Introduction : agr√©gation des donn√©es\nR√©capitulons. Vous venez d‚Äôeffectuer l‚Äôune des t√¢ches les [plus importantes]{.hovertip bs-toggle=‚Äòtooltip‚Äô bs-title=‚ÄôCertains consid√®rent que cela repr√©sente 80 % du travail !} d‚Äôun √©pid√©miologiste : le nettoyage des donn√©es. Maintenant que vous disposez de donn√©es propres et normalis√©es, vous pouvez vous mettre au travail et commencer √† les analyser. Les analyses commencent g√©n√©ralement par des tableaux et des r√©sum√©s qui d√©crivent nos donn√©es :\n\nTableaux de fr√©quence univari√©s pour compter les occurrences de diff√©rentes valeurs\nStatistiques sommaires des variables num√©riques (moyenne, m√©diane, √©cart-type)\nTableaux crois√©s pour examiner les relations entre les variables cat√©gorielles\nR√©sum√©s par groupe pour comparer les statistiques entre diff√©rents sous-ensembles de donn√©es"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#compter-plusieurs-colonnes-tableaux-de-contingence",
    "href": "sessions_core/05_summary_table.html#compter-plusieurs-colonnes-tableaux-de-contingence",
    "title": "Tableaux r√©capitulatifs",
    "section": "Compter plusieurs colonnes (tableaux de contingence)",
    "text": "Compter plusieurs colonnes (tableaux de contingence)\nAu cours de la session d‚Äôexploration des donn√©es, vous avez appris √† cr√©er un tableau de fr√©quence pour une variable cat√©gorielle unique √† l‚Äôaide de la fonction count(). C‚Äôest bien, mais nous voulons souvent compter le nombre d‚Äôobservations en fonction de deux variables (ou plus !).\nCes tableaux sont appel√©s tableaux de contingence. Par exemple, conna√Ætre le nombre de patients par sous-pr√©fecture est tr√®s utile, mais nous pourrions vouloir stratifier √† la fois par sous-pr√©fecture et par groupe d‚Äô√¢ge pour voir si certaines zones ont des patients anormalement √¢g√©s. Ce type de stratification est un moyen utile d‚Äôessayer de trouver des zones qui pourraient √™tre de bons candidats pour des campagnes de rattrapage. C‚Äôest facile, il suffit de passer plusieurs noms de colonnes √† count() :\n\ndf_linelist |&gt;\n  count(sous_prefecture, age_groupe)\n\n\nCr√©ez un nouveau tableau r√©capitulatif en comptant le nombre de patients stratifi√©s par sous_prefecture et hospitalisation. Que se passe-t-il si vous modifiez l‚Äôordre des arguments donn√©s √† count() ?\nMaintenant, en utilisant count(), r√©ponds aux questions suivantes :\n\nCombien de patients √©taient des femmes ? Quelle est la proportion ?\nQuelles sont toutes les valeurs possibles de la variable statut_sortie ?\nCombien de patients √¢g√©s de 1 √† 4 ans se sont r√©tablis ?"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#filtrer-les-valeurs-na",
    "href": "sessions_core/05_summary_table.html#filtrer-les-valeurs-na",
    "title": "Tableaux r√©capitulatifs",
    "section": "Filtrer les valeurs NA",
    "text": "Filtrer les valeurs NA\nEn examinant les cat√©gories du statut_sortie, vous devriez avoir remarqu√© que certaines patientes ont des valeurs manquantes (NA):\n\ndf_linelist |&gt;\n  count(statut_sortie) |&gt;\n  mutate(prop = n / sum(n))\n\n\nObservez le r√©sultat du code ci-dessus. Comment pouvez-vous √©galement calculer la proportion de patients d√©c√©d√©s ? √ätes-vous satisfait de ce calcul ?\n\nLa proportion de cas d√©c√©d√©s est √©galement appel√©e taux de l√©talit√©. Pour calculer pr√©cis√©ment le CFR, nous devons nous assurer que le d√©nominateur ne comprend que les patients dont nous sommes s√ªrs du r√©sultat (c‚Äôest-√†-dire que nous devons supprimer tous les cas avec ‚ÄúNA‚Äù ou ‚Äúcontre avis m√©dical‚Äù).\nRappelons que nous pouvons le faire en utilisant filter(). Pour garder les valeurs manquantes (NA) dans une variable, nous pouvons utiliser la petite fonction is.na(statut_sortie). L‚Äôajout d‚Äôun ! devant fera l‚Äôinverse : supprimer les valeurs manquantes de statut_sortie :\n\ndf_linelist |&gt;\n  filter(statut_sortie != \"sortie contre avis medical\", \n         !is.na(statut_sortie)) |&gt;\n  count(statut_sortie)\n\n\nQuelle autre instruction conditionnelle pourriez-vous utiliser dans filter() pour obtenir les m√™mes r√©sultats ?\n\nMaintenant que nous avons supprim√© les patients dont l‚Äôissue est inconnue, nous pouvons ajouter ceci avant de cr√©er notre tableau de fr√©quence pour obtenir le CFR correct.\n\n√Ä l‚Äôaide de votre filtre, mettez √† jour votre code pour r√©sumer le nombre observ√© de patients qui ont surv√©cu et sont d√©c√©d√©s ainsi que le taux de l√©talit√© (proportion de d√©c√®s). Stockez ce nouveau dataframe dans un objet, cfr_df.\n\n\n\n\n\n\n\nAstuce\n\n\n\nBonus. Une fonction de ‚Äúraccourci‚Äù utile est drop_na() du package {tidyr} qui √©quivaut √† filter(!is.na()).\n\ndf_linelist |&gt;\n  drop_na(statut_sortie) |&gt;\n  count(statut_sortie)\n\ndrop_na() est particuli√®rement utile car vous pouvez lui donner plusieurs noms de colonnes pour filtrer. Mais attention, cela supprimera toutes les lignes o√π une ou plusieurs de ces colonnes ont une valeur manquante."
  },
  {
    "objectID": "sessions_core/05_summary_table.html#tableau-r√©capitulatif-statistiques-par-sous-pr√©fecture",
    "href": "sessions_core/05_summary_table.html#tableau-r√©capitulatif-statistiques-par-sous-pr√©fecture",
    "title": "Tableaux r√©capitulatifs",
    "section": "Tableau r√©capitulatif : statistiques par sous-pr√©fecture",
    "text": "Tableau r√©capitulatif : statistiques par sous-pr√©fecture\nMaintenant que nous avons produit quelques tableaux de fr√©quence et de contingence simples, nous pouvons augmenter la complexit√©. Une t√¢che courante en √©pid√©miologie consiste √† examiner les statistiques r√©sum√©es dans des sous-ensembles de donn√©es.\nPar exemple, on peut nous demander de produire des statistiques sur les patients au niveau des sous-pr√©fectures, c‚Äôest-√†-dire que pour chaque sous-pr√©fecture dans les donn√©es, nous devons r√©pondre aux questions suivantes :\n\nCombien de patients ont √©t√© consult√©s ?\nQuel est leur √¢ge moyen ?\nQuelle a √©t√© la date d‚Äôadmission la plus ancienne ?\nCombien de patients ont √©t√© hospitalis√©s ?\nParmi les enfants de moins de 6 mois, combien sont d√©c√©d√©s ?\n\nC‚Äôest exactement pour cela que la fonction summarize() a √©t√© cr√©√©e ! Elle nous permet de calculer des statistiques r√©sum√©es sur un ensemble de donn√©es, et la syntaxe est similaire √† celle de mutate() :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf |&gt;\n  mutate(new_col = function_to_create(existing_col))\n\ndf |&gt;\n  summarize(.by = grouping_variable,\n            new_col = summary_function(existing_col))\n\nConsid√©rons le code suivant, o√π nous r√©sumons les donn√©es pour calculer l‚Äô√¢ge moyen de tous les patients.\n\ndf_linelist |&gt;\n  summarize(moy_age = mean(age))\n\n# A tibble: 1 √ó 1\n  moy_age\n    &lt;dbl&gt;\n1    6.82\n\n\nNotez que ce code donne une seule valeur pour l‚Äô√¢ge moyen. Aucune variable de regroupement n‚Äôa √©t√© fournie, donc summarize() a renvoy√© une statistique r√©capitulative pour l‚Äôensemble du jeu de donn√©es. Pour calculer l‚Äô√¢ge moyen par strate sp√©cifique, nous devons sp√©cifier une variable de regroupement en utilisant l‚Äôargument .by :\n\ndf_linelist |&gt;\n  summarize(.by = sexe, # Faire le r√©sum√© (ici, la moyenne) par sexe\n            moy_age = mean(age))\n\n# A tibble: 2 √ó 2\n  sexe  moy_age\n  &lt;chr&gt;   &lt;dbl&gt;\n1 f        6.77\n2 m        6.87\n\n\n\nJetez un ≈ìil aux r√©sultats ci-dessus. Comment les interpr√©tez-vous ?\n\nMaintenant que nous pouvons utiliser summarize(), nous pouvons l‚Äôutiliser pour calculer des statistiques r√©capitulatives appropri√©es par sous-pr√©fecture. Commen√ßons par appeler un summarize() vide et regrouper les donn√©es sur sous_prefecture.\n\nEx√©cutez le code suivant :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture)\n\nQue se passe-t-il lorsque vous ex√©cutez ces lignes ?\n\n\nComptages\nNous voulons d‚Äôabord examiner le nombre de cas dans chaque sous_prefecture. Cela peut √™tre fait en utilisant la fonction d‚Äôaide n() :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n()  # pour compter\n)\n\n\nOk, maintenant construisons un tableau r√©capitulatif pour chaque sous-pr√©fecture. Commen√ßons par reproduire les lignes ci-dessus.\n\n\n\nR√©capitulatifs des variables continus\nNous pouvons ensuite utiliser les fonctions mean(), median(), min(), max() (et autres) pour produire des r√©capitulatifs pour les variables continues. Par exemple, l‚Äô√¢ge moyen :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n(),\n            mean_age = mean(age))\n\n\nAjoutez la date d‚Äôadmission minimale √† votre tableau pour chacune des sous_prefecture ? √ätes-vous satisfait des r√©sultats ?\n\n\n\n\n\n\n\nAstuce\n\n\n\nN‚Äôoubliez pas qu‚Äôavec les fonctions arithm√©tiques telles que mean(), median(), min(), max(), vous devez indiquer explicitement √† R de supprimer NA.\n\n\n\n\nComptage avec une condition\nNous pouvons √©galement √™tre int√©ress√©s par le nombre de patients (lignes) qui r√©pondent √† une condition : le nombre de patients de sexe f√©minin. Le comptage par condition logique peut √™tre effectu√© avec la syntaxe suivante :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\nsummarize(sum_category = sum(LOGIC_TEST, na.rm = TRUE))\n\nCette somme nous permet de compter toutes les lignes o√π notre condition a √©t√© remplie (retourne TRUE). Par exemple :\nCette somme nous permet de compter toutes les lignes o√π notre condition a √©t√© remplie (retourne TRUE). Par exemple :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_female = sum(sexe == \"f\", na.rm = TRUE))\n\n\nAjoutez une variable √† votre tableau qui compte le nombre de patients qui ont √©t√© hospitalis√©s. (c‚Äôest-√†-dire : les lignes qui ont ‚Äúoui‚Äù dans la variable ‚Äúhospitalisation‚Äù)\n\n\n\nAutres statistiques\nParfois, nous voulons produire une statistique plus compliqu√©e, par exemple l‚Äô√¢ge moyen de tous les patients hospitalis√©s. Ici, la syntaxe est un peu diff√©rente :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\ndf |&gt;\n  summarize(mean_category = mean(col_to_use[LOGIC_TEST], na.rm = TRUE))\n\nIci, nous avons : - Indiqu√© quelle statistique de synth√®se nous voulons utiliser (mean()) - Indiqu√© sur quelle colonne nous voulons calculer cette statistique (col_to_use) - Cr√©ation d‚Äôune condition indiquant les observations de cette colonne √† utiliser dans le calcul ([LOGIC_TEST])\nPour donner un exemple concret, si nous voulions calculer la moyenne de la variable age mais uniquement pour les patients hospitalis√©s (c‚Äôest-√†-dire dans les lignes o√π hospitalisation == \"oui\") nous √©cririons :\n\ndf_linelist |&gt;\n  summarize(.by = sous_prefecture,\n            n_patients = n(),\n            moy_age_hosp = mean(age[hospitalisation == \"oui\"], na.rm = TRUE))\n\nL‚Äôutilisation d‚Äôun test logique dans l‚Äôexemple ci-dessus est appel√©e indexation logique, o√π une condition est essentiellement utilis√©e pour filtrer les observations que vous souhaitez prendre en compte lors d‚Äôun calcul. L‚Äôindexation logique est tr√®s puissante, mais elle peut aussi demander un certain temps d‚Äôadaptation, alors ne vous inqui√©tez pas trop si ce n‚Äôest pas parfaitement clair √† ce stade.\n\nPouvez-vous utiliser cette syntaxe pour calculer l‚Äô√¢ge moyen des patientes dans votre tableau ?\n\nC‚Äôest tr√®s bien ! Nous commen√ßons √† obtenir un tableau r√©capitulatif group√© assez exhaustif avec beaucoup d‚Äôinformations utiles par ‚Äúsous-pr√©fecture‚Äù ! Un d√©fi suppl√©mentaire pour vous :\n\nD√âFI : Pourriez-vous ajouter une variable √† votre tableau qui compte le nombre de patients d√©c√©d√©s parmi ceux qui ont &lt; 6 mois.\n Note. Vous voulez compter les lignes (donc utiliser sum()) qui remplissent une condition sp√©cifique pour le r√©sultat (statut_sortie == \"deces\"), mais uniquement lorsque age_group == \"&lt; 6 months\"\n\n\n\nUtiliser la sortie\nEnfin, n‚Äôoubliez pas que summarize() renvoie un dataframe que nous pouvons ensuite manipuler davantage (par exemple : avec filter() et mutate()).\n\nAjoutez un mutate() apr√®s avoir produit votre tableau r√©capitulatif pour calculer :\n\nLa proportion de patients hospitalis√©s par sous-pr√©fecture\nLa proportion de patientes par sous-pr√©fecture\n\n\nL‚Äôen-t√™te de votre tableau final devrait ressembler √† ceci :\n\n\n# A tibble: 6 √ó 11\n  sous_prefecture n_patients moy_age min_admission n_femme n_hosp moy_age_hosp\n  &lt;chr&gt;                &lt;int&gt;   &lt;dbl&gt; &lt;date&gt;          &lt;int&gt;  &lt;int&gt;        &lt;dbl&gt;\n1 Moissala              1808    6.84 2022-08-14        923    612         5.49\n2 Bouna                 1376    6.56 2023-01-11        669    412         5.67\n3 Bedjondo               534    7.07 2023-06-09        251    184         5.21\n4 Bekourou               496    6.84 2023-06-17        251    164         6.04\n5 Bedaya                 435    7.10 2023-07-04        209    147         6.16\n6 Koumra                 253    7.11 2023-08-14        138     84         6.26\n# ‚Ñπ 4 more variables: moy_age_femme &lt;dbl&gt;, n_deces_moins_6m &lt;int&gt;,\n#   prop_female &lt;dbl&gt;, prop_hosp &lt;dbl&gt;"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#cest-fait",
    "href": "sessions_core/05_summary_table.html#cest-fait",
    "title": "Tableaux r√©capitulatifs",
    "section": "C‚Äôest fait !",
    "text": "C‚Äôest fait !\nVous devriez √™tre fiers de vous, la cr√©ation de tableaux r√©capitulatifs est une comp√©tence importante pour un √©pid√©miologiste, et le faire en R est tr√®s efficace ! N‚Äôoubliez pas de sauvegarder votre code !\n\n\n\n Solutions exercices"
  },
  {
    "objectID": "sessions_core/05_summary_table.html#pour-aller-plus-loin",
    "href": "sessions_core/05_summary_table.html#pour-aller-plus-loin",
    "title": "Tableaux r√©capitulatifs",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\nExercices suppl√©mentaires\n\nCr√©ez un tableau r√©capitulatif qui calcule les statistiques suivantes par groupes d‚Äô√¢ge :\n\n\nLe nombre de patients\nLa proportion d‚Äôhommes\nLe nombre de d√©c√®s\nLe CFR\nLe nombre de d√©c√®s parmi les patients atteints de pneumonie\n\n\nFaites un tableau qui montre la proportion de patients par √¢ge ayant re√ßu un vaccin contre la rougeole (par rappel oral ou par carte) et ceux qui ont re√ßu 1 ou 2 doses.\nFaites un tableau comparant la proportion de patients hospitalis√©s et non hospitalis√©s pr√©sentant un TDR positif pour le paludisme, de la fi√®vre, une √©ruption cutan√©e, une toux, des yeux rouges, une pneumonie, une enc√©phalite et un MUAC ¬´ rouge ¬ª ou ¬´ jaune ¬ª (moins de 125 mm).\nCalculer le nombre moyen de jours entre l‚Äôapparition des premiers sympt√¥mes et la consultation par sous-pr√©fecture.\nCalculer le temps moyen pass√© √† l‚Äôh√¥pital (i.e.¬†jours entre l‚Äôadmission et le r√©sultat) par r√©sultat (i.e.¬†chez ceux qui ont gu√©ri et ceux qui sont d√©c√©d√©s).\n\n\n\nRessources suppl√©mentaires\n\nLe chapitre du manuel EpiR sur le regroupement des donn√©es\nUne fois que vous avez des tableaux, vous pouvez les personnaliser en profondeur pour l‚Äôaffichage/la publication √† l‚Äôaide du paquetage {gt} :\n\nSite web de gt\nLivre sur gt"
  },
  {
    "objectID": "sessions_extra/data_exploration.html",
    "href": "sessions_extra/data_exploration.html",
    "title": "Exploration des donn√©es",
    "section": "",
    "text": "Effectuer une exploration rapide d‚Äôun ensemble de donn√©es import√©\nProduire des tableaux de fr√©quence pour les variables"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#objectifs",
    "href": "sessions_extra/data_exploration.html#objectifs",
    "title": "Exploration des donn√©es",
    "section": "",
    "text": "Effectuer une exploration rapide d‚Äôun ensemble de donn√©es import√©\nProduire des tableaux de fr√©quence pour les variables"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#setup",
    "href": "sessions_extra/data_exploration.html#setup",
    "title": "Exploration des donn√©es",
    "section": "Setup",
    "text": "Setup\nDependances. Cette session suppl√©mentaire suppose que vous avez suivi les sessions introduction √† R et R studio, et importation de donn√©es.\n\nPour cette session, nous travaillerons avec notre liste brute de rougeole de Moissala qui peut √™tre t√©l√©charg√©e ici :\n\n\n\n  Course Folder\n\n\n\n Assurez-vous qu‚Äôil est correctement stock√© dans data/raw de votre projet. Ensuite, ouvrez un nouveau script appel√© data-exploration.R, et assurez-vous que les paquets {here}, {rio} et {dplyr} sont charg√©s. Enfin, importez les donn√©es dans R sous la forme d‚Äôun objet appel√© df_linelist."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-des-donn√©es",
    "href": "sessions_extra/data_exploration.html#exploration-des-donn√©es",
    "title": "Exploration des donn√©es",
    "section": "Exploration des donn√©es",
    "text": "Exploration des donn√©es\nJuste apr√®s avoir import√© des donn√©es dans R, nous pouvons avoir envie d‚Äôy jeter un coup d‚Äô≈ìil. Lorsque l‚Äôon parle d‚Äôexploration de donn√©es, on veut g√©n√©ralement faire plusieurs choses :\n\nExaminer les dimensions des donn√©es (c‚Äôest-√†-dire le nombre de lignes et de colonnes).\nExaminer les noms des colonnes\nVisualiser les premi√®res ou les derni√®res lignes\nD√©terminer le type des variables\nD√©terminer la plage de valeurs des variables continues\nObserver les valeurs possibles de chaque variable cat√©gorielle\n\nCe processus est crucial et nous permettra de nous familiariser avec nos donn√©es et d‚Äôidentifier les probl√®mes qui seront trait√©s lors de l‚Äô√©tape de nettoyage des donn√©es."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-de-base",
    "href": "sessions_extra/data_exploration.html#exploration-de-base",
    "title": "Exploration des donn√©es",
    "section": "Exploration de base",
    "text": "Exploration de base\nLa toute premi√®re chose que vous voulez savoir sur vos donn√©es, ce sont les dimensions, c‚Äôest-√†-dire le nombre de lignes et le nombre de colonnes qui composent vos donn√©es. Il existe plusieurs fa√ßons d‚Äôobtenir ces informations dans R :\n\nRegardez votre volet environnement dans RStudio et v√©rifiez vos donn√©es - le nombre √† c√¥t√© (5230x25) nous indique qu‚Äôil s‚Äôagit d‚Äôun data frame avec 5230 lignes et 25 colonnes.\nUtilisez dim() sur vos donn√©es pour renvoyer un vecteur avec le nombre de lignes et le nombre de colonnes.\nVous pouvez aussi utiliser ncol() pour obtenir le nombre de colonnes et nrow() pour le nombre de lignes.\n\nIl est bon de se souvenir de ces nombres afin de pouvoir rep√©rer rapidement tout changement inattendu dans vos donn√©es au cours de votre analyse (c‚Äôest-√†-dire plus ou moins de lignes ou de colonnes que pr√©vu).\n\nEn utilisant la m√©thode de votre choix, obtenez les dimensions de votre data frame df_linelist."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#noms-de-variables",
    "href": "sessions_extra/data_exploration.html#noms-de-variables",
    "title": "Exploration des donn√©es",
    "section": "Noms de variables",
    "text": "Noms de variables\nComme nous allons utiliser les noms des variables tr√®s souvent au cours de notre analyse, nous voulons nous familiariser avec eux d√®s le d√©but. De plus, nous devons identifier celles qui devront √™tre renomm√©es lors du nettoyage des donn√©es. La fonction names() renvoie un vecteur de tous les noms de variables dans notre cadre de donn√©es :\n\nnames(df_linelist)\n\n [1] \"id\"                   \"full_name\"            \"sex\"                 \n [4] \"age\"                  \"age_unit\"             \"region\"              \n [7] \"sub_prefecture\"       \"village_commune\"      \"date_onset\"          \n[10] \"date_consultation\"    \"hospitalisation\"      \"date_admission\"      \n[13] \"health_facility_name\" \"malaria_rdt\"          \"fever\"               \n[16] \"rash\"                 \"cough\"                \"red_eye\"             \n[19] \"pneumonia\"            \"encephalitis\"         \"muac\"                \n[22] \"vacc_status\"          \"vacc_doses\"           \"outcome\"             \n[25] \"date_outcome\"        \n\n\n\nQue pensez-vous des noms de votre ensemble de donn√©es ? Pouvez-vous d√©j√† rep√©rer des noms de variables que vous aimeriez renommer ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#inspecter-vos-donn√©es",
    "href": "sessions_extra/data_exploration.html#inspecter-vos-donn√©es",
    "title": "Exploration des donn√©es",
    "section": "Inspecter vos donn√©es",
    "text": "Inspecter vos donn√©es\nIl est √©galement int√©ressant d‚Äôinspecter vos donn√©es, cela peut vous permettre de rep√©rer plus facilement certaines incoh√©rences, des variables avec beaucoup de valeurs manquantes, et cela vous permettra de voir √† quelles valeurs s‚Äôattendre pour chacune d‚Äôentre elles. Vous pouvez ‚Äúprint‚Äù vos donn√©es dans la console en :\n\nEx√©cutant l‚Äôobjet df_linelist seul (attention, vous ne voudrez peut-√™tre pas faire cela si vous avez un grand ensemble de donn√©es).\nUtilisant la fonction head() pour voir les 6 premi√®res lignes (vous pouvez augmenter ce nombre en utilisant l‚Äôargument n)\nUtilisant la fonction tail() pour voir les 6 derni√®res lignes (encore une fois, vous pouvez augmenter ce nombre en utilisant l‚Äôargument n)\n\nCes m√©thodes n‚Äôafficheront que les 40 premi√®res lignes de vos donn√©es au maximum, car c‚Äôest la limite de votre console. Alternativement, vous pouvez utiliser View() pour voir vos donn√©es sous forme de tableau. Cela ouvrira une nouvelle fen√™tre avec vos donn√©es affich√©es comme dans une feuille de calcul Excel. Note : cette commande ne fait qu‚Äôafficher les donn√©es, elle ne vous permet pas de les modifier.\n\n\n\n\n\n\nAstuce\n\n\n\nSoyez tr√®s prudent avec View() sur un grand jeu de donn√©es car cela peut faire planter votre session RStudio. Pour √©viter cela, vous pouvez imprimer la sortie dans la console.\n\n\n\nPouvez-vous afficher les 15 premi√®res lignes de vos donn√©es ? Que se passe-t-il lorsque vous modifiez la largeur de votre fen√™tre de console et que vous ex√©cutez √† nouveau la commande ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#types-des-variables",
    "href": "sessions_extra/data_exploration.html#types-des-variables",
    "title": "Exploration des donn√©es",
    "section": "Types des variables",
    "text": "Types des variables\nNous voulons maintenant v√©rifier le type des diff√©rentes variables. C‚Äôest important car une partie du nettoyage des donn√©es consiste √† s‚Äôassurer que les variables num√©riques sont de type numeric, dates Date, et que les variables cat√©gorielles sont de type factor ou character. Vous avez d√©j√† vu la fonction class(), qui permet de v√©rifier le type d‚Äôun vecteur. Dans R, chaque variable d‚Äôun dataframe est un vecteur. Nous pouvons extraire toutes les valeurs de ce vecteur en utilisant le sign $, et les passer √† la fonction class() :\n\nclass(df_linelist$age)\n\n\nEssayez d‚Äôextraire toutes les valeurs de la variable sex. Quelle est le type de cette variable ?\n\nVous pouvez √©galement utiliser str() sur votre dataframe pour v√©rifier le type de toutes les variables √† la fois :\n\nstr(df_linelist)\n\n\nUtilisez str() pour v√©rifier le type de donn√©es de chaque colonne. Y a-t-il quelque chose d‚Äô√©trange ? Rappelez-vous que vous pouvez aussi utiliser des fonctions comme is.character() et is.numeric() si vous voulez tester le type d‚Äôune colonne en particulier."
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-des-variables-continues",
    "href": "sessions_extra/data_exploration.html#exploration-des-variables-continues",
    "title": "Exploration des donn√©es",
    "section": "Exploration des variables continues",
    "text": "Exploration des variables continues\nMaintenant que vous savez comment extraire les valeurs d‚Äôune variable, vous pouvez vouloir explorer certaines des valeurs des variables num√©riques pour v√©rifier les incoh√©rences. Calculer des statistiques r√©capitulatives pour ces variables, et Base R fournit de nombreuses fonctions pratiques :\n\n\n\n\n\n\n\n\n\nFonction\nDescription\nExemple\nRetours\n\n\n\n\nmin()\nValeur minimale\nmin(x)\nValeur minimale unique\n\n\nmax()\nValeur maximale\nmax(x)\nValeur maximale unique\n\n\nmean()\nMoyenne arithm√©tique\nmean(x)\nValeur moyenne\n\n\nmedian()\nValeur moyenne\nmedian(x)\nValeur moyenne\n\n\nrange()\nMin et max\nrange(x)\nVecteur de (min, max)\n\n\nIQR(x)\nQ3 - Q1\nIQR(x)\nQ3 - Q1\n\n\nquantile()\nQuantiles sp√©cifi√©s\nquantile(x, probs = c(0.25, 0.75))\nQuantiles demand√©s\n\n\nsd()\nEcart-type\nsd()\nEcart-type\n\n\nvar()\nVariance\nvar(x)\nVariance\n\n\nsum()\nSomme des valeurs\nsum(x)\nSomme\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nCes fonctions exigent que vous supprimiez explicitement les valeurs manquantes (NA) en utilisant l‚Äôargument na.rm = TRUE\n\n\nVous pouvez extraire les valeurs d‚Äôune variable en utilisant $, et les passer √† n‚Äôimporte laquelle de ces fonctions.\n\nUtilisez la syntaxe $ pour obtenir :\n\nLa valeur minimale de age\nLe maximum de muac\n\nDes probl√®mes ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#exploration-des-variables-cat√©gorielles",
    "href": "sessions_extra/data_exploration.html#exploration-des-variables-cat√©gorielles",
    "title": "Exploration des donn√©es",
    "section": "Exploration des variables cat√©gorielles",
    "text": "Exploration des variables cat√©gorielles\nEnfin, examinons les valeurs de nos variables cat√©gorielles. Pour ce faire, nous pouvons utiliser des tableaux de fr√©quence. C‚Äôest pratique car :\n\nIls nous permettent de voir rapidement les valeurs uniques d‚Äôune variable cat√©gorielle\nLe nombre d‚Äôobservations pour chacune de ces cat√©gories\n\nPour ce faire, on utilise la fonction count() du package {dplyr}, qui accepte un dataframe et le nom d‚Äôune (ou plusieurs !) colonne(s) en tant qu‚Äôarguments. Il compte alors le nombre d‚Äôobservations de chaque √©l√©ment unique dans cette colonne. Par exemple, voyons les valeurs possibles de la variable sex :\n\ncount(df_linelist, sex)\n\nLe r√©sultat est un nouveau dataframe, plus petit, contenant le nombre de patients observ√©s, stratifi√© par sex. Il semble que cette variable n√©cessite un recodage‚Ä¶ Nous le ferons dans une prochaine session.\n\nEn utilisant les donn√©es de votre liste, examinez les valeurs de la variable outcome. A quoi cela ressemble-t-il ?\nMaintenant, essayez d‚Äôajouter l‚Äôargument sort = TRUE √† la fonction count(). Que fait cet argument ?"
  },
  {
    "objectID": "sessions_extra/data_exploration.html#cest-fait",
    "href": "sessions_extra/data_exploration.html#cest-fait",
    "title": "Exploration des donn√©es",
    "section": "C‚Äôest fait !",
    "text": "C‚Äôest fait !\nBravo pour ce premier coup d‚Äô≈ìil sur vos donn√©es !\n\n\n\n Solution File"
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html",
    "href": "sessions_extra/surveillance_companion.html",
    "title": "Surveillance",
    "section": "",
    "text": "Travailler les comp√©tences acquises dans les deux modules FETCH-R (importation, nettoyage et visualisation des donn√©es).\nAnalyser des donn√©es de surveillance rougeole pour d√©tecter les alertes et aider √† prioriser quelles alertes doivent √™tre approfondies avec une enqu√™te sur le terrain."
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#objectifs",
    "href": "sessions_extra/surveillance_companion.html#objectifs",
    "title": "Surveillance",
    "section": "",
    "text": "Travailler les comp√©tences acquises dans les deux modules FETCH-R (importation, nettoyage et visualisation des donn√©es).\nAnalyser des donn√©es de surveillance rougeole pour d√©tecter les alertes et aider √† prioriser quelles alertes doivent √™tre approfondies avec une enqu√™te sur le terrain."
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#introduction",
    "href": "sessions_extra/surveillance_companion.html#introduction",
    "title": "Surveillance",
    "section": "Introduction",
    "text": "Introduction\nCe satellite accompagne l‚Äô√©tude de cas R√©ponse d‚Äôurgence contre la rougeole dans la r√©gion du Katanga (RDC) du module FETCH Surveillance. √áa n‚Äôa probablement pas beaucoup de sens d‚Äôessayer de le suivre sans les documents et les discussions de l‚Äô√©tude.\nEn ce qui concerne la partie R du module surveillance, nous nous appuierons sur les comp√©tences acquises tout au long des modules FETCH-R, et introduirons quelques nouvelles fonctions utiles pour le nettoyage et les analyses.\n\n\n\n\n\n\nAstuce\n\n\n\nN‚Äôh√©sitez pas √† checker vos notes, vos scripts ou les tutoriels des sessions pr√©c√©dentes pour vous rafra√Æchir sur le fonctionnement de certaines fonctions quand vous en √©prouvez le besoin."
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#mise-en-place-question-2",
    "href": "sessions_extra/surveillance_companion.html#mise-en-place-question-2",
    "title": "Surveillance",
    "section": "Mise en place (Question 2)",
    "text": "Mise en place (Question 2)\nComme cette session fait partie d‚Äôun module sp√©cifique, vous allez cr√©er un nouveau projet RStudio. Jetez un coup d‚Äô≈ìil √† la session principale si vous ne vous rappelez plus comment faire.\n\nCr√©er le projet\n\n\nCr√©ez un dossier surveillance_case_study sur votre ordinateur, associ√© avec le module Surveillance du FETCH. Ajoutez les sous dossiers suivants √† l‚Äôint√©rieur :\n\n\nüìÅ data\n\nüìÅ clean\nüìÅ raw\n\nüìÅ R\nüìÅ outputs\n\n\nCr√©ez un projet RStudio √† la racine du dossier surveillance_case_study.\nSi vous n‚Äôavez pas encore les donn√©es, t√©l√©chargez-les.\n\n\n\n\n T√©l√©charger les donn√©es brutes\n\n\n\n 4. D√©zippez l‚Äôarchive si vous venez de t√©l√©charger les donn√©es. Quelle que soit la source, enregistrez les deux fichiers Excel dans le sous dossier data/raw.  5. Cr√©ez un nouveau script import_nettoyage.R et enregistrez-le dans le sous dossier R. Ajoutez les m√©tadonn√©es et une section pour charger les paquets {here}, {rio}, et {tidyverse}.\n\n\n\nImporter les donn√©es\nRappel de l‚Äô√©tude de cas : vous avez demand√© l‚Äôacc√®s aux donn√©es de surveillance de routine et aux donn√©es de laboratoire au MSP de la RDC. Le minist√®re a accept√© de les partager avec vous toutes les semaines. Vous recevez le premier fichier √† la semaine 20 en 2022 (note : les donn√©es sur lesquelles nous travaillerons sont simul√©es).\n\nSi vous ne l‚Äôavez pas d√©j√† fait, ouvrez les deux fichiers dans un tableur (Excel ou autre) pour les inspecter avant l‚Äôimportation.\n\nLe jeu de donn√©es de surveillance a l‚Äôair facile √† importer. En revanche, le jeu de donn√©es laboratoire pourrait vous inqui√©ter, avec ses lignes suppl√©mentaires avant les donn√©es‚Ä¶ Heureusement, la fonction import() que nous utilisons a un argument skip qui permet de g√©rer ce cas courant :\n\n# NE PAS EX√âCUTER (PSEUDO-CODE)\nimport(\n  here(\"data\", \"raw\", \"fichier_exemple.xlsx\"), \n  skip = 3  # Sauter les trois premi√®res lignes, l'import commence √† la ligne 4\n) \n\n\n\nAjoutez une section pour l‚Äôimport des donn√©es √† votre script.\nImportez le jeu de donn√©es surveillance et stockez le dans un objet df_surv_brut. Ensuite, importez le jeu de donn√©es laboratoire et stockez le dans un objet df_labo_brut.\nV√©rifiez que l‚Äôimportation s‚Äôest bien pass√©e pour les deux data frames (vous avez plusieurs outils √† votre disposition : Viewer, dimensions de l‚Äôobjet, haut et bas du data frame‚Ä¶)."
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#nettoyage-question-2-and-3",
    "href": "sessions_extra/surveillance_companion.html#nettoyage-question-2-and-3",
    "title": "Surveillance",
    "section": "Nettoyage (Question 2 and 3)",
    "text": "Nettoyage (Question 2 and 3)\nMaintenant que les donn√©es sont import√©es, nous pouvons effectuer quelques v√©rifications dessus, et les nettoyer.\n\nDonn√©es de surveillance (Q2)\n\nInspection rapide\nPendant l‚Äô√©tude de cas vous n‚Äôaurez peut-√™tre pas le temps d‚Äôinspecter et nettoyer toutes les colonnes. Nous vous proposons donc de vous focaliser sur quelques colonnes cl√©s : zone_sante, semaine, totalcas et totaldeces.\n\n\n\n\n\n\nNote\n\n\n\nSi vous revenez sur le tutoriel plus tard ou finissez en avance, n‚Äôh√©sitez pas √† v√©rifier la qualit√© des autres variables, et √† recouper les informations de diff√©rentes colonnes. Nous vous renvoyons √† la discussion lors de l‚Äô√©tude ou aux documents du module de gestion des donn√©es pour des id√©es de v√©rifications √† effectuer.\n\n\n\nAjoutez une section pour l‚Äôexploration et le nettoyage des donn√©es de surveillance dans votre script.  Maintenant, explorez le data frame et r√©pondez aux questions suivantes :\n\nQuels sont les noms des colonnes ?\nCombien de provinces y a-t-il dans le jeu de donn√©es actuel ? Cela correspond-il √† ce que vous attendez ?\nCombien de zones de sant√© y a-t-il dans le jeu de donn√©es ? Cela correspond-il √† ce que vous attendez ?\nQuel est la plage des semaines ?\nQuelle est la valeur minimale de totalcas ?\nQuel est le maximum de totaldeces ?\nRemarquez-vous des donn√©es manquantes pour les colonnes ci-dessus ? Les cha√Ænes de caract√®re (rappel : le texte) sont-elles propres ?\n\n\n\n\nNettoyer les cha√Ænes de caract√®res\nMaintenant que nous avons une meilleure id√©e de l‚Äô√©tat des donn√©es, nettoyons-les. Nous allons √©crire un pipeline de nettoyage (ou cha√Æne de commandes) comme dans les modules R pr√©c√©dents (voir votre code √† la fin du module de nettoyage).\n\n\n\n\n\n\nAstuce\n\n\n\nPour faciliter le d√©bogage de la cha√Æne de commandes, ajoutez et testez les √©tapes unes par unes !\n\n\nNous allons am√©liorer un peu les colonnes de texte afin d‚Äô√©liminer des probl√®mes potentiels :\n\npasser tout en minuscules (homog√©n√©ise)\nsupprimer les espaces surnum√©raires (√©ventuels)\nremplacer - et les espaces par _.\n\nPeut √™tre que vous n‚Äôaurez pas le temps de faire ces √©tapes pour toutes les colonnes. Pour commencer, choisissez une de ces deux colonnes : zone_sante ou prov pour appliquer les instructions. Vous pourrez faire les autres plus tard.\n\nCommencez un pipeline de nettoyage avec un mutate() pour transformer la colonne de votre choix en minuscules.\n\nNous allons maintenant voir deux petites fonctions tr√®s utiles pour le nettoyage du texte. La premi√®re est la fonction str_squish() du paquet {stringr} (la page d‚Äôaide), qui supprime les espaces au d√©but ou √† la fin des cha√Ænes de caract√®res, et les espaces surnum√©raires ou qu‚Äôils soient :\n\nexemples &lt;- c(\" Espaces au d√©but et √† la fin     \",\n              \"Espaces     multiples\",\n              \" Tous les     probl√®mes  \")\n\nstr_squish(exemples)\n\n[1] \"Espaces au d√©but et √† la fin\" \"Espaces multiples\"           \n[3] \"Tous les probl√®mes\"          \n\n\nL‚Äôautre fonction, str_replace (√©galement du paquet {stringr}) remplace un bout de texte dans une cha√Æne de caract√®res par un autre bout de texte, sans surprise. L‚Äôargument pattern accepte le texte √† remplacer, et l‚Äôargument replacement le texte √† utiliser comme remplacement.\n\nstr_replace(\n  \"HAUT-KATANGA\",    # Le texte sur lequel on travaille (peut √™tre une colonne)\n  pattern = \"-\",     # Le bout √† remplacer\n  replacement = \"_\"  # Le remplacement\n)\n\n[1] \"HAUT_KATANGA\"\n\n\n\nAjoutez des lignes √† votre mutate pour, sur la colonne de votre choix :\n\nNettoyer les espaces\nChanger les - et les espaces en _ (deux √©tapes)\n\nLe d√©but d‚Äôau moins une des colonnes devrait ressembler √† :\n\n\n  pays     province     zone_sante  maladie\n1  rdc haut_katanga mufunga_sampwe rougeole\n2  rdc haut_katanga        sakania rougeole\n3  rdc haut_katanga        mitwaba rougeole\n4  rdc haut_katanga kilela_balanda rougeole\n5  rdc haut_katanga         likasi rougeole\n6  rdc haut_katanga         kikula rougeole\n\n\nStockez le r√©sultat dans un data frame df_surv.\n\n\n\nEnregistrer les donn√©es nettoy√©es\n\nUtilisez le paquet {rio} pour exporter df_surv vers un fichier .rds appel√© data_ids_2022-20_clean dans le sous dossier data/clean de votre projet.\n\n\n\n\nDonn√©es labo (Q2)\nNous allons suivre les m√™mes √©tapes pour le jeu de donn√©es laboratoire. Nous nous focaliserons sur les colonnes zone_sante, igm_rougeole et igm_rubeole.\n\nInspection rapide\n\nInspectez les colonnes mentionn√©es, et les dimensions du data frame.\nQuelles sont les cat√©gories des colonnes igm_rougeole et igm_rubeole ? Quel type de nettoyage sera √† effectuer dessus ?\n\n\n\nNettoyage et recodage\n\n\nD√©marrez un nouveau pipeline de nettoyage pour les donn√©es labo. Choisissez une colonne de texte et passez l√† en minuscules, puis supprimez les espaces surnum√©raires. Enfin, remplacez les espaces et les - par _.\nRecodez au moins une des colonnes igm_rougeole ou igm_rubeole pour que les cat√©gories soient negatif, positif et indetermin√©.\nStockez la version nettoy√©e dans un data frame df_labo\n\nL‚Äôen-t√™te des colonnes nettoy√©es devrait maintenant √™tre :\n\n\n   zone_sante igm_rougeole igm_rubeole\n1     kambove      negatif     negatif\n2     kambove      negatif     negatif\n3     kambove      negatif     positif\n4     kambove      negatif     negatif\n5     kambove      negatif     positif\n6     kambove      negatif     negatif\n7     kambove      negatif     negatif\n8     kambove      negatif     positif\n9      manika      negatif     negatif\n10  kamalondo      negatif     negatif\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\n\n\nVous pouvez utiliser la fonction case_when() pour recoder les colonnes contenant les r√©sultats des tests anticorps.\n\n\n\n\n\nEnregistrer les donn√©es nettoy√©es\n\nExportez le data frame df_labo vers un fichier .rds appel√© df_labo_2022-w20_clean dans le sous dossier data/clean de votre projet.\n\n\n\n\nAller plus loin\nVous √™tes arriv√©s au bout de la question 2. Si vous avez termin√© en avance, utilisez les fonctions vues pour nettoyer les autres colonnes de texte dans les deux data frames, et recodez les deux colonnes IGM dans les donn√©es labo.\nSi vous avez encore du temps, inspectez vos donn√©es plus avant :\n\nAffichez la zone de sant√© pour laquelle les totaux par groupe d‚Äô√¢ge sont diff√©rents de la colonne total (pour les cas, puis pour les d√©c√®s)\nEst-ce qu‚Äôil y a une ZS o√π le nombre de d√©c√®s est plus √©lev√© que le nombre de cas ?\nY a-t-il des lignes dupliqu√©es (enti√®rement dupliqu√©es, ou plusieurs valeurs pour la zone de sant√© et la semaine) ?\nY a-t-il des nombres de cas que vous estimez aberrants ?\n\n\n\nDonn√©es de surveillance compl√©t√©es (Q3)\nDurant l‚Äôinspection des donn√©es vous avez du vous rendre compte qu‚Äôil y a des semaines manquantes pour certaines ZS dans les donn√©es de surveillance. Normalement, vous avez discut√© les raisons possibles et des probl√®mes associ√©s en pl√©ni√®re. Dans ce tutoriel, nous allons fournir le code pour compl√©ter le data frame surveillance pour que toutes les ZS aient toutes les semaines (en faisant l‚Äôhypoth√®se que les semaines manquantes n‚Äôont pas eu de cas ou de d√©c√®s).\nNous utiliserons la fonction complete() du paquet {tidyr} pour ajouter les lignes manquantes et remplir les colonnes contenant des nombres (totalcas et totaldeces) avec des z√©ros. A cause des contraintes de temps nous allons vous donner le code, mais quelques exemples et explicatins seront donn√©s dans la section Aller plus loin que vous pourrez lire quand vous aurez le temps.\n\n\nCommencez un nouveau pipeline √† partir de df_surv et ne conservez dedans que les colonnes province, zone_sante, semaine et totalcas.\nAjoutez une nouvelle √©tape √† votre pipeline et collez le code ci-dessous pour compl√©ter le data frame :\n\n\ncomplete(\n  # On travaille sur les combinaisons existantes de province et ZS\n  nesting(province, zone_sante),\n  \n  # On voudra toutes les semaines entre le minimum (1) et le maximum (20) de la colonne semaine\n  semaine = seq(min(semaine, na.rm = TRUE), \n                max(semaine, na.rm = TRUE)),\n  \n  # Remplir les nouvelles semaines de zeros pour ces colonnes :\n  fill = list(totalcas   = 0, \n              totaldeces = 0\n  )\n) \n\n\nStockez le r√©sultat dans un data frame appel√© df_surv_sem, qui devrait ressembler √† :\n\n\n\n# A tibble: 10 √ó 5\n   province     zone_sante semaine totalcas totaldeces\n   &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1 haut_katanga kafubu           1        0          0\n 2 haut_katanga kafubu           2        0          0\n 3 haut_katanga kafubu           3        0          0\n 4 haut_katanga kafubu           4        0          0\n 5 haut_katanga kafubu           5        0          0\n 6 haut_katanga kafubu           6        0          0\n 7 haut_katanga kafubu           7        0          0\n 8 haut_katanga kafubu           8        0          0\n 9 haut_katanga kafubu           9        0          0\n10 haut_katanga kafubu          10        0          0\n\n\n\nexportez ce data frame dans un fichier .rds appel√© data_ids_2022-w20_weeks_clean dans le sous dossier data/clean de votre projet.\n\n\n\n\nAller plus loin\nC‚Äôest la fin de la question 3. Si vous terminez en avance, finissez l‚Äôinspection des donn√©es, listez les probl√®mes et nettoyez les colonnes que vous savez nettoyer avant de r√©exporter. Si c‚Äôest fait, lisez les eplications sur la fonction complete() et allez explorer sa page d‚Äôaide."
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#d√©finir-les-alertes-question-4",
    "href": "sessions_extra/surveillance_companion.html#d√©finir-les-alertes-question-4",
    "title": "Surveillance",
    "section": "D√©finir les alertes (Question 4)",
    "text": "D√©finir les alertes (Question 4)\n\nPr√©parer le jeu de donn√©es\nNous allons continuer la pr√©paration de data frames pr√™ts pour l‚Äôanalyse.\n\n\nSi vous n‚Äôavez pas eu le temps de nettoyer la zone de sant√© et la province dans les deux data frames, et les deux colonnes IGM dans le jeu de donn√©es labo, vous pouvez importer les jeux de donn√©es nettoy√©s :\n\n\n\n\n T√©l√©charger donn√©es propres\n\n\n\n D√©zippez l‚Äôarchive et importez les donn√©es dans le sous dossier data/clean\n\nCr√©ez un script analyse_surveillance.R dans le sous dossier R. Ajoutez les m√©tadonn√©es, et une section pour importer les paquets {here}, {rio}, {tidyverse}, {lubridate} et {zoo}.\nAjoutez une section d‚Äôimport des donn√©es propres et importez les fichiers .rds dans R en utilisant la fonction import() comme d‚Äôhabitude (soit les v√¥tres, soit ceux que vous venez de t√©l√©charger). Assignez ces donn√©es nettoy√©es aux data frames df_surv, df_labo and df_surv_sem.\n\n\n\nS√©lection des ZS\nPour simplifier le travail nous allons nous focaliser sur quatre zones de sant√© : Dilolo, Kampemba, Kowe, et Lwamba.\n\nCommencez une nouvelle cha√Æne de commande √† partir du data frame df_surv_sem. La premi√®re √©tape est de filtrer les donn√©es pour ne conserver que les zones de sant√© Dilolo, Kampemba, Kowe, et Lwamba.\n\n\n\nIndicateur hebdomadaire\nNotre premier indicateur regarde si une zone de sant√© a 20 cas suspects ou plus dans une semaine. Cet indicateur est dichotomique et ne prend en compte que les donn√©es d‚Äôune zone de sant√© pour une semaine donn√©e (√ßa tombe bien, √ßa correspond aux lignes du data frame).\n\nAjoutez un mutate() √† votre cha√Æne pour cr√©er une colonne cas20 qui contient la valeur 1 si une ZS a 20 cas ou plus cette semaine-l√†, et 0 sinon.\n Le d√©but du data frame ressemble √† √ßa :\n\n\n# A tibble: 10 √ó 6\n   province     zone_sante semaine totalcas totaldeces cas20\n   &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1 haut_katanga kampemba         1       75          0     1\n 2 haut_katanga kampemba         2       42          0     1\n 3 haut_katanga kampemba         3       46          0     1\n 4 haut_katanga kampemba         4       50          0     1\n 5 haut_katanga kampemba         5       43          0     1\n 6 haut_katanga kampemba         6       33          0     1\n 7 haut_katanga kampemba         7       45          0     1\n 8 haut_katanga kampemba         8       52          0     1\n 9 haut_katanga kampemba         9       38          0     1\n10 haut_katanga kampemba        10       46          0     1\n\n\n\n\n\nIndicateur cumul√©\nNotre second indicateur regarde si une zone de sant√© compte plus de 35 cas suspects cumul√©s en trois semaines. C‚Äôest un peu plus compliqu√© √† calculer que l‚Äôindicateur hebdomadaire : pour chaque zone de sant√©, il faut calculer la somme des cas par fen√™tres de trois semaines, mais les groupes ne sont pas fixes, ils glissent dans le temps. Nous entrons ici dans le domaine des moyennes/sommes/etc. mobiles ou glissantes‚Ä¶\n\nSomme cumul√©e\nNous allons utiliser la fonction rollapply() du paquet {zoo} pour calculer la somme cumul√©e car elle est polyvalente et puissante. Comme son nom l‚Äôindique, la fonction rollapply() applique une fonction de mani√®re glissante (roll peut √™tre traduit ici en ‚Äúrouler‚Äù) √† un vecteur ou √† une colonne d‚Äôun data frame.\nComme nous sommes contraint par le temps, nous allons vous fournir ici le code pour calculer la somme cumul√©e, et nous vous donnerons plus de d√©tails sur la fonction dans la section Aller plus loin que vous pourrez lire quand vous aurez le temps.\nVoici comment utiliser la fonction pour une zone de sant√© :\n\n# Cr√©e un mini data frame pour l'exemple\nexemple_df = data.frame(\n  province   = \"Haut Katanga\",\n  zone_sante = \"Dilolo\",\n  semaine    = 1:10,\n  totalcas   = rep(1, times = 10))\n\nexemple_df \n\n       province zone_sante semaine totalcas\n1  Haut Katanga     Dilolo       1        1\n2  Haut Katanga     Dilolo       2        1\n3  Haut Katanga     Dilolo       3        1\n4  Haut Katanga     Dilolo       4        1\n5  Haut Katanga     Dilolo       5        1\n6  Haut Katanga     Dilolo       6        1\n7  Haut Katanga     Dilolo       7        1\n8  Haut Katanga     Dilolo       8        1\n9  Haut Katanga     Dilolo       9        1\n10 Haut Katanga     Dilolo      10        1\n\nexemple_df |&gt; \n  mutate(cas_cumu = rollapply(\n    data  = totalcas,   # La colonne cible\n    width = 3,          # La taille de la fen√™tre  \n    FUN   = sum,        # La fonction √† appliquer, ici la somme\n    align = \"right\",    # On cumule les valeurs pass√©es jusqu'√† pr√©sent\n    partial = TRUE,     # Les somme partielles sont autoris√©es\n    na.rm = TRUE        # Argument en plus √† passer √† la fonction sum()\n  )\n  )\n\n       province zone_sante semaine totalcas cas_cumu\n1  Haut Katanga     Dilolo       1        1        1\n2  Haut Katanga     Dilolo       2        1        2\n3  Haut Katanga     Dilolo       3        1        3\n4  Haut Katanga     Dilolo       4        1        3\n5  Haut Katanga     Dilolo       5        1        3\n6  Haut Katanga     Dilolo       6        1        3\n7  Haut Katanga     Dilolo       7        1        3\n8  Haut Katanga     Dilolo       8        1        3\n9  Haut Katanga     Dilolo       9        1        3\n10 Haut Katanga     Dilolo      10        1        3\n\n\nOk, mais nous voudrions utiliser cette fonction dans un data frame qui contient plusieurs zones de sant√©, et faire la somme cumul√©e par zone de sant√©. Ce n‚Äôest pas si compliqu√© : nous allons trier notre jeu de donn√©es par zone de sant√© et semaine, puis utiliser l‚Äôargument .by dans le mutate pour effectuer les actions par zone de sant√©.\n\n\n\n\n\n\nNote\n\n\n\nRappelez-vous, nous avons d√©j√† vu le .by. Nous l‚Äôavons utilis√© au sein de la fonction summarize() lors de la session sur les tableaux agr√©g√©s pour faire des r√©sum√©s par groupe.\nC‚Äôest la m√™me id√©e aujourd‚Äôhui, sauf qu‚Äôau lieux d‚Äôutiliser une fonction qui ne renvoie qu‚Äôune seule valeur par groupe (summarize()) nous allons utiliser une fonction qui retourne une valeur par ligne (mutate()), mais prendra en compte les informations du groupe.\nPour petit rappel de comment summarize() + .by fonctionne, voici comment nous calculons le nombre total de cas suspects et d√©c√®s par province :\n\ndf_surv_sem |&gt; \n  summarize(\n    .by = province,  # Fait les choses PAR province\n    cas_tot   = sum(totalcas, na.rm = TRUE),\n    deces_tot = sum(totaldeces, na.rm = TRUE)\n  )\n\n# A tibble: 4 √ó 3\n  province     cas_tot deces_tot\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;\n1 haut_katanga    5948        34\n2 haut_lomami     6928        70\n3 lualaba         1485         3\n4 tanganyika      7836       137\n\n\n\n\n\n\nAjoutez une √©tape √† votre pipeline pour trier les donn√©es par province, zone de sant√© et semaine (dans cet ordre) avec la fonction arrange(), qui est une fonction de tri du package {dplyr}:\n\n\ndf_surv_sem |&gt;\n  arrange(province, zone_sante, semaine)\n\n\nAjoutez ensuite le code pour calculer la somme cumul√©e :\n\n\nmutate(\n  .by = c(province, zone_sante),\n  cas_cumu = rollapply(\n    data  = totalcas,   # La colonne cible\n    width = 3,          # La taille de la fen√™tre  \n    FUN   = sum,        # La fonction √† appliquer, ici la somme\n    align = \"right\",    # On cumule les valeurs pass√©es jusqu'√† pr√©sent\n    partial = TRUE,     # Les somme partielles sont autoris√©es\n    na.rm = TRUE        # Argument en plus √† passer √† la fonction sum()\n  )\n)\n\n\nMaintenant que la somme cumul√©e est calcul√©e, il ne nous reste plus qu‚Äô√† calculer l‚Äôindicateur dichotomique qui r√©sume les donn√©es cumul√©es pour chaque semaine, puis un indicateur combin√© qui r√©sume les deux indicateurs pr√©c√©dents.\n\n\nAjoutez une nouvelle √©tape √† votre pipeline pour cr√©er une colonne cas_cumu35 qui contient 1 si la somme cumul√©e est sup√©rieure ou √©gale √† 35, et 0 sinon.\nDans le m√™me mutate, ajoutez une colonne alerte, qui est 1 si ‚Äôl‚Äôindicateur cas20 OU l‚Äôindicateur cas_cumu35 est 1 et 0 sinon. Pour lest logique vous devrez utiliser l‚Äôop√©rateur | qui repr√©sente le OU logique (renverra TRUE si au moins une des conditions est remplie, √† fortiori les deux).\nAssignez le r√©sultat √† un data frame data_alerte.\n\nCe data frame ressemble √† ceci (quelques colonnes sont cach√©es pour l‚Äôaffichage) :\n\n\n# A tibble: 10 √ó 7\n   zone_sante semaine totalcas cas20 cas_cumu cas_cumu35 alerte\n   &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 kampemba         1       75     1       75          1      1\n 2 kampemba         2       42     1      117          1      1\n 3 kampemba         3       46     1      163          1      1\n 4 kampemba         4       50     1      138          1      1\n 5 kampemba         5       43     1      139          1      1\n 6 kampemba         6       33     1      126          1      1\n 7 kampemba         7       45     1      121          1      1\n 8 kampemba         8       52     1      130          1      1\n 9 kampemba         9       38     1      135          1      1\n10 kampemba        10       46     1      136          1      1\n\n\n\n\n\n\n\nZones de sant√© en alerte\nMaintenant que la pr√©paration est finie, nous pouvons enfin regarder quelles zones de sant√© sont en alerte dans notre jeu de donn√©es, en particulier √† la semaine 20 (les donn√©es les plus r√©centes selon l‚Äô√©tude de cas).\n\nAffichez les donn√©es filtr√©es pour ne voir que ce qui se passe √† la semaine 20. Quelle zones sont en alerte en ce moment ?\nCr√©ez un vecteur zs_alerte qui contient le nom des zones de sant√© qui sont en alerte √† la semaine 20. Ce vecteur sera utilis√© par la suite pour filtrer les donn√©es lors de l‚Äôanalyse."
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#tracer-la-courbe-√©pid√©mique-question-4",
    "href": "sessions_extra/surveillance_companion.html#tracer-la-courbe-√©pid√©mique-question-4",
    "title": "Surveillance",
    "section": "Tracer la courbe √©pid√©mique (Question 4)",
    "text": "Tracer la courbe √©pid√©mique (Question 4)\nNous allons √† pr√©sent tracer la courbe √©pi pour les zones en alerte √† la semaine 20. Nous pouvons r√©utiliser le code vu lors de la session sur les courbes √©pid√©miques : nous utiliserons le paquet ggplot() et la fonction geom_col() pour cr√©er un diagramme qui montre la distribution des cas par semaine. Petite nouveaut√© : par le pass√© nous avions une liste linaire o√π une ligne correspond √† un patient, donc un cas. Aujourd‚Äôhui nous avons des donn√©es d√©j√† agr√©g√©es par semaine et zone de sant√© : nul besoin de compter le nombre de cas nous m√™me.\n\nTracez la courbe √©pid√©mique pour une des zones de sant√© en alerte.\n Le graphe devrait ressembler √† ceci (peut √™tre avez-vous choisi l‚Äôautre zone) :\n\n\n\n\n\n\n\n\n\n\nNouvelle fonction utile, la fonction facet_wrap() permet de cr√©er plusieurs graphiques d‚Äôun seul coup rassembl√©s en une seule figure. Consultez le satellite sur le faceting si vous voulez en savoir plus.\n\ndata_alerte |&gt;\n  filter(zone_sante %in% zone_sante_alertee) |&gt;\n  ggplot(aes(x = semaine, \n             y = totalcas)) + \n  geom_col(fill = \"#2E4573\") + \n  theme_bw(base_size = 16) + \n  labs(x = \"Semaine\",\n       y = \"N cas\",\n       title = \"Zone de sant√© de Kampemba (en alerte)\") +\n  facet_wrap(vars(zone_sante))   # Un graphe par zone de sant√©"
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#indicateurs-cl√©s-question-6",
    "href": "sessions_extra/surveillance_companion.html#indicateurs-cl√©s-question-6",
    "title": "Surveillance",
    "section": "Indicateurs cl√©s (Question 6)",
    "text": "Indicateurs cl√©s (Question 6)\nNous pouvons calculer plus d‚Äôindicateurs sur les zones de sant√© pour nous aider √† d√©cider laquelle devrait faire l‚Äôobjet d‚Äôune enqu√™te (vu que vous n‚Äôavez pas le temps ni les ressources pour investiguer les deux).\n\n\n\n\n\n\nAstuce\n\n\n\nCette partie utilise les fonctions d‚Äôaggr√©gation vues quand nous avons appris √† faire des tableaux r√©sum√©s. N‚Äôh√©sitez pas √† vous rafra√Æchir si besoin.\n\n\n\nPremi√®re semaine en alerte\n\nUtilisez la fonction summarize() pour afficher les premi√®res semaines o√π les ZS sont pass√©es en alerte. Quelle zone de sant√© a √©t√© en alerte en premier ?\n\n\n\nIndicateurs des donn√©es de surveillance\nReprenons le jeu de donn√©es de surveillance avec toutes les colonnes, df_surv.\n\n\nAjoutez-lui une colonne cas_moins_5ans qui contient le nombre total de cas rapport√©s ayant moins de cinq ans.\nD√©rivez, pour chaque zone en alerte, les indicateurs suivants, organis√©s en un seul tableau :\n\n\nLe nombre de cas\nLe nombre de morts\nLe nombre de moins de cinq ans\nLa mortalit√© en pourcentage\nLe pourcentage de moins de cinq ans.\n\nLe r√©sultat ressemble √† :\n\n\n  zone_sante n_cas n_deces n_moins_5 p_moins_5 mortalite\n1   kampemba   730       0       544  74.52055   0.00000\n2     lwamba   256       2       233  91.01562   0.78125\n\n\n\n\n\nIndicateurs des donn√©es labo\nInt√©ressons-nous √† pr√©sent aux donn√©es de laboratoire pour compl√©ter les indicateurs pr√©c√©dents.\n\nPour chacune des zones en alerte, d√©rivez les indicateurs suivants :\n\nLe nombre de patients test√©s pour la rougeole\nLe nombre de positifs pour la rougeole\nLa proportion de positifs pour la rougeole\nLe nombre de patients test√©s pour la rub√©ole\nLe nombre de positifs pour la rub√©ole\nLa proportion de positifs pour la rub√©ole\n\nLe r√©sultat devrait ressembler √† ceci :\n\n\n  zone_sante n_test_roug n_test_roug_pos positivite_roug n_test_rub\n1     lwamba          10               5       0.5000000         10\n2   kampemba          14               4       0.2857143         14\n  n_test_rub_pos positivite_rub\n1              0     0.00000000\n2              1     0.07142857\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nSi vous avez du mal avec cette question, rafra√Æchissez-vous sur les r√©sum√©s conditionnels."
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#cest-fini",
    "href": "sessions_extra/surveillance_companion.html#cest-fini",
    "title": "Surveillance",
    "section": "C‚Äôest fini !",
    "text": "C‚Äôest fini !\nBravo, vous √™tes venus √† bout de ce tutoriel !\n\n\n\n Solutions"
  },
  {
    "objectID": "sessions_extra/surveillance_companion.html#sec-going-further",
    "href": "sessions_extra/surveillance_companion.html#sec-going-further",
    "title": "Surveillance",
    "section": "Aller plus loin",
    "text": "Aller plus loin\n\nExplications sur complete()\nDans le mini exemple ci-dessous la zone de sant√© de Kitenge n‚Äôa pas de ligne pour la semaine 2 :\n\n# Data frame simplifi√©, avec seulement trois semaines\nexemple_df = data.frame(\n  province   = c(\"haut_katanga\", \"haut_katanga\", \"haut_katanga\", \"haut_lomami\", \"haut_lomami\"),\n  zone_sante = c(\"likasi\", \"likasi\", \"likasi\", \"kitenge\", \"kitenge\"),\n  semaine    = c(1, 2, 3, 1, 3),\n  totalcas  = c(2, 1, 3, 1, 2))\n\nexemple_df\n\n      province zone_sante semaine totalcas\n1 haut_katanga     likasi       1        2\n2 haut_katanga     likasi       2        1\n3 haut_katanga     likasi       3        3\n4  haut_lomami    kitenge       1        1\n5  haut_lomami    kitenge       3        2\n\n\nNous pouvons utiliser le code suivant pour compl√©ter toutes les zones de sant√© pour qu‚Äôelles aient toutes les semaines possible, ici les semaine de un √† trois :\n\n# Compl√©te la semaine manquante √† Kitenge\nexemple_df |&gt; \n  complete(\n    nesting(province, zone_sante), \n    semaine = seq(1, 3),            # Vecteur de 1 √† 3\n    fill = list(totalcas = 0)       # Remplir avec des z√©ros (sinon, NA par d√©faut)\n  ) \n\n# A tibble: 6 √ó 4\n  province     zone_sante semaine totalcas\n  &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 haut_katanga likasi           1        2\n2 haut_katanga likasi           2        1\n3 haut_katanga likasi           3        3\n4 haut_lomami  kitenge          1        1\n5 haut_lomami  kitenge          2        0\n6 haut_lomami  kitenge          3        2\n\n\nMaintenant les deux zones de sant√© dans les deux provinces ont toutes les semaines possibles.\nVous vous demandez peut √™tre pourquoi nous avons √©crit nesting(province, zone_sante) au lieu de juste zone_sante. La raison est qu‚Äôil peut y avoir deux zones de sant√© avec le m√™me nom dans des provinces diff√©rentes. Nous devons donc tenir compte de la colonne province. L‚Äôargument nesting() indique √† la fonction de n‚Äôutiliser que les combinaisons existantes des deux colonnes dans le data frame.\n\n\n\n\n\n\nNote\n\n\n\nPetit encart pour voir ce qui se serait pass√© si nous avions pass√© les deux colonnes √† la fonction complete() sans utiliser nesting() : la fonction aurait cr√©√© toutes les combinaisons possibles entre les cat√©gories des colonnes province et zone_sante, ce qui n‚Äôa pas de sens dans notre cas.\n\nexemple_df |&gt; \n  complete(\n    province, zone_sante, \n    semaine = seq(1, 3),  # Vecteur de 1 √† 3\n    fill = list(totalcas = 0)\n  ) \n\n# A tibble: 12 √ó 4\n   province     zone_sante semaine totalcas\n   &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n 1 haut_katanga kitenge          1        0\n 2 haut_katanga kitenge          2        0\n 3 haut_katanga kitenge          3        0\n 4 haut_katanga likasi           1        2\n 5 haut_katanga likasi           2        1\n 6 haut_katanga likasi           3        3\n 7 haut_lomami  kitenge          1        1\n 8 haut_lomami  kitenge          2        0\n 9 haut_lomami  kitenge          3        2\n10 haut_lomami  likasi           1        0\n11 haut_lomami  likasi           2        0\n12 haut_lomami  likasi           3        0\n\n\n\n\nComme la base de donn√©es va √™tre mise √† jour chaque semaine, il serait pratique de choisir automatiquement la plage des semaines qui doivent √™tre pr√©sentes dans les donn√©es. Pour √ßa, il nous suffit de remplacer les valeurs que nous avons cod√© en dur par la plus petite semaine existante dans les donn√©es et la plus grande :\n\nexemple_df |&gt; \n  complete(\n    nesting(province, zone_sante),\n    semaine = seq(min(semaine, na.rm = TRUE),   # Vecteur allant du minimum\n                  max(semaine, na.rm = TRUE)),  # au maximum de la colonne `semaine`\n    fill = list(totalcas = 0)\n  ) \n\n# A tibble: 6 √ó 4\n  province     zone_sante semaine totalcas\n  &lt;chr&gt;        &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 haut_katanga likasi           1        2\n2 haut_katanga likasi           2        1\n3 haut_katanga likasi           3        3\n4 haut_lomami  kitenge          1        1\n5 haut_lomami  kitenge          2        0\n6 haut_lomami  kitenge          3        2\n\n\n\n\nExplications sur rollaply()\nPour calculer la somme cumul√©e des cas sur trois semaine il nous faut appliquer (apply en anglais) la fonction sur des fen√™tres glissantes de trois semaines.\n\n# Vecteur pour les exemples\nexemple_vect &lt;- rep(1, time = 10)\nexemple_vect\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\nrollapply(\n  data  = exemple_vect,\n  width = 3,       # Largeur de la fen√™tre\n  FUN   = sum,     # Fonction √† appliquer (ici, la somme)\n  align = \"right\"  # Calcul dans le pass√©\n)\n\n[1] 3 3 3 3 3 3 3 3\n\n\nNous avons fourni en entr√©e un vecteur de 10 valeurs et obtenu en sortie un vecteur contenant les sommes. Manifestement, la fonction a fait des choix sur comment traiter les extr√©mit√©s, et le r√©sultat est plus court que le vecteur d‚Äôentr√©. Ce dernier point est un probl√®me si l‚Äôon veut utiliser la fonction dans un mutate(), qi cr√©e des colonnes dans un data frame, o√π toutes les colonnes ont la m√™me taille.\nIl est possible de contr√¥ler le comportement de la fonction aux extr√©mit√©s :\n\nRemplir les valeurs pour lesquelles il n‚Äôy a pas assez de valeur dans la fen√™tre avec des NA\nAutoriser des calculs partiels (ici, des sommes partielles, en d‚Äôautres termes des valeurs ne repr√©sentent pas la somme sur trois semaines).\n\nL‚Äôargument fill = NA remplit les valeurs manquantes aux extr√©mit√©s concern√©es avec des NA (dans notre cas, √† gauche, vu que l‚Äôon a align√© la fen√™tre √† droite) :\n\nrollapply(\n  data  = exemple_vect,\n  width = 3,       # Largeur de la fen√™tre\n  FUN   = sum,     # Fonction √† appliquer (ici, la somme)\n  align = \"right\", # Calcul dans le pass√©\n  fill  = NA\n)\n\n [1] NA NA  3  3  3  3  3  3  3  3\n\n\nC‚Äôest souvent une fa√ßon raisonnable de g√©rer les valeurs aux extr√©mit√©s o√π les fen√™tres ne sont pas compl√®tes. N√©anmoins, dans notre cas, nous pouvons faire mieux. En effet, imaginons qu‚Äôil y ait 40 cas lors de la premi√®re semaine : m√™me si nous n‚Äôavons pas de valeurs pour les deux semaines pr√©c√©dentes, l‚Äôalerte devrait √™tre d√©clench√©e ! Nous voudrions donc que la somme cumul√©e soit calcul√©e d√®s la premi√®re semaine pour pouvoir d√©tecter des alertes pr√©coces ! L‚Äôargument partial = TRUE permet cela :\n\nrollapply(\n  data    = exemple_vect,\n  width = 3,        # Largeur de la fen√™tre\n  FUN   = sum,      # Fonction √† appliquer (ici, la somme)\n  align = \"right\",  # Calcul dans le pass√©\n  partial = TRUE    # Autorise les sommes partielles aux extr√©mit√©s\n  )\n\n [1] 1 2 3 3 3 3 3 3 3 3\n\n\nC‚Äôest mieux comme √ßa pour notre cas d‚Äôusage.\n\n\n\n\n\n\nImportant\n\n\n\nGardez √† l‚Äôesprit que les deux premi√®res valeurs du vecteur (ou de la colonne) contiennent donc des sommes partielles. En cons√©quence, une absence d‚Äôalerte dans les deux premi√®res semaines ne veut pas forcement dire grand chose.\n\n\nUn dernier point : rappelez-vous qu‚Äôil faut utiliser na.rm = TRUE pour ignorer les valeurs manquantes dans la plupart des op√©rations arithm√©tiques dans R.\nSi nous avions un vecteur un peu moins complet, nous aurions des probl√®mes :\n\nexemple_vect_na &lt;- c(1, 1, 1, NA, 1, 1)\n\nrollapply(\n  data  = exemple_vect_na,\n  width = 3,       # Largeur de la fen√™tre\n  FUN   = sum,     # Fonction √† appliquer (ici, la somme)\n  align = \"right\", # Calcul dans le pass√©\n  partial = TRUE   # Autorise les sommes partielles aux extr√©mit√©s\n)\n\n[1]  1  2  3 NA NA NA\n\n\nOups. Heureusement, nous pouvons passer l‚Äôargument na.rm = TRUE √† la fonction rollapply() pour qu‚Äôelle le passe √† la fonction sum().\n\nrollapply(\n  data  = exemple_vect_na,\n  width = 3,       # Largeur de la fen√™tre\n  FUN   = sum,     # Fonction √† appliquer (ici, la somme)\n  align = \"right\", # Calcul dans le pass√©\n  partial = TRUE,  # Autorise les sommes partielles aux extr√©mit√©s\n  na.rm = TRUE     # Argument en plus non nomm√© √† passer √† sum()\n)\n\n[1] 1 2 3 2 2 2\n\n\nEnfin, quelues mots sur l‚Äôargument align. Il d√©finit la position de la fen√™tre glissante par rapport √† la valeur en train d‚Äô√™tre calcul√©e. Par d√©faut la fen√™tre est centr√©e autour de la valeur √† cacluler : la valeur calcul√©e i est la somme des valeurs i-1 (la valeur pr√©c√©dente) et la valeur i+1 (la valeur suivante).\nExemples des trois alignements (en mettant des valeurs manquantes aux extr√©mit√©s pour voir plus facilement ce qui se passe) :\n\n# Alignement √† gauche : la valeur est la somme des valeurs dans le futur\nrollapply(data  = c(5, 10, 1, 2, 5, 10),\n          width = 3, \n          FUN   = sum,\n          align = \"left\", \n          fill = NA)\n\n[1] 16 13  8 17 NA NA\n\n# Alignement centr√© : somme des valeurs de chaque c√¥t√©\nrollapply(data  = c(5, 10, 1, 2, 5, 10),\n          width = 3, \n          FUN   = sum,\n          align = \"center\",\n          fill = NA)  # The default\n\n[1] NA 16 13  8 17 NA\n\n# Alignement √† droite : somme des valeurs pass√©es jusqu'√† pr√©sent\nrollapply(data  = c(5, 10, 1, 2, 5, 10),\n          width = 3, \n          FUN   = sum,\n          align = \"right\",\n          fill = NA)\n\n[1] NA NA 16 13  8 17\n\n\nDans notre cas, nous voulons que la valeur pour une semaine donn√©e refl√®te cette semaine et les deux semaines pr√©c√©dentes, donc nous utilisons l‚Äôargument align = \"right\", pour calculer dans le pass√©.\n\n\n\n\n\n\nAstuce\n\n\n\nDans ce tutoriel nous avons appliqu√© la fonction sum() √† des fen√™tres de trois semaines pour calculer une somme cumul√©e. Mais le code peut √™tre facilement modifi√© pour calculer une moyenne glissante sur une fen√™tre de votre choix !\n\n\n\n\nFormatage des pourcentages\nLa fonction percent() du paquet {scales} formate une valeur ou un vecteur de valeurs en pourcentages.\n\nscales::percent(0.8556)\n\nIl y a un argument accuracy pour contr√¥ler le nombre de d√©cimales √† afficher :\n\nscales::percent(0.8556,\n                accuracy = 0.1)\n\nVous pouvez fournir un vecteur (ou une colonne !) de proportions √† la fonction pour afficher les valeurs en pourcentages, ce qui est plus lisible dans un tableau r√©sum√©.\n\n\n\n\n\n\nImportant\n\n\n\nLa colonne ainsi cr√©e n‚Äôest plus une colonne num√©rique : l‚Äôajout du signe % transforme la colonne en texte. Vous ne pourrez donc plus effectuer d‚Äôop√©rations arithm√©tiques dessus."
  }
]