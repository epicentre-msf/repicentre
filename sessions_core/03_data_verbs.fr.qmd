---
title: Manipulation de données de base
description: Une introduction à la manipulation et au nettoyage des données en utilisant `{dplyr}`.
date: last-modified
image: ../img/under_construction.svg
categories:
  - Core
  - Manipulation des données
  - Nettoyage des données
---

```{r setup}
#| include: false
#| echo: false
#| eval: true
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

library(dplyr)

df_raw <- rio::import(here::here('data', 'raw', 'moissala_linelist_EN.xlsx'))
```


Objectifs
----------------------------------------------------------------------------------------------------
- Apprendre les verbes de données de base de `{dplyr}` pour :
  - Sélectionner des colonnes spécifiques (`select()`)
  - Renommer des colonnes (`rename()`)
  - Ajouter de nouvelles colonnes et modifier les colonnes existantes (`mutate()`)
  - Supprimer les observations en double
- Comprendre l'opérateur de tuyauterie `|>`


Mise en place
----------------------------------------------------------------------------------------------------
**Cette session suppose que vous savez comment utiliser RStudio et que vous êtes capable d'importer des données. Si vous avez besoin d'un rafraîchissement sur l'un ou l'autre de ces sujets, nous vous encourageons à revoir les [deux premières sessions du parcours d'apprentissage] (https://epicentre-msf.github.io/repicentre/pathway.html).


::: {.setup}
Cette session travaillera avec les données **raw** Moissala linelist, qui peuvent être téléchargées ici :

```{r}
#| echo : false
#| eval : true

downloadthis::download_link(
  link = 'https://github.com/epicentre-msf/repicentre/raw/refs/heads/main/data/raw/moissala_linelist_EN.xlsx',
  button_label = ' Télécharger les données',
  has_icon = TRUE,
  icon = « fa fa-save »,
  self_contained = FALSE
)
```
<br>
Make sure this dataset is saved into the appropriate subdirectory of your R project and create a new script called `data_verbs_practice.R` in your `R` directory. Add an appropriate header and load the following packages: `{here}`, `{rio}`, and `{tidyverse}`.
<br><br>
Finally, add an import section where you use `{here}` and `{rio}` to load your data into an object called [`df_raw`]{.hovertip bs-toggle='tooltip' bs-title="Note, that we are calling this our raw data, not `df_linelist` as we did previously. You will see why later."}.
:::


Manipulating Data with `{dplyr}`
----------------------------------------------------------------------------------------------------
Now that we know how to set up a project and import data, we can finally start to play around with it. Going forward we will be using several packages from the « [tidyverse]{.hovertip bs-toggle=“tooltip” bs-title= »The tidyverse is a collection of packages that are designed for maximum human readability and user friendliness. Check out their website for more information on what's available.« } » to help us manipulate, summarize, and visualize our data. La session d'aujourd'hui se concentrera sur la manipulation de données à l'aide d'un paquetage appelé `{dplyr}`.

### Qu'est-ce que `{dplyr}` ?
La manipulation des données est la base de [travailler avec des données dans R]{.hovertip bs-toggle='tooltip' bs-title=« Or really any other language, including Excel ! »} et, en tant que telle, elle est fondamentale pour le travail que nous effectuons en tant qu'épidémiologistes. En particulier, les compétences en matière de manipulation de données seront essentielles pour essayer de nettoyer nos données. 

Dans R, le paquetage `{dplyr}` fournit un grand nombre de fonctions pour nous aider à manipuler les cadres de données et à effectuer de nombreuses tâches que nous devrons utiliser quotidiennement, par exemple :

- Sous-ensemble de nos données pour supprimer certaines [variables]{.hovertip bs-toggle='tooltip' bs-title=« Rappelez-vous que chaque variable est une colonne dans le contexte d'un cadre de données »}
- Renommer certaines variables
- Ajouter ou modifier une variable
- Supprimer les entrées en double

Dans `{dplyr}`, chacune de ces actions peut être effectuée à l'aide d'une fonction particulière, qui a généralement un [verbe intuitif pour un nom]{.hovertip bs-toggle='tooltip' bs-title=« Ces verbes, comme tout ce qui est dans R, sont en anglais et seront, il est vrai, moins intuitifs pour les apprenants venant d'un milieu non-anglophone. »}. Par exemple, pour renommer des colonnes, on utilisera la fonction `rename()`.

Dans la session d'aujourd'hui, nous examinerons le « verbe de manipulation des données », c'est-à-dire la fonction, nécessaire pour chacune des tâches ci-dessus, ainsi que la manière de les enchaîner dans un pipeline de données efficace.


:::{.callout-note}
Vous avez peut-être remarqué que nous vous avons demandé de charger un paquetage appelé `{tidyverse}` plutôt que `{dplyr}` dans l'installation. Charger `{tidyverse}` chargera [plusieurs des paquets les plus utiles]{.hovertip bs-toggle='tooltip' bs-title="The tidyverse is pretty big and loading *all* of it's contents would be impractical for most projects. Le paquet `{tidyverse}` ne charge donc que les paquets 'core' les plus utiles de la collection complète."} de l'ensemble de tidyverse, y compris `{dplyr}` et quelques autres paquets que nous verrons plus tard dans la session.
:::



Données de base Verbes
----------------------------------------------------------------------------------------------------

### Sélectionner des colonnes spécifiques
La plupart du temps, lorsque nous recevons un ensemble de données, il comporte des colonnes supplémentaires dont nous n'avons pas besoin, soit parce que ces colonnes contiennent des [données sensibles]{.hovertip bs-toggle='tooltip' bs-title=« Comme les noms de patients, par exemple »} soit parce que notre analyse ne portera que sur un sous-ensemble des données. C'est là qu'une fonction comme `select()` s'avère utile.

Voici la syntaxe de base, notez qu'il s'agit de [pseudo-code]{.hovertip bs-toggle='tooltip' bs-title="Le pseudo-code est utilisé pour montrer la syntaxe du modèle mais n'est pas conçu pour être réellement exécuté. Il utilise souvent des noms de substitution comme `column_name` pour illustrer un concept. Dans cette session et les suivantes, nous utiliserons souvent du pseudo-code pour démontrer la syntaxe de base des nouvelles fonctions au fur et à mesure de leur introduction. »} et n'est pas destiné à être exécuté par vous-même.

```{r}
# NE PAS EXÉCUTER (PSEUDO-CODE)
select(df_raw, first_column_to_keep, second_column_to_keep)
```

Ici, nous voyons que le premier argument est notre ensemble de données et que chaque argument suivant est le nom d'une colonne que nous aimerions conserver. Dans le tidyverse, les variables (c'est-à-dire les noms de colonnes) n'ont pas besoin d'être mises entre guillemets. Ainsi, par exemple, si nous voulons sélectionner les colonnes id, sex et age, nous pouvons utiliser ce qui suit :

```{r}
select(df_raw, id, sex, age)
```

:::{.write}
Utilisez `select()` pour sélectionner les variables suivantes dans votre ensemble de données : `id`, `sex`, `age`, `sub_prefecture`, `date_onset` et `outcome`. L'en-tête de votre sortie devrait ressembler à ceci :

```{r}
#| eval: true
#| echo: false
head(select(df_raw, id, sex, age, date_onset, outcome))
```
<br>
Regardez ce résultat, puis `df_raw`. Nous pouvons voir que `df_raw` contient toujours toutes les colonnes, ce qui est ce que nous voulons. Mais pouvez-vous dire pourquoi il n'a pas changé ?
:::

Souvent, nous voulons conserver la plupart des variables de notre ensemble de données et n'en supprimer qu'une ou deux. Nous pouvons utiliser la syntaxe ci-dessus pour ce faire, mais cela peut devenir assez fastidieux de [écrire le nom de chaque colonne]{.hovertip bs-toggle='tooltip' bs-title=« Quiconque a travaillé avec des listes de lignes complexes ou des données d'enquête peut certainement en ressentir les effets. »}. Dans ces cas, au lieu de dire `sélectionner ce qu'il faut **garder**, nous pouvons utiliser un signe de soustraction (`-`) pour lui dire ce qu'il faut **supprimer**. Par exemple, si nous voulons supprimer la colonne `village_commune` de notre dataframe, nous pouvons utiliser ce qui suit :

```{r}
select(df_raw, -village_commune)
```

Beaucoup plus facile !

:::{.write}
Utilisez la syntaxe `-` dans `select()` pour sélectionner toutes les colonnes de `df_raw` **à l'exception de** : [`full_name`]{.hovertip bs-toggle='tooltip' bs-title=« En général, les noms complets et autres informations identifiables doivent être immédiatement supprimés lorsque vous travaillez avec des données de type liste de lignes. »} et `age_unit` de votre ensemble de données.
:::

### Renommer les colonnes
Un autre problème courant lorsque nous obtenons de nouveaux ensembles de données est que les noms de variables sont [incommodes]{.hovertip bs-toggle='tooltip' bs-title=« Cela peut être dû au fait qu'ils sont trop longs, ou pire, qu'ils contiennent des espaces ou des accents »}. Dans ces cas, `rename()` peut faire des merveilles. Voici la syntaxe de base :

{r}
# NE PAS EXÉCUTER (PSEUDO CODE)
rename(df,
       new_column_name = old_column_name,
       another_new_name = another_old_name)
```

Comme dans le cas de select(), et en fait dans pratiquement tous les verbes {dplyr}, le premier argument est notre daframe. Ensuite, chaque argument suivant est une instruction `new_column_name = old_column_name` indiquant à R les colonnes à renommer et les nouveaux noms que nous voulons utiliser, chaque paire ayant sa propre ligne pour améliorer la lisibilité. Si nous voulions changer `village_commune` en simplement `village`, par exemple, nous pouvons écrire :

```{r}
rename(df_raw,
       village = village_commune)
```

:::{.write}
Utilisez `rename()` sur `df_raw` pour changer les colonnes `sub_prefecture`, `village_commune` et `health_facility_name` en `prefecture`, `village` et `facility` respectivement.
:::

Dans l'exercice ci-dessus, il a peut-être été difficile de vérifier si le résultat semblait correct car R aurait imprimé le cadre de données complet. Dans ces cas, il peut être utile de créer un objet temporaire juste pour vérifier si tout semble correct. Vous pouvez appeler cet objet comme vous le souhaitez, mais un nom courant est [tmp]{.hovertip bs-toggle='tooltip' bs-title=« Ici, tmp signifie « temporaire ». »}.

:::{.write}
Répétez le dernier exercice, mais cette fois-ci, affectez la sortie à un objet appelé `tmp` et utilisez `names()` pour vérifier que les noms des colonnes ont changé comme prévu. La sortie de `names()` devrait vous donner quelque chose comme ceci :

```{r}
#| eval: true
#| echo: false

df_raw |>
rename(prefecture = sub_prefecture,
       village = village_commune,
       facility = health_facility_name) |>
       names()
```
:::

:::{.callout-important}
Les objets temporaires, comme le data frame `tmp` que vous venez de créer, sont justement temporaires. Ils sont généralement utilisés pour tester si quelque chose a fonctionné et sont conçus pour être écrasés chaque fois que vous avez besoin de tester autre chose. En tant que tels, vous ne devez pas utiliser ces objets temporaires comme entrée pour d'autres parties de votre code. Si vous souhaitez créer un data frame qui sera réutilisé, comme une version propre de `df_raw`, vous devez utiliser un objet portant un nom approprié, comme `df` ou `df_clean`.
:::

### Modifier et ajouter des colonnes
Nous savons maintenant comment sélectionner et renommer des colonnes, mais comment les modifier ? C'est là que [mutate()] entre en jeu. Cette fonction peut être utilisée à la fois pour ajouter de nouvelles colonnes et pour modifier des colonnes existantes.

Commençons par la syntaxe de base de `mutate()` nécessaire pour ajouter une nouvelle colonne :

```{r}
# NE PAS EXÉCUTER (PSEUDO-CODE)
mutate(df,
       new_column = action(existing_column),
       another_new_column = another_action(another_existing_column))
```

Dans le code ci-dessus, nous créons une nouvelle colonne (`new_column`) en effectuant une sorte d'action (`action()`) sur une colonne existante dans le dataframe (`existing_column`). Cette action peut être n'importe quoi, elle peut utiliser une fonction ou être une simple opération arithmétique et peut utiliser une ou plusieurs colonnes. Par exemple, si nous voulions créer une nouvelle colonne exprimant [MUAC en cm]{.hovertip bs-toggle='tooltip' bs-title=« Il s'agit évidemment d'un indicateur dont vous n'auriez probablement pas besoin dans la pratique, mais qui est utilisé ici juste pour illustrer l'utilisation de mutate(). »} nous pourrions utiliser ce qui suit :

```{r}
mutate(df_raw,
muac_cm = muac / 100)
```

:::{.write}
Utilisez mutate() pour créer une nouvelle colonne appelée age_years qui exprime l'âge en années plutôt qu'en mois. L'en-tête de votre nouvelle colonne age_years devrait ressembler à ceci :

```{r}
#| eval: true
#| echo: false
df_raw |>
  mutate(age_years = age / 12) |>
  select(age_years) |>
  head()
```
:::

Super ! Mais que se passe-t-il si, au lieu de créer une nouvelle colonne, nous voulons en modifier une existante ? Il suffit d'utiliser le nom de la colonne existante à gauche du `=` au lieu de donner un nouveau nom de colonne. Par exemple, dans le code MUAC ci-dessus, nous écririons :

```{r}
mutate(df_raw,
       muac = muac / 100)
```

Nous pourrions vouloir conserver l'âge en mois ainsi qu'en années, donc nous ne réattribuerons pas cette colonne. Mais il y a d'autres colonnes qui pourraient être modifiées. Il y a de nombreuses raisons pour lesquelles nous pourrions vouloir modifier une colonne, les deux plus courantes étant :

1. Le format d'une chaîne de caractères doit être modifié
2. Le type de données d'une colonne est incorrect

Notre ensemble de données présente ces deux problèmes. Par exemple, bien que ce ne soit pas en soi un problème que `region` et `sub_prefecture` soient en majuscules, ce n'est pas non plus [particulièrement agréable] {.hovertip bs-toggle='tooltip' bs-title=« De plus, l'incohérence dans l'utilisation des majuscules est un type de saleté courant dans les ensembles de données et la normalisation en mettant tout en minuscules ou en majuscules peut être un élément utile du nettoyage. »}. Pour corriger cela, nous pouvons utiliser une autre fonction de {tidyverse}, cette fois-ci d'un package appelé {stringr} pour mettre ces colonnes en [majuscules initiales] {.hovertip bs-toggle='tooltip' bs-title=« Les majuscules initiales sont utilisées lorsque la première lettre de chaque mot est en majuscule, comme dans le titre d'un livre. »} :

```{r}
mutate(df_raw,
       region = str_to_title(region),
       sub_prefecture = str_to_title(sub_prefecture))
```

:::{.write}
Utilisez `mutate()` pour mettre à jour le format de `malaria_rdt` et `outcome` afin d'utiliser la casse des titres. L'en-tête de ces deux colonnes devrait maintenant ressembler à ceci :

```{r}
#| eval: true
#| echo: false

df_raw |>
  mutate(malaria_rdt = stringr::str_to_title(malaria_rdt),
  outcome = stringr::str_to_title(outcome)) |>
  select(malaria_rdt, outcome) |>
  head()
```
:::

:::{.callout-note}
Notez que nous n'avons pas eu besoin de charger {stringr} pour faire l'exercice ci-dessus. En effet, comme {dplyr}, ce package est chargé lorsque nous chargeons {tidyverse}.
:::


C'est plus agréable. Maintenant, considérons le deuxième problème, celui des variables de mauvais type.

:::{.look}
Regardez le type de données de vos colonnes, est-ce que l'une d'entre elles vous semble étrange ? 
<br><br>
**Indice.** `str()` peut être utile ici.
:::

La plupart des colonnes semblent correctes, mais il y a quelque chose d'étrange avec les dates. Certaines sont de type caractère et d'autres sont appelées [POSIXct]{.hovertip bs-toggle='tooltip' bs-title=« Il s'agit d'un type de données en R qui est parfois utilisé pour exprimer des dates. Ce n'est pas la manière la plus pratique de gérer les dates, bien que les raisons en soient un peu en dehors du cadre de ce cours. En général, nous recommandons de convertir POSIXct en Date chaque fois que l'on travaille avec des dates. »}. Nous préférerions de loin que toutes ces colonnes utilisent le type simple `Date`. 

Pour convertir en dates, nous allons faire appel à [un autre package du tidyverse, `{lubridate}`]{.hovertip bs-toggle='tooltip' bs-title=« Comme vous pouvez le voir, le tidyverse contient de nombreux packages pratiques pour nous faciliter la vie en tant qu'épidémiologistes. »}. En particulier, nous allons utiliser la fonction [`ymd()`]{.hovertip bs-toggle='tooltip' bs-title=« Ici, le nom de la fonction indique qu'elle attend que les dates soient formatées en année-mois-jour. D'autres fonctions sont disponibles dans {lubridate} pour les dates qui sont construites différemment. »}. Par exemple :

```{r}
mutate(df_raw,
       date_outcome = ymd(date_outcome))
```

:::{.write}
Utilisez mutate() et ymd() pour modifier date_onset et date_admission afin qu'ils soient de type Date. Utilisez un data frame temporaire tmp pour vérifier que votre code fait ce que vous voulez qu'il fasse.
:::


### Supprimer les doublons
Parfait ! Nous savons comment sélectionner, renommer et modifier nos données. Une autre tâche que nous devrons souvent effectuer est la suppression des entrées en double. Heureusement, celle-ci est facile à réaliser à l'aide de la fonction `distinct()`, dont la syntaxe de base est la suivante :

```{r}
# NE PAS EXÉCUTER (PSEUDO-CODE)
distinct(df)
```

Notez que distinct n'a besoin que d'un seul argument par défaut, le jeu de données lui-même. Cela permettra de rechercher et de supprimer toutes les observations en double dans le data frame. Il existe des moyens plus sophistiqués d'utiliser distinct() qui rechercheront les doublons sur certaines variables uniquement, mais cela dépasse le cadre de la session d'aujourd'hui.

:::{.write}
Utilisez `distinct()` pour créer un data frame temporaire, `tmp`, qui contient toutes les observations uniques dans `df_raw`. Comparez le nombre de lignes dans `tmp` à celui de `df_raw`. Avons-nous des doublons ?
:::



L'opérateur Pipe
----------------------------------------------------------------------------------------------------
Il semble donc que nous ayons fait pas mal de nettoyage tout en apprenant les principaux verbes de `{dplyr}`. Nous devrions probablement essayer de rassembler certaines des étapes ci-dessus pour commencer à construire un pipeline de nettoyage de données de base. Jusqu'à présent, nous n'avons enregistré aucune de nos modifications, sauf peut-être dans un data frame temporaire. Il serait bien de les conserver dans un nouvel objet `df` propre.

Par exemple, si nous voulons appliquer le changement de nom de colonne que nous avons effectué ci-dessus à un objet réutilisable, nous pourrions écrire quelque chose comme ceci :

```{r}
df <- rename(df_raw, 
             prefecture = sub_prefecture,
             village = village_commune,
             facility = health_facility_name)
```


:::{.callout-tip}
En général, il est recommandé de conserver une version brute de votre ensemble de données, ici `df_raw`, qui reste inchangée dans votre code. Ainsi, vous l'avez toujours à disposition dans votre environnement comme référence et elle est toujours disponible au début de votre pipeline de nettoyage pour améliorer la reproductibilité.
:::


Nous avons maintenant un nouvel objet, `df`, sur lequel nous pouvons effectuer d'autres opérations. Génial. Par exemple, si nous voulions maintenant tout sélectionner sauf `full_name`, nous pourrions mettre à jour le code ci-dessus comme ceci :

```{r}
# Étape 1 : Renommer les variables
df <- rename(df_raw, 
             prefecture = sub_prefecture,
             village = village_commune,
             facility = health_facility_name)

# Étape 2 : Sélectionner les variables à conserver
df <- select(df,
             -full_name)
```

Notez que dans cette deuxième étape, nous utilisons `df` comme entrée de `select()` plutôt que `df_raw` car nous voulons continuer à travailler sur notre version modifiée des données. Supposons maintenant que nous voulions ajouter une colonne d'âge en années :

```{r}
# Étape 1 : Renommer les variables
df <- rename(df_raw, 
             prefecture = sub_prefecture,
             village = village_commune,
             facility = health_facility_name)

# Étape 2 : Sélectionner les variables à conserver
df <- select(df,
             -full_name)

# Étape 3 : Ajouter l'âge en années
df <- mutate(df,
             age_years = age / 12)
```

Hum, ok, ça fonctionne, mais ça commence à devenir répétitif. À chaque étape, nous réutilisons le résultat de la précédente, puis nous mettons à jour le même data frame, `df`. Il serait préférable de pouvoir enchaîner ces actions de manière plus simple. 

C'est exactement à cela que sert l'opérateur pipe, `|>` ! La syntaxe de base du pipe est la suivante :

```{r}
# NE PAS EXÉCUTER (PSEUDO-CODE)
input |> action()
```

Ici, l'entrée à gauche (input) est « canalisée » vers l'action à droite (action()). Ainsi, par exemple, au lieu d'écrire :

```{r}
select(df_raw, id, sex)
```

nous pourrions écrire :

```{r}
df_raw |>
  select(id, sex)
```

:::{.write}
Essayez le code ci-dessus pour voir s'il fonctionne.
:::

Cela peut être utilisé pour enchaîner plusieurs actions et vous verrez souvent du code de style tidyverse qui utilise des pipes de la manière suivante :

```{r}
# NE PAS EXÉCUTER (PSEUDO-CODE)
df <- df_raw |>
  première_action() |>
  deuxième_action() |>
  troisième_action()
```

:::{.callout-tip}
Notez qu'ici, chaque action dans le pipe se voit attribuer sa propre ligne. C'est considéré comme une bonne pratique car cela rend votre code plus facile à lire et à comprendre.
:::

Donc, si nous voulions enchaîner les actions de l'exemple que nous avons vu ci-dessus en un seul pipe, nous pourrions écrire quelque chose comme ceci :

```{r}
df <- df_raw |>
  rename(prefecture = sub_prefecture,
  village = village_commune,
  facility = health_facility_name) |>
  select(-full_name) |>
  mutate(age_years = age / 12)
```

C'est beaucoup plus facile que de réaffecter `df` après chaque étape ! 

::{.write}
Voyons si nous pouvons rassembler ce que nous avons appris ci-dessus dans un seul pipeline ! Utilisez l'opérateur de pipeline « |> », « select() », « rename() », « mutate() », « str_to_title() », « ymd() » et « distinct() » pour effectuer les actions suivantes sur « df_raw » et affecter la sortie à un nouveau data frame appelé « df » :

- Supprimer les variables `full_name` et `age_unit`
- Renommer les variables suivantes :
- `age` devient `age_months`
- `sub_prefecture` devient `prefecture`
- `village_commune` devient `village`
- `health_facility_name` devient `facility`
- Ajouter une variable `age_years` avec l'âge du patient en années
- Mettre à jour `region` et `prefecture` pour utiliser la casse du titre
- Mettre à jour toutes les colonnes de date pour utiliser le type `Date`
- Supprimer toutes les observations en double

L'en-tête de vos données finales devrait ressembler à ceci :

```{r}
#| eval: true
#| echo: false

df_raw |>
  select(-full_name, -age_unit) |>
  rename(age_months = age,
  prefecture = sub_prefecture,
  village = village_commune,
  facility = health_facility_name) |>
  mutate(age_years = age_months / 12,
  region = stringr::str_to_title(region),
  prefecture = stringr::str_to_title(prefecture),
  date_onset = lubridate::ymd(date_onset),
  date_consultation = lubridate::ymd(date_consultation),
  date_admission = lubridate::ymd(date_admission),
  date_outcome = lubridate::ymd(date_outcome)) |>
  distinct() |>
  head()
```

**Astuce.** Faites attention aux noms de vos colonnes ici ! Si vous avez renommé quelque chose, vous devrez utiliser les nouveaux noms pour toutes les parties suivantes du pipeline.
:::

Incroyable ! Cela ressemble à un excellent début de pipeline de nettoyage de données. Gardez ce code à portée de main, vous l'utiliserez lors de la prochaine session où nous examinerons une autre partie courante du nettoyage des données : le **recodage**.


C'est fait !
----------------------------------------------------------------------------------------------------
Bravo, vous avez appris les bases de la manipulation de données et comment enchaîner plusieurs commandes dans un pipe de manipulation de données. À l'avenir, les fichiers de solution seront moins axés sur l'« exercice par exercice » et fourniront plutôt un exemple de ce à quoi pourrait ressembler un vrai script dans un contexte réel. Dans ce cas, les solutions se concentreront uniquement sur le pipe final créé à la fin de la session.

```{r}
#| echo : false
#| eval: true

downloadthis::download_link(
  link = 'https://github.com/epicentre-msf/repicentre/blob/main/sessions_core/03_data_verbs_solutions_fr.R',
  button_label = 'Solutions',
  has_icon = TRUE,
  icon = « fa fa-save »,
  self_contained = FALSE
)


Aller plus loin
----------------------------------------------------------------------------------------------------

### Exercices supplémentaires

1. Ajoutez une ligne à votre `mutate()` pour mettre à jour la variable `hospitalisation` afin que son texte soit également en majuscules.

2. Peut-être préféreriez-vous utiliser des minuscules pour la colonne `region` plutôt que la casse du titre, mettez plutôt votre code à jour pour le faire. **Astuce** : vous pouvez consulter `str_to_lower()` de `{stringr}`.

3. Créez une colonne `delay_consultation`, qui contient le nombre de jours entre l'apparition des symptômes et la consultation.
