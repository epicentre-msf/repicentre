---
title: Epicurves with dates in x axis
description: Display dates rather than epiweeks numbers on your epicurves
date: last-modified
image: .../sessions_core/img/ggplot_000_logo.png
params: 
  solutions: FALSE
  sub_title: "**------ With Solutions ------**"
categories:
  - Satellite
  - Graphs
  - ggplot2
  - epicurve
  - dates
  - scales
---

```{r setup}
#| include: false
#| eval: true
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

solutions <- params$solutions

library(here)        # Better paths
library(rio)         # Import files
library(dplyr)       # Data manipulation
library(lubridate)   # Deal with dates
library(ggplot2)     # Todays workhorse


# The data
df_linelist <- rio::import(here::here('data', 'clean',
                                      'linelist_moissala_2023-09-24_clean.rds')) %>% 
  mutate(
    
    # Week number (ISO)
    week_admission = isoweek(date_admission),  # Their code
    week_outcome = isoweek(date_outcome),      # Examples
    
    # First DATE of the week
    week_first_day_adm = floor_date(date_admission,  # Their code
                                    unit = "week",
                                    week_start = 1),
    
    week_first_day_outcome = floor_date(date_outcome,   # Examples
                                        unit = "week",
                                        week_start = 1)
  )


# df_cases_age <- df_linelist %>% 
#   count(week_admission, age_group) %>% 
#   tidyr::drop_na(week)

# Data for our examples
df_outcome <- df_linelist %>%
  count(week_outcome, name = 'patients') %>%
  tidyr::drop_na(week_outcome)
```


## Objective

Learn to display dates on the bottom axis of your graphs, and how to tweak the labels.

In the [introduction to ggplot session](../sessions_core/ggplot.qmd) you learned how to plot an epicurve of the number of cases across time.

```{r}
#| echo: false
#| eval: true

df_linelist %>%
  count(week_admission) %>%
  ggplot(aes(x = week_admission,
             y = n)) +
  geom_col(fill = '#2E4573') +
  labs(x = 'ISO Week',
       y = 'Measles Cases',
       title = 'Measles in Moissala',
       caption = 'Ficticious data') +
  theme_classic(base_size = 18) 
```

In that graph we chose to represent epiweeks in the bottom axis, as it is a common task. In this session we will show how to code a variant of this graph with dates instead.


```{r}
# df_linelist %>% 
#   count(week_first_day_outcome, name = "cases") %>% 
#   ggplot(aes(x = week_fist_day,
#              y = cases)) +
#   geom_col(fill = "#2E4573") +
#   labs(x = "Date of admission",
#        y = "Cas hebdomadaires") +
#   scale_x_date(date_breaks = '4 weeks') +
#   theme_classic(base_size = 15)
```

As in the core session, the examples will plot the epicurve for outcomes, and you will code the epicurve for hospitalizations.


## Dependancies

We will use the following packages in this session:
- `{here}` to write robust absolute paths,
- `{rio}` to import the data, 
- `{dplyr}` for general tool to manipulate data,
- `{ggplot2}` to create the graphs, 
- `{lubridate}` to manage dates and times

## Setup

We use the same setup as the one from the [ggplot core session](../sessions_core/ggplot.qmd#sec-epicurve-steps).

```{r}
# Import clean data ----------------------------------------
df_linelist <- rio::import(here::here('data', 'clean',
                                      'linelist_moissala_2023-09-24_clean.rds')) %>% 
  mutate(week_admission = isoweek(date_admission))  # Used to plot the weeks ISO
```


## Create the time variable

In the core session we used the function `isoweek()` from the `{lubridate}` package to derive the week ISO *number*. In this session, we need to aggregate data by week, but also to still retain information on dates. To do that we will use the function `floor_date()`, which also belong to the `{lubridate}` package. This function returns the *first date* of a given period (day, month, year etc.). You can think of it as a sort of rounding to the smallest value, but for dates.^[Predictably, there also is a `ceiling_date()` function that rounds dates to the highest value of a period]

The function has a `unit = ` argument that allows you to choose the period of interest (week, month...) and a `week_start = ` period where you can pass the first day of the week (mondays are `1`).

```{r}
df_linelist <- df_linelist %>% 
  mutate(
    # Week number (ISO)
    week_outcome = isoweek(date_outcome),
    
    # First DATE of the week
    week_first_day_outcome = floor_date(date_outcome,
                                        unit = "week",
                                        week_start = 1)
    )
```


Let's look at all these time variables:

```{r}
#| eval: true
df_linelist %>% 
  select(id, date_outcome, week_outcome, week_first_day_outcome) %>%
  arrange(date_outcome) %>%     # Sort the data by date
  head(n = 15)
```

It is even easier to understand if we calculate the day of thee week associated with each date with the function `wday()` that *also* belong to the `{lubridate}` package:^[The `{lubridate}` package is an extremely useful tool to manage dates in R.]

```{r}
#| eval: true
df_linelist %>% 
  mutate(
    day_outcome = wday(date_outcome, 
                       label = TRUE, 
                       abbr = FALSE),
    day_floor   = wday(week_first_day_outcome, 
                       label = TRUE, 
                       abbr = FALSE)) %>% 
  select(date_outcome,
         day_outcome,
         week_outcome,
         week_first_day_outcome,
         day_floor) %>% 
  head(n = 15)
```

This illustrate how `week_outcome` and `week_first_day_outcome` are two ways to have only one value by week, which makes aggregation possible at the week scale.

::: {.callout .callout-code}
**Code.**  In the import data section of your script, add a new command to your `mutate()` call and create the variable `week_first_day_adm` that contains the first day of the week each patient was admitted in. Choose your argument as if the first day of the week is a monday.
:::


```{r echo=solutions}
# SOLUTION
df_linelist <- df_linelist %>% 
  mutate(week_first_day_adm = floor_date(date_admission,
                                    unit = "week",
                                    week_start = 1))
```


::: {.callout-tip}
Go in the help page to checkout the list of possible unit, it's big!
:::



## Aggregate by week

::: {.callout .callout-code}
**Code.**  Count the number of patients per week of admission, this time using the week start instead of the week number.
:::

Here are the first ten lines of what it should look like:

```{r echo=solutions}
#| eval: true
# SOLUTION
df_linelist %>% 
  count(week_first_day_adm) %>% 
  head(10)
```


## Draw the epicurve

::: {.callout .callout-code}
**Code.**  Create a `ggplot` with the same look at the epicurve from the [ggplot core session](../sessions_core/ggplot.qmd#sec-epicurve-steps), but with the first day of the week on the x axis. Don't forget to update axis names.
:::

It should look like that: 

```{r echo=solutions}
#| eval:true
# SOLUTION
df_linelist %>% 
  count(week_first_day_adm) %>% 
  ggplot(aes(x = week_first_day_adm,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of admission",
       y = "Measles cases",
       title = "Measles in Moissala",
       caption = "Ficticious data") +
  theme_classic(base_size = 16)
```

::: {.callout-note}
Notice that the bars are identical to the epicurve with weeks number. This is normal, are we are aggregating by week in both cases. It is only the information use to represent the week (ISO number or start date) that changes.
:::

## Improve the date labels

`{ggplot2}` automatically provided labels for the x axis, trying to adjust for the range of data. We can manually force it to make the labels more or less frequent.

To modify the appearance of the axis, we once again use function from the `scales_xxx` family: `scale_x_date()`.


This function has a  `date_breaks = ` argument that accepts the interval between two labels in a string. The string can have the following format: `"1 week"`, `"4 months"`, `"2 years"` etc.

```{r}
#| eval: true

df_linelist %>% 
  count(week_first_day_outcome) %>% 
  ggplot(aes(x = week_first_day_outcome,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of outcome",
       y = "Measles cases",
       title = 'Measles outcomes in Moissala') +
  scale_x_date(date_breaks = '4 month') +
  theme_classic(base_size = 16)
```





::: {.callout .callout-code}
**Code.**  Add the code so that the x axis displays one date every four weeks.
:::

```{r echo=solutions}
#| eval: true
# SOLUTION

df_linelist %>% 
  count(week_first_day_adm) %>% 
  ggplot(aes(x = week_first_day_adm,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of admission",
       y = "Measles cases",
       title = "Measles in Moissala",
       caption = "Ficticious data") +
  scale_x_date(date_breaks = '4 month') +
  theme_classic(base_size = 16)
```

