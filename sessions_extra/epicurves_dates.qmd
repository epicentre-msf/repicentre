---
title: Epicurves with dates in x-axis
description: Display dates rather than epiweeks numbers on your epicurves
date: last-modified
image: ../sessions_extra/img/epicurve-dates-000-logo.png
categories:
  - Satellite
  - Graphs
  - epicurve
  - dates
---

```{r setup}
#| include: false
#| eval: true
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

library(here)        # Better paths
library(rio)         # Import files
library(dplyr)       # Data manipulation
library(lubridate)   # Deal with dates
library(ggplot2)     # Todays workhorse
library(scales)      # prettier labels


# The data
df_linelist <- rio::import(here::here("data", "clean",
                                      "simulated_measles_ll.rds")) %>% 
  mutate(
    
    # Week number (ISO)
    week_consultation = isoweek(date_consultation),  # Their code
    week_outcome   = isoweek(date_outcome),      # Examples
    
    # First DATE of the week
    week_first_day_cons = floor_date(date_consultation,  # Their code
                                    unit = "week",
                                    week_start = 1),
    
    week_first_day_outcome = floor_date(date_outcome,   # Examples
                                        unit = "week",
                                        week_start = 1)
  ) %>% 
   filter(year(date_consultation) == 2022)

# Data for our examples
df_outcome <- df_linelist %>%
  count(week_outcome, name = 'patients') %>% 
  tidyr::drop_na(week_outcome)
```


## Objectives

In this tutorial we will Learn to **display dates** on the x-axis of your graphs, and how to **tweak the date labels**.

In the [epicurve session](../sessions_core/07_epicurves.qmd) you learned how to plot an epicurve of the number of cases across time:

```{r}
#| echo: false
#| eval: true

df_linelist %>%
  tidyr::drop_na(week_consultation) %>% 
  count(week_consultation) %>%
  ggplot(aes(x = week_consultation,
             y = n)) +
  geom_col(fill = '#2E4573') +
  labs(x = 'ISO Week',
       y = 'Measles Cases',
       title = 'Measles in Moissala - 2022',
       caption = 'Ficticious data') +
  theme_classic(base_size = 18) 
```

In that graph we chose to represent epiweeks in the bottom axis, as it is a common task. In this session we will show how to code a variant of this graph with dates instead.

As in the core session, the examples will plot the epicurve for outcomes, and you will code the epicurve for consultations.


## Setup

We will build on code from the [epicurve session](../sessions_core/07_epicurves.qmd) so you may code in the script associated or create a new script.

::: {.setup}
Create a new script for this tutorial or open the script from the epicurve lesson.

Make sure the following packages are installed and loaded:

- `{here}` to write robust absolute paths,
- `{rio}` to import the data, 
- `{dplyr}` to manipulate data,
- `{ggplot2}` to create the graphs, 
- `{lubridate}` to manage dates and times
- `{scales} ` to create prettier labels

Import the clean data, create a `week_consultation` variable (if not done already) and filter the data to keep only patients that consulted in 2022.
:::


::: {.callout-important}
To avoid the warnings all along the session, we removed the missing valuesfrom the outcome date columns in the examples. When you analyse and plot data, always be aware of how many missing data you have and how a `tidyr::drop_na()` command affects your dataframe.
:::


## First Day of the Week Variable

In the core session we used the function `isoweek()` from the `{lubridate}` package to derive the week ISO *number*, which is one way of aggregating data by week. In this session, we also want to aggregate data by week and yet still retain information on dates. To do that we will use the function `floor_date()` (also from the `{lubridate}` package),which returns the *first date* of a given period. You can think of it as a sort of [rounding to the smallest value]{.hovertip bs-toggle='tooltip' bs-title="Predictably, there also is a `ceiling_date()` function that rounds dates to the highest value of a period"}, but for dates.

The function has a `unit` argument that allows you to choose the period of interest (week, month...) and a `week_start` period where you can pass the first day of the week (mondays are `1`).

```{r}
df_linelist <- df_linelist %>% 
  mutate(
    week_first_day_outcome = floor_date(date_outcome,
                                        unit = "week",
                                        week_start = 1)
  )
```


Let's look at all these different time variables to figure out what's happening:

```{r}
#| eval: true

df_linelist %>% 
  select(id, date_outcome, week_outcome, week_first_day_outcome) %>%
  arrange(date_outcome) %>%     # Sort the data by date
  head(n = 10)
```

It might be even easier to understand if we calculate the day of thee week associated with each date using the function `wday()` (that *also* belong to the `{lubridate}` package, are you maybe seeing a pattern here ðŸ˜‰?):  

```{r}
#| eval: true
df_linelist %>% 
  # Get the name of the day for several date variables, to understand a bit better
  mutate(
    day_outcome = wday(date_outcome, 
                       label = TRUE, 
                       abbr = FALSE),
    day_floor   = wday(week_first_day_outcome, 
                       label = TRUE, 
                       abbr = FALSE)) %>% 
  arrange(date_outcome) %>%     # Sort the data by date
  select(date_outcome,
         day_outcome,
         week_outcome,
         week_first_day_outcome,
         day_floor) %>% 
  head(n = 10)
```

This illustrate how `week_outcome` and `week_first_day_outcome` are two ways to have only one value by week, which makes aggregation possible at the week scale. One difference between the two options is that week numbers are not unique (2022 and 2023 have a first week) while dates are.

::: {.write}
In the import data section of your script, add a new command to your `mutate()` call and create the variable `week_first_day_cons` that contains the first day of the week each patient has consulted. Choose your argument as if the first day of the week is a Monday.
:::

::: {.callout-tip}
Go read the [help page](https://lubridate.tidyverse.org/reference/round_date.html) for `floor_date()` to check out the list of possible units.
:::


## Aggregate by Week

Now that we have an alternative to `week_outcome`, we are going to follow the same steps that we did to create the epicurve, and the first one is to aggregate data by week.


::: {.write}
Count the number of patients per week of consultation, this time using the week start instead of the week number (`week_first_day_cons`).
:::

Here are the first ten lines of what it should look like:

```{r}
#| eval: true
#| echo: false

df_linelist %>% 
  count(week_first_day_cons) %>% 
  head(10)
```


## Draw the Epicurve

So far so good, now we can pipe that aggregated data frame into our plot commands, making a couple ajustments to make it work.

::: {.write}
Create a `ggplot` with the same look at the epicurve from the [epicurve core session](../sessions_core/07_epicurves.qmd#sec-epicurve-steps), but with the first day of the week on the x-axis. Don't forget to update axes names.
:::

It should look like that: 

```{r}
#| eval: true
#| echo: false
 
df_linelist %>% 
  count(week_first_day_cons) %>% 
  ggplot(aes(x = week_first_day_cons,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of consultation",
       y = "Measles cases",
       title = "Measles in Moissala - 2022",
       caption = "Ficticious data") +
  theme_classic(base_size = 16)
```


Notice that the bars are identical to the epicurve with weeks numbers. This is normal, are we are aggregating by week in both cases. It is only the information used to represent the week (ISO number or start date) that changes.



## Improve the Axis

Now, let's learn how to tweak the appearance of that date axis! `{ggplot2}` automatically provided labels for the x-axis, trying to adjust for the range of data. That default may not please us, so we may want to manually force the labels to be more or less frequent, or change the *format* of the labels.

To modify the appearance of the axis, we use a function from the scale family, `scale_x_date()`.


### Modify breaks

The breaks controls the *frequency* of ticks on the axis.

The `scale_x_date()` function has a `date_breaks` argument that accepts the interval between two labels in a string. The string can have the following format: `"1 week"`, `"2 weeks"`, `"4 months"`, `"2 years"` etc.

```{r}
#| eval: true

# Outcome graph
df_linelist %>% 
  count(week_first_day_outcome) %>% 
  ggplot(aes(x = week_first_day_outcome,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of outcome",
       y = "Measles cases",
       title = "Measles outcomes in Moissala - 2022") +
  scale_x_date(date_breaks = "1 months") +  # Define breaks
  theme_classic(base_size = 16)
```


::: {.write}
Your turn! Modify your code so that the x-axis displays labels at reasonable intervals on your screen.
:::


### Improve Labels

Now that we changed the interval between ticks, let's improve the *labels* themselves (the way dates are displayed on the axis). By default the labels are in the form "year-month-day". We are going to show you two ways to change that.


#### With the `{scales}` Package.

The `scale_x_date()` function has a `label` argument, that accepts several entries, among which a vector containing the dates, but also a function that generates labels from the breaks. The `{scales}` package provides such a function, `label_date_short()`, that attempts to create efficient and short labels for dates.

```{r}
#| eval: true

# Outcome graph
df_linelist %>% 
  count(week_first_day_outcome) %>% 
  ggplot(aes(x = week_first_day_outcome,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of outcome",
       y = "Measles cases",
       title = "Measles outcomes in Moissala - 2022") +
  scale_x_date(date_breaks = "2 weeks",
               labels = scales::label_date_short()) + # Short labels
  theme_classic(base_size = 16)
```

::: {.write}
Modify your code and use `label_date_short()` to generate labels.
:::


#### With the `strptime` Syntax

If you prefer to have full control on how to format dates, R has a *syntax* to describe date and time formats. There is a long help page with all the syntax items accessible with the `help(strptime)` command, but here are a few of the most useful elements to format a date label:

**Day**: 

- `%d`: from 01 to 31
- `%e`: from 1 to 31

**Month**:

- `%b`: abbreviated month name (current locale on your computer)
- `%B`: full month name (current locale on your computer)
- `%m`: month as a decimal number

**Year**:

- `%y`: Year without the century (two digits)
- `%Y`: year in four digits

**Special separators**:

- `%n`: newline
- `%t`: tab

You can assemble these items in a string, that you pass to different functions that accept a format as argument. Here we will pass it to the `format()` function to quickly see what display it creates, but after that we will use them in our graph command.

```{r}
# Create a date vector to explore different formats
some_dates <- as.Date(c("2024-10-06", "2024-12-15", "2025-01-20"))

# Let's try out different syntax
format(some_dates, "%Y-%b-%d")
format(some_dates, "%Y-%b")
format(some_dates, "%Y %B %d")
format(some_dates, "%y/%m/%d")
format(some_dates, "%d/%m/%Y")
```


Back to the graph! The `scale_x_date()` function has an argument `date_labels` that accepts a string of text in the above format for the date labels.

```{r}
#| eval: true

# Outcome graph
df_linelist %>% 
  count(week_first_day_outcome) %>% 
  ggplot(aes(x = week_first_day_outcome,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of outcome",
       y = "Measles cases",
       title = "Measles outcomes in Moissala - 2022") +
  scale_x_date(
    date_breaks = "1 months",      # Define intervals betw. labels
    date_labels = "%Y%n%b%n%d") +  # Define format of labels
  theme_classic(base_size = 16)
```


::: {.write}
Modify the code of you graph to have labels look like this:
:::

```{r}
#| eval: true
#| echo: false

df_linelist %>% 
  count(week_first_day_cons) %>% 
  ggplot(aes(x = week_first_day_cons,
             y = n)) +
  geom_col(fill = "#2E4573") +
  labs(x = "Date of consultation",
       y = "Measles cases",
       title = "Measles in Moissala - 2022",
       caption = "Ficticious data") +
  scale_x_date(date_breaks = "1 months",
               date_labels = "%m/%d%n%y") +
  theme_classic(base_size = 15)
```

## Done!

Congratulations! Dates are complicated, and their formatting is often scary, but we hope this little introduction showed you some nice tricks for your epicurves!

```{r}
#| echo: false
#| eval: true

downloadthis::download_link(
  link = 'https://github.com/epicentre-msf/repicentre/blob/main/sessions_core/epicurves_dates_solutions.R',
  button_label = 'Solution File',
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```


## Resources

- Chapter of the [Elegant graphics for data analyses](https://ggplot2-book.org/scales-position#sec-date-scales) book on date scales
- [Get started with lubridate](https://lubridate.tidyverse.org/articles/lubridate.html) from the package homepage.