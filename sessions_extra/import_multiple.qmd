---
title: Import multiple files and sheets
description: Learn how to import multiple sheets from an Excel file, or several Excel files.
date: last-modified
image: ../img/under_construction.svg
params: 
  solutions: FALSE
  sub_title: "**------ With Solutions ------**"
categories:
  - Satellite
  - Import data
  - Multiple files
  - list.files
---

```{r setup}
#| include: false
#| eval: true
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

solutions <- params$solutions

library(rio)    # import data easilly
library(here)   # helps with paths

path_data_raw <- here("data", "raw")
```

<!-- ![](../img/under_construction.svg) -->

## Objectives

- Learn to efficiently import data from several files
- Learn to efficiently import data from several sheets in the same file

## Introduction

In the [import data](../sessions_core/import_data.qmd) core session your learned how to use `{rio}` [package](https://gesistsa.github.io/rio/index.html#supported-file-formats) to import any file formats, and in particular `.xlsx` and `.csv` files, which will probably cover 90% of your needs. In this session we will tackle the very common problem of *scaterred data*.

You may have already encountered these situations:

- You have an Excel file with data in several sheets (linelist data, lab data, bed occupancy) and you need to import it all

- You have several Excel files (linelist data, lab data, bed occupancy) with data to import.

- You have an Excel file with data in several sheets, and all the sheets are formatted the same, and you wish the data was all together. A prime example of it is linelist or aggregated data where one sheet represent one week, or one district, and there are about 20 sheets...

- You have multiple Excel file, all formatted the same (one linelist per site, for exemple)

The two first cases can be solved with several calls to the different sheets or files, and storing the files in different dataframes, and it would not be horrible. The two last cases should however be automatized! 

The following session will help with all of them anyway: the `{rio}` package has a `import_list()` function that can import several *items* in one go. These items can be files or sheets depending on what you provide as arguments.


## Setup

We expect you to be working in the course project. You can add this tutorial to your `import_data.R` script that you created in the [Import data core session](../sessions_core/import_data.qmd), or create a new script. 


::: {.callout .callout-code}
**Code.** If you are working in a new script, add metadata about it at the top and load the `{rio}` and `{here}` packages. Then create a `path_data_raw` object that points to the directory `data / raw` of the course folder.
:::

```{r}
#| include = solutions
# SOLUTION

# Setup --------------------------
#  Packages 
library(here)
library(rio)

# Paths
path_data_raw <- here("data", "raw")
```


## Import Multiple Sheets

The `import_list()` function can import all the sheets from a Excel file^[Or, in fact, all items from a multi-object file such as `.Rdata` or `.zip`] and store them into a [list](../sessions_extra/lists.qmd). It avoids you having to write multiple `import()` commands for each file separately.

```{r}
# returns a list of dataframes
import_list(here(path_data_raw, "example_linelist.xlsx")) 
```

Now imagine someone gave you lab data with the positive, negative and inconclusive scattered in three different sheets.^[You wonder why they did that but you probably have seen weirder things.] Let's import this data.

::: {.callout .callout-look}
**Look.** In the course folder, go to the subfolder `data / raw / multiple_sheets`. There are two modified version of the lab data. Open them and look at their structure. Do you see how the second file differs form the first one?
:::

We will tackle the first file, as it is less messy.

::: {.callout .callout-code}
**Code.** Use the `import_list()` function to import all the sheets of `msf_laboratory_moissala_2023-09-24_first.xlsx`in one go, and store it in an object called `lab_data_list`.
:::

```{r echo = solutions}
#| eval: true
# SOLUTION
lab_data_list <- import_list(here(path_data_raw, "multiple_sheets",
                                  "msf_laboratory_moissala_2023-09-24_first.xlsx")) 
```

The object `lab_data_list` is a **list** that contains several dataframes (one dataframe per sheet). Maybe you have not followed the [list](../sessions_extra/lists.qmd) satellite yet and are not sure what to do with it. For now, let's just peak at it. You can inspect its structure with well known tools:

```{r}
#| eval: true

str(lab_data_list)     # Structure of the list
length(lab_data_list)  # Nb of items in the list
names(lab_data_list)   # Name of the items of the list
```

You can also go and click on the list [in the Environment panel](../sessions_core/introduction.qmd#sec-envt) to inspect its structure, and open it in the Viewer, as we did for dataframes. 

::: {.callout .callout-look}
**Look.** The View is a bit different. Click on the buttons you see and see what happens.

**Hint** There are buttons that you can click on both on the left and right of the Viewer pane.
:::

You can access elements of the list with these commands^[we added the `head()` function to shorten the output, but you can print the whole elements by removing it!]:

```{r}
#| eval: true

head(lab_data_list$positive)  # Access by name
head(lab_data_list[1])        # Access by position the first element of the list
head(lab_data_list[[1]])      # Access the content of the first element
```


### Bind Into a Dataframe

If you know that the data in all the sheets have the same structure, you can tell R to bind all of these tables into a single dataframe (rowwise) by setting the argument `rbind = ` to `TRUE`:

```{r}
# Returns a single dataframe:
import_list(
  here(path_data_raw, "example_linelist.xlsx"), 
  rbind = TRUE,                    # Tells R to bind list elements together
  rbind_label = "Sheet_position"   # Optional: name the column of the source of data
)
```

::: {.callout .callout-code}
**Code.** Use the `import_list()` function to import all the sheets of `msf_laboratory_moissala_2023-09-24_first.xlsx`in one go, and store it in an object called `lab_data`, which is a *single dataframe* containing all the data.
:::

```{r}
#| include = solutions
# SOLUTION
lab_data <- import_list(here(path_data_raw, "multiple_sheets",
                             "msf_laboratory_moissala_2023-09-24_first.xlsx"),
                        rbind = TRUE) 

str(lab_data)
View(lab_data)
```

You may use the `rbind_label = ` argument and provide a string for the column name, or nor and see what happens.


### Slightly More Messy Sheets

Now, let's focus on the second dataframe provided, `msf_laboratory_moissala_2023-09-24_second.xlsx`. By now you should have realized that this data is more messy:

- the `CT value` volumn exists only in the third sheet
- the `Laboratory id` is not in the same position in the three sheets
- The date of the test does not have the same name in all sheets

Let's see how the `import_list()` function behaves in these conditions:

```{r}
#| eval: true
lab_data_messy <- import_list(
  here(path_data_raw, "multiple_sheets",
       "msf_laboratory_moissala_2023-09-24_second.xlsx"),
  rbind = TRUE,
  rbind_label = "Sheet_position")
```

::: {.callout .callout-look}
**Look.** Run the above code and use the tools that you know to inspect the structure and content of the `lab_data_messy` object.

- What happened to the `CT value` columns? Was it imported? If yes, how was it filled?
- What happened to the `Laboratory id` columns? Was it imported? If yes, how was it filled?
- What happened to the dates columns? Were they ignored?
:::

As you can see the function behaves reasonably: 

- columns are **matched by name**, so if a column exists in all sheets *and has the same name*, the data is gathered in the same column, independantly of its position
- the corrolary is that columns with different names are treated as different columns, so check your names!
- if a column exist in one sheet and not the others, the column will exist in the final dataframe, but the values will be `NA` for the rows coming from sheets without the column ([don't remember what `NA` means?](../sessions_core/introduction.qmd#sec-missing-values)).


## Import Multiple files

The `import_list()` function can also accept a vector of file names. In this case, it will import each of these files and store them into a [list](../sessions_extra/lists.qmd), unless you can use the `rbind = TRUE`.

```{r}
# Create a vector of (fictitious) files
vector_paths <- c(
  here(path_data_raw, "example_linelist_A.xlsx"),
  here(path_data_raw, "example_linelist_B.xlsx"),
  here(path_data_raw, "example_linelist_C.xlsx"),
  here(path_data_raw, "example_linelist_D.xlsx"),
  here(path_data_raw, "example_linelist_E.xlsx"),
  here(path_data_raw, "example_linelist_F.xlsx"),
  here(path_data_raw, "example_linelist_G.xlsx"),
  here(path_data_raw, "example_linelist_H.xlsx"),
  here(path_data_raw, "example_linelist_I.xlsx"),
  here(path_data_raw, "example_linelist_J.xlsx"),
  here(path_data_raw, "example_linelist_K.xlsx"),
  here(path_data_raw, "example_linelist_L.xlsx"),
  here(path_data_raw, "example_linelist_M.xlsx")
)

import_list(vector_paths) # returns a list
```


::: {.callout .callout-look}
**Look.** Go to the subfolder `data / raw / multiple_files`. Open the files to check their content. Would it make sense to concatenate the data together at import in this case?
:::

::: {.callout .callout-code}
**Code.** Import all the Excel files in one go and store them in a dataframe called `linelist_data`.

Inspect the dataframe created: how many lines? How many columns? Was everything imported as you expected?
:::

```{r}
#| include = solutions
# SOLUTION

path_mult <- here::here(path_data_raw, "multiple_files") # optional, to shorten the following code

vector_paths <- c(
  here(path_mult, "msf_linelist_moissala_2023-09-24_bedaya.xlsx"),
  here(path_mult, "msf_linelist_moissala_2023-09-24_bekourou.xlsx"),
  here(path_mult, "msf_linelist_moissala_2023-09-24_bouna.xlsx"),
  here(path_mult, "msf_linelist_moissala_2023-09-24_danamadji.xlsx"),
  here(path_mult, "msf_linelist_moissala_2023-09-24_koumogo.xlsx"),
  here(path_mult, "msf_linelist_moissala_2023-09-24_moissala.xlsx")
)

# Print:
vector_paths

# Import the data and concatenate it:
linelist_data <- import_list(vector_paths,
                             rbind = TRUE)
```


### Get File Paths with `file.path()`

#### List All the Files

Manually listing the files that you want to import was fine for demonstrations purposes so that you understand what to pass to the `import_list()` function, but it is slow and error prone. 

We will now use the function `list.files()` to automatically retrieve the file paths. Its main argument, `path = ` takes a file path, and the function returns a simple vector of file names.

```{r}
#| eval: true

path_mult <- here::here(path_data_raw, "multiple_files") # optional, to shorten the following code

list.files(path = path_mult) # returns a vector of file names
```

We can ask the function to return the full paths of the files with the argument `full.names = TRUE`:

```{r}
#| eval: true
list.files(path = path_mult,
           full.names = TRUE)
```

::: {.callout-note}
Note that even if these are absolute paths, we used `{here}` and relative paths within the course directory so the absolute paths will different but functional on your computer.
:::

#### Keep Only the Excel files

Now, this is nice and all but there are those pesky files that are not Excel which we would like to avoid. An easy way is to use the `pattern = ` argument of `list.files()`. It takes a string of text that is matched to the names of files, to keep only the ones you want.

The `pattern = ` argument accepts [regular expressions, or regex for short](https://r4ds.hadley.nz/regexps), which are *way* out of our scope here^[Regular expressions have their own syntax that is not limited to R and are super powerfull. They are also hard to use so if you are new to R you should probably wait a bit before diving into them.]. Here we are only giving you pointers to create a simple pattern.

The function will return file names that match the pattern: 

```{r}
#| eval: true

# All file names that contain "bedaya":
list.files(path = path_mult, pattern = "bedaya") 

# All file names that contain "msf_linelist":
list.files(path = path_mult, pattern = "msf_linelist") 

# All file names that contain "msf_ll":
list.files(path = path_mult, pattern = "msf_ll") 

# All the files that contain "doc"
list.files(path = path_mult, pattern = "doc")
```


Did you notice at the end, two files contained "doc" in their name, one in its name, the other in its extension. If you want to select only the Word document, you need a more precise pattern.


```{r}
#| eval: true
# Get this word document for sure
list.files(path = path_mult, pattern = "\\.doc$") 
```

Here we modified the pattern to make it more restrictive:

- the `\\.` at the start is the regex way of saying that there should be a "." before "doc".^[It sound complicated because the "." alone has a special meaning in regex, so we need to add the "\\\". Go [read on regex](https://r4ds.hadley.nz/regexps), or trust us for now.]
- the `$` at the end of the pattern indicates that this pattern should be at the end of the file name.

So with this pattern we are looking for *files that contain ".doc" at the end of their names*.


::: {.callout .callout-code}
**Code.** Now, write a command using `list.files()` to automatically list all files that end with ".xlsx".
Then, update your previous code to import these files in one dataframe, as we did before.
:::

```{r}
#| include = solutions
# SOLUTION
# Import the data and concatenate it:
linelist_data <- import_list(
  list.files(path = path_mult, pattern = "\\.xlsx$",
             full.names = TRUE),
  rbind = TRUE)
```

::: {.callout-tip}
The argument `recursive = TRUE` allows you to list files present in subdirectories of your path target, which can be handy if you have nested folders containing data.
:::