---
title: Surveillance
description: Tutoriel d'accompagnement au module Surveillance du FETCH
image: ../img/companion/surveillance/logo.svg
categories:
  - Compagnon
  - Analyse
---

```{r setup}
#| include: false
#| eval: true
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

library(here)        # For paths
library(rio)         # Import and export data
library(tidyverse)   # Data manipulation
library(zoo)  

# Surveillance data
df_surv_brut <- import(here("data", "surveillance_module", "raw", 
                            "data_ids_sem20_2022_fr.xlsx"))

# Laboratory data
df_labo_brut <- import(
  here("data", "surveillance_module", "raw", "data_labo_sem20_2022_fr.xlsx"), 
  skip = 7  # Skip the first seven lines
) 


df_surv <- df_surv_brut |> 
  mutate(
    
    # Format strings to lower case
    pays       = tolower(pays),
    province   = tolower(province),
    zone_sante = tolower(zone_sante),
    maladie    = tolower(maladie),
    
    
    # Remove excess spaces with the str_squish() function from 
    # the stringr package, very usefull!
    province   = str_squish(province),
    zone_sante = str_squish(zone_sante),
    
    
    # Remove spaces or "-" with the str_replace() function from 
    # the stringr package
    province   = str_replace(province, pattern = "-", replacement = "_"), 
    province   = str_replace(province, pattern = " ", replacement = "_"),
    zone_sante = str_replace(zone_sante, pattern = "-", replacement = "_"), 
    zone_sante = str_replace(zone_sante, pattern = " ", replacement = "_")
  )

df_labo <- df_labo_brut |> 
  mutate(
    
    # Clean strings
    zone_sante = tolower(zone_sante),    # Format strings to lower case
    zone_sante = str_squish(zone_sante), # Remove excess spaces
    zone_sante = str_replace(zone_sante, "-", "_"),  # Replace - by _
    zone_sante = str_replace(zone_sante, " ", "_"),  # Replace space by _
    
    # Recode IgM modalities
    igm_rougeole = case_when(
      igm_rougeole == 'pos' ~ 'positif', 
      igm_rougeole == 'neg' ~ 'negatif', 
      .default = igm_rougeole),
    
    igm_rubeole = case_when(
      igm_rubeole == 'pos' ~ 'positif', 
      igm_rubeole == 'neg' ~ 'negatif', 
      .default = igm_rubeole)
  )

df_surv_sem <- df_surv |> 
  select(province, zone_sante, semaine, totalcas, totaldeces) |>
  complete(
    nesting(province, zone_sante),
    semaine = seq(min(df_surv$semaine, na.rm = TRUE), 
                  max(df_surv$semaine, na.rm = TRUE)),
    fill = list(totalcas = 0, 
                totaldeces = 0)
  ) 


# Analyse
data_alerte <- df_surv_sem |>
  
  # Select the 4 health zones
  filter(zone_sante %in% c("dilolo", "kowe" ,"kampemba", "lwamba")) |>
  
  # Order by province, zone_sante and semaine
  arrange(province, zone_sante, semaine) |>
  
  # Binary indicator for 20 cases (semainely indicator by health zone)
  mutate(
    cas20 = case_when(
      totalcas >= 20 ~ 1, 
      .default = 0)) |>
  
  
  # Cumulative indictors, need to be calculated by health zone
  mutate(
    
    # Group by province and health zone
    .by = c(province, zone_sante),
    
    # Cumulative cases over 3 semaine window (zoo::rollapply)
    cas_cumu = rollapply(totalcas, 
                         width = 3,        # Window width
                         sum,              # function to apply
                         na.rm = TRUE,     # Arguments to pass to the function (here, sum)
                         align = "right",  
                         partial = TRUE),
    
    # Binary indicator for 35 cumulative cases
    cas_cumu35 = case_when(cas_cumu >= 35 ~ 1, 
                           .default = 0),
    
    
    # Combined alerte indicator
    # The operator | is a logical OR. Here we test:
    # is cas20 equal to 1 OR is cas_cumu35 equal to 1
    alerte = case_when(
      (cas20 == 1 | cas_cumu35 == 1) ~ 1, 
      .default = 0)
  )

zone_sante_alertee <- data_alerte |>
  filter(semaine == 20)  |>
  filter(alerte == 1) |>
  pull(zone_sante)
```

## Objectifs

- Travailler les comp√©tences acquises dans les deux modules FETCH-R (importation, nettoyage et visualisation des donn√©es).
- Analyser des donn√©es de surveillance rougeole pour d√©tecter les alertes et aider √† prioriser quelles alertes doivent √™tre approfondies avec une enqu√™te sur le terrain.


## Introduction

Cette session accompagne l'√©tude de cas _R√©ponse d'urgence contre la rougeole dans la r√©gion du Katanga (RDC)_ du module FETCH Surveillance. √áa n'a probablement pas beaucoup de sens d'essayer de la suivre sans les documents et les discussions de l'√©tude.

En ce qui concerne la partie *R* du module surveillance, nous nous appuierons sur les comp√©tences acquises tout au long des modules FETCH-R, et introduirons quelques nouvelles fonctions utiles pour le nettoyage et les analyses.


::: {.callout-tip}
N'h√©sitez pas √† scaner vos notes, vos scripts ou les tutoriels des sessions pr√©c√©dentes pour vous rafra√Æchir sur le fonctionnement de certaines fonctions quand vous en √©prouvez le besoin.

Par ailleurs, les [encadr√©s contenant les instructions](../sessions_core/01_introduction.qmd#Exercise Format) sont les m√™mes que dans les autres modules.
:::


## Mise en place

Comme cette session fait partie d'un module sp√©cifique, vous allez cr√©er un nouveau projet RStudio. Jetez un coup d‚Äô≈ìil [√† la session principale](../sessions_core/02_import_data.qmd) si vous ne vous rappelez plus comment faire.

### Cr√©er le projet

:::  {.setup}
1. Cr√©ez un dossier `surveillance_case_study` sur votre ordinateur, associ√© avec le module Surveillance du FETCH. Ajoutez les sous dossiers suivants √† l'int√©rieur :

- üìÅ data
  - üìÅ clean
  - üìÅ raw
- üìÅ R
- üìÅ outputs

2. Cr√©ez un [projet RStudio](../sessions_core/02_import_data.qmd#rstudio-projects) √† la racine du dossier `surveillance_case_study`.

3. Si vous n'avez pas encore les donn√©es, t√©l√©chargez-les.

```{r}
#| echo: false
#| eval: true

downloadthis::download_link(
  link = 'https://github.com/epicentre-msf/repicentre/raw/main/data/surveillance_module/raw/donnes_brutes_fr.zip',
  button_label = "T√©l√©charger les donn√©es brutes",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

<br>
4. D√©zippez l'archive si vous venez de t√©l√©charger les donn√©es. Quelle que soit la source, enregistrez les deux fichiers Excel dans le sous dossier `data/raw`. 
<br>
5. Cr√©ez un nouveau script `import_nettoyage.R` et enregistrez-le dans le sous dossier `R`. Ajoutez les m√©tadonn√©es et une section pour charger les paquets `{here}`, `{rio}`, et `{tidyverse}`.
:::


### Importer les donn√©es

**Rappel de l'√©tude de cas** : vous avez demand√© l'acc√®s aux donn√©es de surveillance de routine et aux donn√©es de laboratoire au MSP de la RDC. Le minist√®re a accept√© de les partager avec vous toutes les semaines. Vous recevez le premier fichier √† la semaine 20 en 2022 (note : les donn√©es sur lesquelles nous travaillerons sont simul√©es).

:::  {.look}
Si vous ne l'avez pas d√©j√† fait, ouvrez les deux fichiers dans un tableur (Excel ou autre) pour les inspecter avant l'importation.
:::

Le jeu de donn√©es de surveillance a l'air facile √† importer. En revanche, le jeu de donn√©es laboratoire pourrait vous inqui√©ter, avec ses lignes suppl√©mentaires avant les donn√©es... Heureusement, la fonction `import()` que nous utilisons a un argument `skip` qui permet de g√©rer ce cas courant :

```{r}
# NE PAS EX√âCUTER (PSEUDO-CODE)
import(
  here("data", "raw", "fichier_exemple.xlsx"), 
  skip = 3  # Sauter les trois premi√®res lignes, l'import commence √† la ligne 4
) 
```

:::  {.write}
1. Ajoutez une section pour l'import des donn√©es √† votre script.

2. Importez le jeu de donn√©es surveillance et stockez le dans un objet `df_surv_brut`. Ensuite, importez le jeu de donn√©es laboratoire et stockez le dans un objet `df_labo_brut`. 

3. V√©rifiez que l'importation s'est bien pass√©e pour les deux data frames (vous avez plusieurs outils √† votre disposition : Viewer, dimensions de l'objet, haut et bas du data frame...).
:::



## Nettoyage des donn√©es (Question 2)

Maintenant que les donn√©es sont import√©es, nous pouvons effectuer quelques v√©rifications dessus, et les nettoyer.

### Donn√©es de surveillance

#### Inspection rapide

Pendant l'√©tude de cas vous n'aurez peut-√™tre pas le temps d'inspecter *et* nettoyer *toutes* les colonnes. Nous vous proposons donc de vous focaliser sur quelques colonnes cl√©s : `zone_sante`, `semaine`, `totalcas` et `totaldeces`.

::: {.callout-note}
Si vous revenez sur le tutoriel plus tard ou finissez en avance, n'h√©sitez pas √† v√©rifier la qualit√© des autres variables, et √† recouper les informations de diff√©rentes colonnes. Nous vous renvoyons √† la discussion lors de l'√©tude ou aux documents du module de gestion des donn√©es pour des id√©es de v√©rifications √† effectuer.
:::

::: {.write}
Ajoutez une section pour l'exploration et le nettoyage des donn√©es de surveillance dans votre script. 
<br>
Maintenant, explorez le data frame et r√©pondez aux questions suivantes :

- Quels sont les noms des colonnes ?
- Combien de provinces y a-t-il dans le jeu de donn√©es actuel ? Cela correspond-il √† ce que vous attendez ?
- Combien de zones de sant√© y a-t-il dans le jeu de donn√©es ? Cela correspond-il √† ce que vous attendez ?
- Quel est la plage des semaines ?
- Quelle est la valeur minimale de `totalcas` ?
- Quel est le maximum de `totaldeces` ?
- Remarquez-vous des donn√©es manquantes pour les colonnes ci-dessus ? Les cha√Ænes de caract√®re (rappel : le texte) sont-elles propres ?
:::


#### Nettoyer les cha√Ænes de caract√®res

Maintenant que nous avons une meilleure id√©e de l'√©tat des donn√©es, nettoyons-les. Nous allons √©crire un *pipeline de nettoyage* (ou *cha√Æne de commandes*) comme dans les modules R pr√©c√©dents (voir votre code √† la fin du [module de nettoyage](../sessions_core/04_data_verbs_conditional.qmd)).

:::  {.callout-tip}
Pour faciliter le d√©bogage  de la cha√Æne de commandes, **ajoutez et testez les √©tapes unes par unes** !
:::

Nous allons am√©liorer un peu les colonnes de texte afin d'√©liminer des probl√®mes potentiels :

- passer tout en minuscules (homog√©n√©ise)
- supprimer les espaces surnum√©raires (√©ventuels)
- remplacer `-` et les espaces par `_`.

Peut √™tre que vous n'aurez pas le temps de faire ces √©tapes pour toutes les colonnes. Pour commencer, choisissez une de ces deux colonnes : `zone_sante` ou `prov` pour appliquer les instructions. Vous pourrez faire les autres plus tard.

:::  {.write}
Commencez un *pipeline* de nettoyage avec un `mutate()` pour transformer la colonne de votre choix en minuscules.
:::

Nous allons maintenant voir deux petites fonctions tr√®s utiles pour le nettoyage du texte. La premi√®re est la fonction `str_squish()` du paquet `{stringr}` ([la page d'aide](https://stringr.tidyverse.org/reference/str_trim.html)), qui supprime les espaces au d√©but ou √† la fin des cha√Ænes de caract√®res, et  les espaces surnum√©raires o√π qu'ils soient : 

```{r}
#| eval: true

exemples <- c(" Espaces au d√©but et √† la fin     ",
              "Espaces     multiples",
              " Tous les     probl√®mes  ")

str_squish(exemples)
```

L'autre fonction, `str_replace` (√©galement du [paquet `{stringr}`](https://stringr.tidyverse.org/reference/str_replace.html?q=str_replace#null)) remplace un bout de texte dans une cha√Æne de caract√®res par un autre bout de texte, sans surprise. L'argument `pattern` accepte le texte √† remplacer, et l'argument `replacement` le texte √† utiliser comme remplacement.

```{r}
#| eval: true

str_replace(
  "HAUT-KATANGA",    # Le texte sur lequel on travaille (peut √™tre une colonne)
  pattern = "-",     # Le bout √† remplacer
  replacement = "_"  # Le remplacement
)
```

:::  {.write}
Ajoutez des lignes √† votre mutate pour, sur la colonne de votre choix :

- Nettoyer les espaces
- Changer les `-` et les espaces en `_` (deux √©tapes)

Le d√©but d'au moins une des colonnes devrait ressembler √† :

```{r}
#| eval: true
#| echo: false

df_surv |> select(pays, province, zone_sante, maladie) |> head()
```

Stockez le r√©sultat dans un data frame `df_surv`.
:::

#### Enregistrer les donn√©es nettoy√©es

:::  {.write}
Utilisez le paquet `{rio}` pour exporter `df_surv` vers un fichier `.rds` appel√© `data_ids_2022-20_clean` dans le sous dossier `data/clean` de votre projet.
:::

### Donn√©es labo

Nous allons suivre les m√™mes √©tapes pour le jeu de donn√©es laboratoire. Nous nous focaliserons sur les colonnes `zone_sante`, `igm_rougeole` et `igm_rubeole`.

#### Inspection rapide

:::  {.write}
Inspectez les colonnes mentionn√©es, et les dimensions du data frame. 

Quelles sont les cat√©gories des colonnes `igm_rougeole` et `igm_rubeole` ? Quel type de nettoyage sera √† effectuer dessus ?
:::

#### Nettoyage et recodage

:::  {.write}

1. D√©marrez un nouveau *pipeline* de nettoyage pour les donn√©es labo. Choisissez une colonne de texte et passez l√† en minuscules, puis supprimez les espaces surnum√©raires. Enfin, remplacez les espaces et les `-` par `_`.

2. Recodez au moins une des colonnes `igm_rougeole` ou `igm_rubeole` pour que les cat√©gories soient `negatif`, `positif` et `indetermin√©`.

3. Stockez la version nettoy√©e dans un data frame `df_labo`

L'en-t√™te des colonnes nettoy√©es devrait maintenant √™tre :

```{r}
#| eval: true
#| echo: false
df_labo |> select(zone_sante, igm_rougeole, igm_rubeole) |> head(10)
```
:::


::: {.callout-tip collapse=true}
Vous pouvez utiliser la fonction `case_when()` pour recoder les colonnes contenant les r√©sultats des tests anticorps. 
:::


#### Enregistrer les donn√©es nettoy√©es

:::  {.write}
Exportez le data frame `df_labo` vers un fichier `.rds` appel√© `df_labo_2022-w20_clean` dans le sous dossier `data/clean` de votre projet.
:::


### Donn√©es de surveillance compl√©t√©es

Durant l'inspection des donn√©es vous avez du vous rendre compte qu'il y a des semaines manquantes pour certaines ZS dans les donn√©es de surveillance. Normalement, vous avez discut√© les raisons possibles et des probl√®mes associ√©s en pl√©ni√®re. Dans ce tutoriel, nous allons fournir le code pour compl√©ter le data frame surveillance pour que toutes les ZS aient toutes les semaines (en faisant l'hypoth√®se que les semaines manquantes n'ont pas eu de cas ou de d√©c√®s).

Nous utiliserons la fonction [`complete()` du paquet `{tidyr}`](https://tidyr.tidyverse.org/reference/complete.html) pour ajouter les lignes manquantes et remplir les colonnes contenant des nombres (`totalcas` et `totaldeces`) avec des z√©ros. A cause des contraintes de temps nous allons vous donner le code, mais quelques exemples et explications seront donn√©s dans la section [Aller plus loin](#sec-going-further), que vous pourrez lire quand vous aurez le temps.


::: {.write}
1. Commencez un nouveau pipeline √† partir de `df_surv` et ne conservez dedans que les colonnes `province`, `zone_sante`, `semaine` et `totalcas`. 

2. Ajoutez une nouvelle √©tape √† votre pipeline et collez le code ci-dessous pour compl√©ter le data frame :

```{r}
complete(
  # On travaille sur les combinaisons existantes de province et ZS
  nesting(province, zone_sante),
  
  # On voudra toutes les semaines entre le minimum (1) et le maximum (20) de la colonne semaine
  semaine = seq(min(semaine, na.rm = TRUE), 
                max(semaine, na.rm = TRUE)),
  
  # Remplir les nouvelles semaines de zeros pour ces colonnes :
  fill = list(totalcas   = 0, 
              totaldeces = 0
  )
) 
```

3. Stockez le r√©sultat dans un data frame appel√© `df_surv_sem`, qui devrait ressembler √† :

```{r}
#| eval: true
#| echo: false
df_surv_sem |> head(10)
```

4. Exportez ce data frame dans un fichier `.rds` appel√© `data_ids_2022-w20_weeks_clean` dans le sous dossier `data/clean` de votre projet.
:::


### Aller plus loin

Vous √™tes arriv√©s au bout de la question 2. Si vous avez termin√© en avance, utilisez les fonctions vues pour nettoyer les autres colonnes de texte dans les deux data frames, et recodez les deux colonnes IgM dans les donn√©es labo.

Si vous avez encore du temps, inspectez vos donn√©es plus avant :

- Affichez la zone de sant√© pour laquelle les totaux par groupe d'√¢ge sont diff√©rents de la colonne total (pour les cas, puis pour les d√©c√®s)
- Est-ce qu'il y a une ZS o√π le nombre de d√©c√®s est plus √©lev√© que le nombre de cas ?
- Y a-t-il des lignes dupliqu√©es (enti√®rement dupliqu√©es, ou plusieurs valeurs pour la zone de sant√© et la semaine) ?
- Y a-t-il des nombres de cas que vous estimez aberrants ?


Vous pouvez aussi lire les explications sur la fonction `complete()` √† la fin du tutoriel et aller explorer la [page d'aide](https://tidyr.tidyverse.org/reference/complete.html) de la fonction.



## D√©finir les alertes (Question 4)

### Pr√©parer le jeu de donn√©es

Nous allons continuer la pr√©paration des data frames pour l'analyse.

#### Mise en place

::: {.setup}
1. Si vous n'avez pas eu le temps de nettoyer la zone de sant√© et la province dans les deux data frames, et les deux colonnes IgM dans le jeu de donn√©es labo, vous pouvez importer les jeux de donn√©es nettoy√©s :

```{r}
#| echo: false
#| eval: true

downloadthis::download_link(
  link = 'https://github.com/epicentre-msf/repicentre/raw/main/data/surveillance_module/clean/clean_data_fr.zip',
  button_label = "T√©l√©charger donn√©es propres",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```
<br>
D√©zippez l'archive et importez les donn√©es dans le sous dossier `data/clean`

2. Cr√©ez un script `analyse_surveillance.R` dans le sous dossier `R`. Ajoutez les m√©tadonn√©es, et une section pour importer les paquets `{here}`, `{rio}`, `{tidyverse}`, `{lubridate}` et `{zoo}`.

3. Ajoutez une section  d'import des donn√©es propres et importez les fichiers `.rds` dans R en utilisant la fonction `import()` comme d'habitude (soit vos donn√©es nettoy√©es, soit celles que vous venez de t√©l√©charger). Assignez les jeux de donn√©es nettoy√©es aux data frames suivants :

- data_ids_2022-w20_clean --> `df_surv`, 
- data_ids_2022-w20_clean_weeks --> `df_surv_sem`
- data_lab_2022-w20_clean --> `df_labo`.

:::


#### S√©lection des ZS

Pour simplifier le travail nous allons nous focaliser sur quatre zones de sant√© : Dilolo, Kampemba, Kowe, et Lwamba.

::: {.write}
Commencez  une nouvelle cha√Æne de commande √† partir du data frame `df_surv_sem`. La premi√®re √©tape est de filtrer les donn√©es pour ne conserver que les zones de sant√© Dilolo, Kampemba, Kowe, et Lwamba.
:::


#### Indicateur hebdomadaire

Notre premier indicateur regarde si *une zone de sant√© a 20 cas suspects ou plus dans une semaine*. Cet indicateur est dichotomique et ne prend en compte que les donn√©es d'une zone de sant√© pour une semaine donn√©e.

::: {.write}
Ajoutez un `mutate()` √† votre cha√Æne pour cr√©er une colonne `cas20` qui contient la valeur `1` si une ZS a 20 cas ou plus cette semaine-l√†, et `0` sinon.

<br>
Le d√©but du data frame ressemble √† √ßa :

```{r}
#| echo: false
#| eval: true

df_surv_sem |>
  
  # Select the 4 health zones
  filter(zone_sante %in% c("dilolo", "kowe" ,"kampemba", "lwamba")) |>
  
  # Order by province, health zone and semaine
  arrange(province, zone_sante, semaine) |>
  
  # Binary indicator for 20 cases (semainely indicator by health zone)
  mutate(
    cas20 = case_when(
      totalcas >= 20 ~ 1, 
      .default = 0))  |> head(10)
```
:::

#### Indicateur cumul√©

Notre second indicateur regarde si une zone de sant√© compte plus de *35 cas suspects cumul√©s en trois semaines*. C'est un peu plus compliqu√© √† calculer que l'indicateur hebdomadaire : pour chaque zone de sant√©, il faut calculer la somme des cas par fen√™tres de trois semaines, mais les fen√™tres ne sont pas fixes, elles *glissent* dans le temps. Nous entrons ici dans le domaine des moyennes/sommes/etc. *mobiles* ou *glissantes*...

##### Somme cumul√©e

Nous allons utiliser la fonction `rollapply()` du paquet `{zoo}` pour calculer la somme cumul√©e car elle est polyvalente et puissante. Comme son nom l'indique, la fonction `rollapply()` *applique* une fonction de mani√®re glissante (*roll* peut √™tre traduit ici en "rouler") √† un vecteur ou √† une colonne d'un data frame. En d'autres termes, cette fonction r√©capitule pour une colonne donn√©e les informations de plusieurs *lignes cons√©cutives* d'un data frame avec une fonction de notre choix (somme, moyenne etc.).

Comme nous sommes contraint par le temps, nous allons vous fournir ici le code pour calculer la somme cumul√©e, et nous vous donnons plus de d√©tails sur la fonction dans la section [Aller plus loin](#sec-going-further) que vous pourrez lire quand vous aurez le temps.

Voici comment utiliser la fonction pour une zone de sant√© :

```{r}
#| eval: true

# Cr√©e un mini data frame pour l'exemple
exemple_df = data.frame(
  province   = "Haut Katanga",
  zone_sante = "Dilolo",
  semaine    = 1:10,
  totalcas   = rep(1, times = 10))

exemple_df 

exemple_df |> 
  mutate(cas_cumu = rollapply(
    data  = totalcas,   # La colonne cible
    width = 3,          # La taille de la fen√™tre  
    FUN   = sum,        # La fonction √† appliquer, ici la somme
    align = "right",    # On cumule les valeurs pass√©es jusqu'√† pr√©sent
    partial = TRUE,     # Les somme partielles sont autoris√©es
    na.rm = TRUE        # Argument en plus √† passer √† la fonction sum()
  )
  )
```


##### Par zone de sant√©

Ok, mais nous voudrions utiliser cette fonction dans un data frame qui contient plusieurs zones de sant√©, et faire la somme cumul√©e *par zone de sant√©*. Ce n'est pas si compliqu√© : nous allons trier notre jeu de donn√©es par zone de sant√© et semaine, puis utiliser l'argument `.by` dans `mutate()` pour effectuer les actions *par zone de sant√©*.

::: {.callout-note}
Rappelez-vous, nous avons d√©j√† vu le `.by` par le pass√©: nous l'avons utilis√© au sein de la fonction `summarize()` lors de la session sur les [tableaux agr√©g√©s](../sessions_core/05_summary_table.qmd#sec-stratify) pour faire des r√©sum√©s *par groupe*.


C'est la m√™me id√©e aujourd'hui, sauf qu'au lieu d'utiliser une fonction qui ne renvoie qu'une seule valeur par groupe (`summarize()`) nous allons utiliser une fonction qui renvoie une valeur par **ligne** (`mutate()`), mais prend en compte les informations du groupe.

Pour rappel de comment `summarize()` + `.by` fonctionne, voici comment calculer le nombre total de cas suspects et d√©c√®s par province : 

```{r}
#| eval: true
df_surv_sem |> 
  summarize(
    .by = province,  # Fait les choses PAR province
    cas_tot   = sum(totalcas, na.rm = TRUE),
    deces_tot = sum(totaldeces, na.rm = TRUE)
  )
```
:::

::: {.write}
1. Ajoutez une √©tape √† votre pipeline pour trier les donn√©es par province, zone de sant√© et semaine (dans cet ordre) avec la fonction `arrange()`, qui est une fonction de tri du paquet `{dplyr}` : 

```{r}
df_surv_sem |>
  arrange(province, zone_sante, semaine)
```

2. Ajoutez ensuite le code pour calculer la somme cumul√©e : 

```{r}
mutate(
  .by = c(province, zone_sante),
  cas_cumu = rollapply(
    data    = totalcas,   # La colonne cible
    width   = 3,          # La taille de la fen√™tre  
    FUN     = sum,        # La fonction √† appliquer, ici la somme
    align   = "right",    # On cumule les valeurs pass√©es jusqu'√† pr√©sent
    partial = TRUE,       # Les somme partielles sont autoris√©es
    na.rm   = TRUE        # Argument en plus √† passer √† la fonction sum()
  )
)
```
:::

::: {.callout-important}
La fonction `rollapply()` consid√®re l'ordre du data frame pour d√©cider o√π placer sa fen√™tre, elle n'a pas de *compr√©hension* du temps : elle fait juste la somme des valeurs pr√©c√©dentes ou suivantes. 

Par exemple, si l'on veut calculer la somme cumul√©e en semaine 15, la fonction somme les deux valeurs venant avant dans le data frame √† la valeur de la ligne concern√©e. On veut donc que les deux lignes pr√©c√©dentes contiennent les valeurs des semaines 13 et 14 ! √áa implique que :

1. Le data frame est **ordonn√©** (ou *tri√©*) ! Si les deux lignes pr√©c√©dentes ne contiennent pas les semaines 13 et 14 de cette zone de sant√©, la somme cumul√©e est fausse.
2. Le data frame est **complet**. Si la somme en semaine 15 est en fait la somme des semaines 12, 13 et 15 parce que la semaine 14 est manquante, le calcul est faux.
:::

##### Calculer l'indicateur binaire

Maintenant que la somme cumul√©e est calcul√©e, on peut calculer l'indicateur dichotomique qui r√©sume les donn√©es cumul√©es pour chaque semaine.

::: {.write}
Ajoutez une nouvelle √©tape √† votre pipeline pour cr√©er une colonne `cas_cumu35` qui contient `1` si la somme cumul√©e est sup√©rieure ou √©gale √† 35, et `0` sinon.
:::


#### Indicateur combin√©

Calculons finalement l'indicateur combin√© qui r√©sume les deux indicateurs pr√©c√©dents.

::: {.write}
1. Dans le m√™me `mutate()` que pr√©c√©dement, ajoutez une colonne `alerte`, qui est `1` si l'indicateur `cas20` **OU** l'indicateur `cas_cumu35`  est `1` et `0` sinon. Pour le test logique vous devrez utiliser l'op√©rateur `|` qui repr√©sente le **OU** logique. Cet op√©rateur renvoi `TRUE` si au moins une des conditions est remplie (et donc aussi si le deux sont remplies).

2. Assignez le r√©sultat √† un data frame appel√© `data_alerte`.

Ce data frame ressemble √† ceci (quelques colonnes sont cach√©es pour l'affichage) :

```{r}
#| echo: false
#| eval: true
data_alerte |>select(-province, -totaldeces) |>
  head(10)
```

:::


### Zones de sant√© en alerte

Maintenant que la pr√©paration est finie, nous pouvons *enfin* regarder quelles zones de sant√© sont en alerte dans notre jeu de donn√©es, en particulier √† la semaine 20 (les donn√©es les plus r√©centes selon l'√©tude de cas).


::: {.write}
Affichez les donn√©es filtr√©es pour ne voir que ce qui se passe √† la semaine 20. Quelle zones sont en alerte en ce moment ?

Cr√©ez un vecteur `zs_alerte` qui contient le nom des zones de sant√© qui sont en alerte √† la semaine 20. Ce vecteur sera utilis√© par la suite pour filtrer les donn√©es lors de l'analyse.
:::


## Tracer la courbe √©pid√©mique (Question 4)

Nous allons √† pr√©sent tracer la courbe √©pi pour les zones en alerte √† la semaine 20. Nous pouvons r√©utiliser le code vu lors de la session sur les [courbes √©pid√©miques](../sessions_core/06_epicurves.qmd) : nous utiliserons le paquet `ggplot()` et la fonction `geom_col()` pour cr√©er un diagramme qui montre la distribution des cas par semaine.

Petite nouveaut√© : par le pass√© nous avions une liste linaire o√π une ligne correspond √† un patient, donc un cas. Aujourd'hui nous avons des donn√©es d√©j√† agr√©g√©es par semaine et zone de sant√© : nul besoin de *compter* le nombre de cas nous m√™me.


::: {.write}
Tracez la courbe √©pid√©mique pour *une* des zones de sant√© en alerte.

<br>
Le graphe devrait ressembler √† ceci (peut √™tre avez-vous choisi l'autre zone) : 

```{r}
#| echo: false
#| eval: true
#| fig-width: 8

data_alerte |>
  filter(zone_sante == "kampemba") |>
  ggplot(aes(x = semaine, 
             y = totalcas)) + 
  geom_col(fill = "#2E4573") + 
  theme_bw(base_size = 16) + 
  labs(x = "Semaine",
       y = "N cas",
       title = "Zone de sant√© de Kampemba (en alerte)")
```
:::

Nouvelle fonction utile, la fonction `facet_wrap()` permet de cr√©er plusieurs graphiques d'un seul coup rassembl√©s en une seule figure. 

```{r}
# NE PAS EX√âCUTER (PSEUDO-CODE)

donn√©es |>
  ggplot(aes(...)) + 
  geom_col(...) + 
  theme_bw(...) + 
  labs(...) +
  facet_wrap(vars(zone_sante))   # Un graphe par zone de sant√©
```


::: {.write}
Tracez la courbe √©pid√©mique pour les deux zones en alerte en ajustant votre code et en utilisant `facet_wrap()`.
:::


Consultez le satellite sur le [faceting](../sessions_extra/faceting.qmd) si vous voulez en savoir plus.


## Indicateurs cl√©s (Question 6)

Nous pouvons calculer plus d'indicateurs sur les zones de sant√© pour nous aider √† d√©cider laquelle devrait faire l'objet d'une enqu√™te (vu que vous n'avez pas le temps ni les ressources pour investiguer les deux).

::: {.callout-tip}
Cette partie utilise les fonctions d'aggr√©gation vues quand nous avons appris √† faire des [tableaux r√©sum√©s](../sessions_core/05_summary_table.qmd). N'h√©sitez pas √† vous rafra√Æchir la m√©moire si besoin.
:::


### Premi√®re semaine en alerte

::: {.write}
Utilisez la fonction `summarize()` pour afficher les premi√®res semaines o√π les ZS sont pass√©es en alerte. Quelle zone de sant√© a √©t√© en alerte en premier ?
:::


### Indicateurs des donn√©es de surveillance

Reprenons le jeu de donn√©es de surveillance avec toutes les colonnes, `df_surv`.

::: {.write}
1. Ajoutez-lui une colonne `cas_moins_5ans` qui contient le nombre total de cas rapport√©s ayant moins de cinq ans.

2. D√©rivez, pour chaque zone en alerte, les indicateurs suivants, organis√©s en un seul tableau : 

- Le nombre de cas
- Le nombre de morts
- Le nombre de moins de cinq ans
- La mortalit√© en pourcentage
- Le pourcentage de moins de cinq ans.

Le r√©sultat ressemble √† : 

```{r}
#| echo: false
#| eval: true

df_surv |>
  filter(zone_sante %in% zone_sante_alertee) |>
  mutate(cas_moins_5ans = cas011mois + cas1259mois) |>
  summarise(
    .by = zone_sante,
    
    n_cas     = sum(totalcas, na.rm = TRUE),
    n_deces   = sum(totaldeces, na.rm = TRUE),
    n_moins_5 = sum(cas_moins_5ans, na.rm = TRUE),
    p_moins_5 = 100 * n_moins_5 / n_cas,
    mortalite = 100 * n_deces / n_cas
  )
```
:::


### Indicateurs des donn√©es labo

Int√©ressons-nous √† pr√©sent aux donn√©es de laboratoire pour compl√©ter les indicateurs pr√©c√©dents.

::: {.write}
Pour chacune des zones en alerte, d√©rivez les indicateurs suivants :

- Le nombre de patients test√©s pour la rougeole
- Le nombre de positifs pour la rougeole
- La proportion de positifs pour la rougeole
- Le nombre de patients test√©s pour la rub√©ole
- Le nombre de positifs pour la rub√©ole
- La proportion de positifs pour la rub√©ole

Le r√©sultat devrait ressembler √† ceci :

```{r}
#| echo: false
#| eval: true

df_labo |>
  filter(zone_sante %in% zone_sante_alertee) |>
  
  summarise(
    .by = zone_sante,
    
    n_test_roug     = sum(!is.na(igm_rougeole)),
    n_test_roug_pos = sum(igm_rougeole == "positif", na.rm = TRUE),
    positivite_roug = n_test_roug_pos / n_test_roug,
    
    n_test_rub     = sum(!is.na(igm_rubeole)),
    n_test_rub_pos = sum(igm_rubeole == "positif", na.rm = TRUE),
    positivite_rub = n_test_rub_pos / n_test_rub
  )
```
:::

::: {.callout-tip}
Si vous avez du mal avec cette question, rafra√Æchissez-vous sur les [r√©sum√©s conditionnels](../sessions_core/05_summary_table.qmd#sec-summary-cond).
:::


## C'est fini !

Bravo, vous √™tes venus √† bout de ce tutoriel !

```{r}
#| echo: false
#| eval: true

downloadthis::download_link(
  link = 'https://github.com/epicentre-msf/repicentre/blob/main/solutions/extra/surveillance_module_solutions_fr.R',
  button_label = 'Solutions',
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```


## Aller plus loin {#sec-going-further}

### Explications sur `complete()`

Nous allons ici donner quelques √©l√©ments pour comprendre un peu les arguments de la fonction `complete()`.

Cr√©ons un mini exemple o√π la zone de sant√© de Kitenge n'a pas de ligne pour la semaine 2 :

```{r}
#| eval: true

# Data frame simplifi√©, avec seulement trois semaines
exemple_df = data.frame(
  province   = c("haut_katanga", "haut_katanga", "haut_katanga", "haut_lomami", "haut_lomami"),
  zone_sante = c("likasi", "likasi", "likasi", "kitenge", "kitenge"),
  semaine    = c(1, 2, 3, 1, 3),
  totalcas  = c(2, 1, 3, 1, 2))

exemple_df
```

C'est probl√©matique si l'on veut calculer une somme cumul√©e.

Nous pouvons utiliser le code suivant pour compl√©ter toutes les zones de sant√© pour qu'elles aient toutes les semaines possibles, ici les semaines une √† trois : 

```{r}
#| eval: true

# Compl√®te la semaine manquante √† Kitenge
exemple_df |> 
  complete(
    nesting(province, zone_sante), # Par province et zone, les explications arrivent juste apr√®s !
    semaine = seq(1, 3),           # Vecteur de 1 √† 3
    fill = list(totalcas = 0)      # Remplir avec des z√©ros (sinon, NA par d√©faut)
  ) 
```

Maintenant les deux zones de sant√© dans les deux provinces ont toutes les semaines possibles.

Pourquoi nous avons √©crit `nesting(province, zone_sante)` au lieu de `zone_sante` tout simplement ? C'est qu'il pourrait y avoir deux zones de sant√© avec le m√™me nom dans des provinces diff√©rentes. Nous devons donc tenir compte de la colonne `province`. La fonction `nesting()` indique √† la fonction `complete()` de n'utiliser *que les combinaisons existantes* des deux colonnes dans le data frame.


::: {.callout-note}
Petit encart pour voir ce qui se serait pass√© si nous avions pass√© les deux colonnes √† la fonction `complete()` sans utiliser `nesting()` : la fonction aurait cr√©√© *toutes les combinaisons possibles* entre les cat√©gories des colonnes `province` et `zone_sante`, ce qui n'a pas de sens dans le cas pr√©sent.

```{r}
#| eval: true

exemple_df |> 
  complete(
    province, zone_sante, 
    semaine = seq(1, 3),  # Vecteur de 1 √† 3
    fill = list(totalcas = 0)
  ) 
```
:::


Comme le jeu de donn√©es va √™tre mise √† jour chaque semaine, il serait pratique de choisir *automatiquement* la plage des semaines qui doivent √™tre pr√©sentes dans les donn√©es.
Pour √ßa, il suffit de remplacer les valeurs cod√©es *en dur* par la plus petite semaine existante dans les donn√©es et la plus grande :

```{r}
#| eval: true

exemple_df |> 
  complete(
    nesting(province, zone_sante),
    semaine = seq(min(semaine, na.rm = TRUE),   # Vecteur allant du minimum
                  max(semaine, na.rm = TRUE)),  # au maximum de la colonne `semaine`
    fill = list(totalcas = 0)
  ) 
```


### Explications sur `rollaply()` 

Pour calculer la somme cumul√©e des cas sur trois semaines il nous faut *appliquer* (*apply* en anglais) la fonction `rollaply()` sur des fen√™tres glissantes de trois semaines.

```{r}
#| eval: true

# Vecteur pour les exemples
exemple_vect <- rep(1, time = 10)
exemple_vect

rollapply(
  data  = exemple_vect,
  width = 3,       # Largeur de la fen√™tre
  FUN   = sum,     # Fonction √† appliquer (ici, la somme)
  align = "right"  # Calcul dans le pass√©
)
```

Nous avons fourni en entr√©e un vecteur de 10 valeurs et obtenu en sortie un vecteur contenant les sommes. Manifestement, la fonction a fait des choix sur comment traiter les extr√©mit√©s, et le r√©sultat est plus court que le vecteur d'entr√©e. Ce dernier point est un probl√®me si l'on veut utiliser la fonction dans un `mutate()`, qui cr√©e des colonnes dans un data frame, o√π toutes les colonnes ont la m√™me taille.

Il est possible de contr√¥ler le comportement de la fonction aux extr√©mit√©s : 

- Remplir les lignes pour lesquelles il n'y a pas assez de valeurs dans la fen√™tre avec des `NA`
- Autoriser des calculs partiels (ici, des sommes partielles, en d'autres termes des valeurs ne repr√©sentent pas la somme sur *trois* semaines, mais moins).

L'argument `fill = NA` remplit les valeurs manquantes aux extr√©mit√©s concern√©es avec des `NA` (dans notre cas, √† gauche, vu que l'on a align√© la fen√™tre √† droite) :

```{r}
#| eval: true
rollapply(
  data  = exemple_vect,
  width = 3,       # Largeur de la fen√™tre
  FUN   = sum,     # Fonction √† appliquer (ici, la somme)
  align = "right", # Calcul dans le pass√©
  fill  = NA
)
```

C'est souvent une fa√ßon raisonnable de g√©rer les valeurs aux extr√©mit√©s o√π les fen√™tres ne sont pas compl√®tes. N√©anmoins, dans notre cas, nous pouvons faire mieux. En effet, imaginons qu'il y ait 40 cas lors de la premi√®re semaine : m√™me si nous n'avons pas de valeurs pour les deux semaines pr√©c√©dentes, l'alerte devrait √™tre d√©clench√©e ! Nous voudrions donc que la somme cumul√©e soit calcul√©e *d√®s la premi√®re semaine* pour pouvoir d√©tecter des alertes pr√©coces ! L'argument `partial = TRUE` permet cela :

```{r}
#| eval: true
rollapply(
  data    = exemple_vect,
  width = 3,        # Largeur de la fen√™tre
  FUN   = sum,      # Fonction √† appliquer (ici, la somme)
  align = "right",  # Calcul dans le pass√©
  partial = TRUE    # Autorise les sommes partielles aux extr√©mit√©s
  )
```

C'est mieux dans notre cas d'usage. 

::: {.callout-important}
Gardez √† l'esprit que les deux premi√®res valeurs du vecteur (ou de la colonne) contiennent donc des sommes *partielles*. En cons√©quence, une *absence d'alerte* dans les deux premi√®res semaines ne veut pas forcement dire qu'il n'y a pas d'alerte.
:::

Un dernier point : rappelez-vous qu'il faut utiliser `na.rm = TRUE` pour ignorer les valeurs manquantes dans la plupart des op√©rations arithm√©tiques dans R.

Si nous avions un vecteur un peu moins complet, nous aurions des probl√®mes :

```{r}
#| eval: true

exemple_vect_na <- c(1, 1, 1, NA, 1, 1)

rollapply(
  data  = exemple_vect_na,
  width = 3,       # Largeur de la fen√™tre
  FUN   = sum,     # Fonction √† appliquer (ici, la somme)
  align = "right", # Calcul dans le pass√©
  partial = TRUE   # Autorise les sommes partielles aux extr√©mit√©s
)
```

Oups. Heureusement, nous pouvons passer l'argument `na.rm = TRUE` √† la fonction `rollapply()` pour qu'elle le passe √† la fonction `sum()`.

```{r}
#| eval: true

rollapply(
  data  = exemple_vect_na,
  width = 3,       # Largeur de la fen√™tre
  FUN   = sum,     # Fonction √† appliquer (ici, la somme)
  align = "right", # Calcul dans le pass√©
  partial = TRUE,  # Autorise les sommes partielles aux extr√©mit√©s
  na.rm = TRUE     # Argument en plus non nomm√© √† passer √† sum()
)
```


Enfin, quelques mots sur l'argument `align`. Il d√©finit la position de la fen√™tre glissante par rapport √† la valeur en train d'√™tre calcul√©e.
Par d√©faut la fen√™tre est centr√©e autour de la valeur √† calculer : la valeur calcul√©e *i* est la somme des valeurs *i-1* (la valeur de la ligne pr√©c√©dente) et la valeur *i+1* (la valeur de la ligne suivante).

Exemples des trois alignements (en mettant des valeurs manquantes aux extr√©mit√©s pour voir plus facilement ce qui se passe) :


```{r}
#| eval: true

# Alignement √† gauche : la valeur est la somme des valeurs suivantes dans le data frame
rollapply(data  = c(5, 10, 1, 2, 5, 10),
          width = 3, 
          FUN   = sum,
          align = "left", 
          fill = NA)

# Alignement centr√© : somme des valeurs de chaque c√¥t√©
rollapply(data  = c(5, 10, 1, 2, 5, 10),
          width = 3, 
          FUN   = sum,
          align = "center",
          fill = NA)  # The default

# Alignement √† droite : somme des valeurs pr√©c√©dentes dans le data frame
rollapply(data  = c(5, 10, 1, 2, 5, 10),
          width = 3, 
          FUN   = sum,
          align = "right",
          fill = NA)
```

Dans notre cas, nous voulons que la valeur pour une semaine donn√©e refl√®te cette semaine et les deux semaines pr√©c√©dentes, donc nous utilisons l'argument `align = "right"`, pour calculer *dans le pass√©* (si le data frame est tri√© dans l'ordre chronologique pour chaque zone de sant√© !).


::: {.callout-tip}
Dans ce tutoriel nous avons appliqu√© la fonction `sum()` √† des fen√™tres de trois semaines pour calculer une *somme cumul√©e*. Mais le code peut √™tre facilement modifi√© pour calculer une *moyenne glissante* sur une fen√™tre de votre choix !
:::

### Formatage  des pourcentages

La fonction `percent()` du paquet `{scales}` formate une valeur ou un vecteur de valeurs en pourcentages.

```{r}
scales::percent(0.8556)
```

Il y a un argument `accuracy` pour contr√¥ler le nombre de d√©cimales √† afficher : 

```{r}
scales::percent(0.8556,
                accuracy = 0.1)
```

Vous pouvez fournir un vecteur (ou une colonne !) de proportions √† la fonction pour afficher les valeurs en pourcentages, ce qui est plus lisible dans un tableau r√©sum√©. 

::: {.callout-important}
La colonne ainsi cr√©e *n'est plus* une colonne num√©rique : l'ajout du signe `%` transforme la colonne en texte. Vous ne pourrez donc plus effectuer d'op√©rations arithm√©tiques dessus.
:::
